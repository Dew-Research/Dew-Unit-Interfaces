










(*<summary>Adds operator overloading support.</summary>
  
<remarks>The unit declares Vector and Matrix types for +, -, *, / operator support.
</remarks>
*)
unit MtxExpr;


interface

{$I bdsppdefs.inc}

uses MtxVec, Math387, AbstractMtxVec, AbstractMtxVecInt, MtxVecBase, MtxVecInt, MtxExprInt
     
     
     ,Classes
      ,Types 
     

     
     
          ,Nmkl
     
     
          ,NmklSingle
     
     ;


    {$HPPEMIT END '#include "MtxExpr.h"'}

    {$HPPEMIT '#include <memory>'}
    {$HPPEMIT '#include <string>'}




type

  
  
  
      {$RTTI EXPLICIT METHODS([])}
  
  
  (*<summary>Vector class for operator overloading (Delphi 2006 and later).</summary>
      
<remarks>Declare Vector instead of TVec to take advantage of
      operator overloading in D2006 and later. Be carefull to declare
      Vector only for local variables with short lifetime.
      Call the Create method for Vector, if the variable is
      a global variable or a variable with a longer life.
      It also makes sense to continue to use TVec for global vars.
      If the Create method (constuctor) is not called, the Vector
      record obtains TVec object from object cache (fastest create).
      If the Create mehod is called, the TVec object is created in
      the usual way (slower). Object cache has limited size.
</remarks>


      <Example>
      <code>
      var b, c: Vector;
          bv: TVec;
      begin
            b := Vector(TDoubleArray.Create(1,1,1,1));
            b := [1,1,1,1]; //or like this
            bv := b;  // b and bv point to same data object

            bv.Scale(2);
            TVec(b).Scale(2);  //an alternative way to scale
            c := b*2 + Cplx(2,3); c := b*2 + 2 + 3i

            c := b*bv; // mix Vector and TVec per element multiply

            bv.Add(c); //pass Vector type and implicitely convert to TVec
      end;
      </code>
      </Example>*)
  Vector = record 
  strict private
    
    FData: TVec;
    

    

    
  private
    function get_Data: TVec ; 
    property Data: TVec read get_Data;
  
  private
  
    function get_Precision: TPrecision;
    function get_Rounding: TRounding;
    function get_BlockEnd: boolean;
    function get_ComplexValues: string;
    function get_RealValues: string;
    procedure set_Precision(const value: TPrecision);
    procedure set_Rounding(const value: TRounding);
    procedure set_Alfa(const value: TCplx);
    procedure set_Beta(const value: TCplx);
    function get_Alfa: TCplx;
    function get_Beta: TCplx;
    procedure set_ZeroTolerance(const value: double);
    function get_IsSubRange: boolean;
    function get_SubRangeLevel: integer;
    function get_ZeroTolerance: double;
    function get_Caption: string;
    function get_Complex: boolean;
    function get_ConditionCheck: boolean;
    function get_Length: integer;
    function get_Tag: integer;
    procedure set_Caption(const value: string);
    procedure set_Complex(const value: boolean);
    procedure set_ConditionCheck(const value: boolean);
    procedure set_Length(const value: integer);
    procedure set_Tag(const value: integer);
    function get_FFTOddLength: boolean;
    function get_FFTScrambled: boolean;
    function get_FFTStorageFormat: TFFTStorageFormat;
    procedure set_FFTOddLength(const value: boolean);
    procedure set_FFTScrambled(const value: boolean);
    procedure set_FFTStorageFormat(const value: TFFTStorageFormat);

    
    function get_CValues(const Indx: integer): TCplx; 
    function get_Values(const Indx: integer): double;  
    procedure set_CValues(const Indx: integer; const value: TCplx); 
    procedure set_Values(const Indx: integer; const value: double); 

    function get_SCValues(const Indx: integer): TSCplx;  
    function get_SValues(const Indx: integer): single;  
    procedure set_SCValues(const Indx: integer; const value: TSCplx); 
    procedure set_SValues(const Indx: integer; const value: single); 

    function GetSelect(const Indx, Len: integer): Vector; 
    procedure SetSelect(const Indx, Len: integer; const Value: Vector); 

    function GetSelectIndex(const startIndex, Step, stopIndex: integer): Vector;
    procedure SetSelectIndex(const startIndex, Step, stopIndex: integer;  const Value: Vector);

    
    function get_Capacity: Int64;
    procedure set_Capacity(const value: Int64);
    function get_CapacityStep: double;
    procedure set_CapacityStep(const value: double);
    function get_FloatPrecision: TMtxFloatPrecision;
    procedure set_FloatPrecision(const value: TMtxFloatPrecision);
    function get_IsDouble: boolean;
    procedure set_IsDouble(const value: boolean);
    function get_First: double;
    function get_Firstc: TCplx;
    function get_Last: double;
    function get_Lastc: TCplx;
  public
    
     


    
    procedure CreateFromCache(Value: boolean);  

    (*<summary>Adopts TVec object.</summary>
      
<remarks>Src object will be adopted by Vector. When the Vector gets out of scope, the Src object
      will be freed.
</remarks>
*)
    procedure Adopt(const Src: TVec); overload;

    
    (*<summary>Adopts aArray memory.</summary>
      
<remarks>Addopts a pointer to AArray array. The method sets the calling vector <see cref="TMtxVec.Complex" text="FloatPrecision"/> property to aFloatPrecision,
      <see cref="Rows"/> to ARows, <see cref="Cols"/> to ACols and Values1D and CValues1D to Pointer(AArray).

      Notes:
        * Required to call the <see cref="Disown"/> method, before freeing the object
        * Do not resize the vector
        * Do not call routines relying on Lapack when cross-platform "Core edition" is used (not linking dlls), because
          Lapack will assume that adopted memory is a dynamic array and will modify array Index -2.
        * TVec.Values array assignment or passing array by var (internal to library) will cause memory corruption in this case.
        * To be used with great care only.
</remarks>


      <SeeAlso cref="Disown"/>*)
    procedure Adopt(AArray: PAPointer; ALength: integer; aFloatPrecision: TMtxFloatPrecision); overload;
    procedure Adopt(AArray: PAPointer; ALength: integer; aIsComplex, aIsDouble: boolean); overload;
    

    (*<summary>Disowns a values pointer.</summary>
      
<remarks>Disowns a values pointer. The Disown method is the opposite of the <see cref="Adopt"/> method. It will set the AArrays to
      Pointer(Values), ALength to vector's <see cref="TMtxVecBase.Length"/> and IsComplex to <see cref="TMtxVec.Complex">Complex</see> property.
      Use the Disown method to "disconnect" AArray from the TVec.Values. Disown sets Values and CValues array pointers to nil and Length property to
      zero, but without freeing the allocated memory. The allocated memory can be disowned only, if it was adopted with a call to
      the <see cref="Adopt"/> method.
</remarks>


      <SeeAlso cref="Adopt"/>*)

    
    procedure Disown(out AArray: PAPointer; out ALength: integer; out aFloatPrecision: TMtxFloatPrecision); overload;
    procedure Disown(out AArray: PAPointer; out ALength: integer; out aIsComplex, aIsDouble: boolean); overload;
    

    (*<summary>Disowns a calling vector values pointer by setting Values, CValues to nil and <see cref="TMtxVecBase.Length" text="Length"/> to 0.</summary>*)
    procedure Disown; overload;

    

    (*<summary>Internally creates TVec object without using object cache.</summary>
                
<remarks>Creates TVec object without using object cache. Suitable for declaring global variables.
</remarks>
*)
    constructor Create(const aLength: integer; const aFloatPrecision: TMtxFloatPrecision); overload;

    
    constructor Create(const aLength: integer); overload;
    
    (*<summary>Uses TVec object as internal storage.</summary>
                
<remarks>The resulting Vector will own Src object of TVec type and will release it once Vector gets out of scope.
</remarks>
*)
    constructor Create(const Src: TVec); overload;  

    (*<summary>Sets the following properties</summary>

      
<remarks><code>
      Vec.Length := ALength;
      Vec.Complex := AComplex;
      </code>
</remarks>
*)
    procedure Size(const aLength: integer; const aIsComplex: boolean; const aIsDouble: boolean); overload;
    function Size(const Src: TMtxVecBase; const aFloatPrecision: TMtxFloatPrecision): TMtxVec; overload;

    
    procedure Size(const aLength: integer; const aIsComplex: boolean); overload;
    

    (*<summary>Returns true, if Left and Right are of equal Length and Values.</summary>

      
<remarks><code>
        var a,b: Vector;
            c: TDoubleArray;
        begin
            c := TDoubleArray.Create(1,1,1,1,1);
            TVec(a).CopyFromArray(c);
            TVec(a).Copy(b);
            if a = b then ERaise('a and b are equal!');

            if a = 1 then ERaise('a equals 1!');   //compare to real value

            if a = Cplx(1,0) then ERaise('a equals 1!'); //compare to complex value
        end;
        </code>
</remarks>


     <SeeAlso cref="TVec.Equal"/>
     <SeeAlso cref="TMtxVec.IsEqual"/>*)
    class operator Equal(const Left, Right: Vector): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>*)
    class operator Equal(const Left: Vector; Right: double): Boolean;
    (*<summary>Returns true, if all elements of Right are equal to Left.</summary>*)
    class operator Equal(Left: double;const Right: Vector): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>*)
    class operator Equal(const Left: Vector;const Right: TCplx): Boolean;
    (*<summary>Returns true, if all elements of Right are equal to Left.</summary>*)
    class operator Equal(const Left: TCplx; const Right: Vector): Boolean;
    (*<summary>Returns true, if Left and Right are of equal Length and Values.</summary>*)
    class operator Equal(const Left: TMtxVec; const Right: Vector): Boolean;
    (*<summary>Returns true, if Left and Right are of equal Length and Values.</summary>*)
    class operator Equal(const Left: Vector; const Right: TMtxVec): Boolean;

    (*<summary>Returns true, if Left and Right are not equal.</summary>
       
<remarks>Returns true, if Left and Right do not have equal Length and Values.
       TMtxVec.IsEqual is called with tolerance 0.

        <code>

        var a,b: Vector;
        begin
            a := Vector(TDoubleArray.Create(1,1,1,1,1));
            if a &lt;&gt; b then ERaise('a and b are not equal!');

            if a &lt;&gt; 1 then ERaise('a does not equals 1!');   //compare to real value

            if a &lt;&gt; Cplx(1,0) then ERaise('a does not equals 1!'); //compare to complex value
        end;
        </code>
</remarks>


     <SeeAlso cref="TVec.Equal"/>
     <SeeAlso cref="TMtxVec.IsEqual"/>*)
    class operator NotEqual(const Left, Right: Vector): Boolean;
    (*<summary>Returns true, if any elements of Left are not equal to Right.</summary>*)
    class operator NotEqual(const Left: Vector; const Right: double): Boolean;
    (*<summary>Returns true, if any elements of Right are not equal to Left.</summary>*)
    class operator NotEqual(const Left: double;const Right: Vector): Boolean;
    (*<summary>Returns true, if any elements of Left are not equal to Right.</summary>*)
    class operator NotEqual(const Left: Vector;const Right: TCplx): Boolean;
    (*<summary>Returns true, if any elements of Right are not equal to Left.</summary>*)
    class operator NotEqual(const Left: TCplx;const Right: Vector): Boolean;
    (*<summary>Returns true, if Left and Right do not have equal Length and Values.</summary>*)
    class operator NotEqual(const Left: TMtxVec; const Right: Vector): Boolean;
    (*<summary>Returns true, if Left and Right do not have equal Length and Values.</summary>*)
    class operator NotEqual(const Left: Vector; const Right: TMtxVec): Boolean;


    (*<summary>Returns true, if Left is less than Right.
      Returns true, if all elements in ALeft are less than ARight.</summary>*)
    class operator LessThan(const ALeft: Vector; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is smaller from all elements in ARight.</summary>*)
    class operator LessThan(const ALeft: TCplx; const ARight: Vector): Boolean;
    (*<summary>Returns true, if all elements of ALeft are smaller from ARight.</summary>*)
    class operator LessThan(const ALeft: Vector; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is smaller from all elements in ARight.</summary>*)
    class operator LessThan(const ALeft: double; const ARight: Vector): Boolean;
    (*<summary>Returns true, if coresponding elements in ALeft are greater than
      coresponding elements in ARight.</summary>*)
    class operator LessThan(const ALeft: Vector; const ARight: Vector): Boolean;

    (*<summary>Returns true, if Left is less than or equal to Right.</summary>*)
    class operator LessThanOrEqual(const ALeft: Vector; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is smaller or equal from all elements in ARight.</summary>*)
    class operator LessThanOrEqual(const ALeft: TCplx; const ARight: Vector): Boolean;
    (*<summary>Returns true, if all elements of ALeft are smaller or equal from ARight.</summary>*)
    class operator LessThanOrEqual(const ALeft: Vector; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is smaller or equal from all elements in ARight.</summary>*)
    class operator LessThanOrEqual(const ALeft: double; const ARight: Vector): Boolean;
    (*<summary>Returns true, if coresponding elements in ALeft are smaller than or equal from
      coresponding elements in ARight.</summary>*)
    class operator LessThanOrEqual(const ALeft: Vector; const ARight: Vector): Boolean;

    (*<summary>Returns true, if Left is greater than or equal to Right.</summary>*)
    class operator GreaterThanOrEqual(const ALeft: Vector; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is greater or equal from all elements in ARight.</summary>*)
    class operator GreaterThanOrEqual(const ALeft: TCplx; const ARight: Vector): Boolean;
    (*<summary>Returns true, if all elements of ALeft are greater or equal from ARight.</summary>*)
    class operator GreaterThanOrEqual(const ALeft: Vector; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is greater or equal from all elements in ARight.</summary>*)
    class operator GreaterThanOrEqual(const ALeft: double; const ARight: Vector): Boolean;
    (*<summary>Returns true, if coresponding elements in ALeft are greater or equal from
      coresponding elements in ARight.</summary>*)
    class operator GreaterThanOrEqual(const ALeft: Vector; const ARight: Vector): Boolean;

    (*<summary>Returns true, if Left is greater than Right.</summary>*)
    class operator GreaterThan(const ALeft: Vector; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is greater from all elements in ARight.</summary>*)
    class operator GreaterThan(const ALeft: TCplx; const ARight: Vector): Boolean;
    (*<summary>Returns true, if all elements of ALeft are greater from ARight.</summary>*)
    class operator GreaterThan(const ALeft: Vector; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is greater from all elements in ARight.</summary>*)
    class operator GreaterThan(const ALeft: double; const ARight: Vector): Boolean;
    (*<summary>Returns true, if coresponding elements in ALeft are greater than
      coresponding elements in ARight.</summary>*)
    class operator GreaterThan(const ALeft: Vector; const ARight: Vector): Boolean;

    (*<summary>Add left to all elements in Right and return result.</summary>*)
    class operator Add(const Left: TCplx; const Right: Vector): Vector;
    (*<summary>Add Right to all elements in Left and return result.</summary>*)
    class operator Add(const Left: Vector; const Right: TCplx): Vector;
    (*<summary>Add Left to all elements in Right and return result.</summary>*)
    class operator Add(const Left: double;const Right: Vector): Vector;
    (*<summary>Add Right to all elements in Left and return result.</summary>*)
    class operator Add(const Left: Vector; const Right: double): Vector;
    (*<summary>Add coresponding elements in Left and Right.</summary>*)
    class operator Add(const Left: TMtxVec;const Right: Vector): Vector;
    (*<summary>Add coresponding elements in Left and Right.</summary>*)
    class operator Add(const Left: Vector; const Right: TMtxVec): Vector;
    (*<summary>Add coresponding elements in Left and Right.</summary>*)
    class operator Add(const Left: Vector;const Right: Vector): Vector;

    (*<summary>Subtract all elements in Right from Left.</summary>*)
    class operator Subtract(const Left: TCplx;   const Right: Vector): Vector;
    (*<summary>Subtract Right from all elements in Left.</summary>*)
    class operator Subtract(const Left: Vector; const Right: TCplx): Vector;
    (*<summary>Subtract all elements in Right from Left.</summary>*)
    class operator Subtract(const Left: double; const Right: Vector): Vector;
    (*<summary>Subtract Right from all elements in Left.</summary>*)
    class operator Subtract(const Left: Vector; const Right: double): Vector;
    (*<summary>Subtract coresponding elements in Right from Left.</summary>*)
    class operator Subtract(const Left: Vector; const Right: TMtxVec): Vector;
    (*<summary>Subtract coresponding elements in Right from Left.</summary>*)
    class operator Subtract(const Left: TMtxVec; const Right: Vector): Vector;
    (*<summary>Subtract coresponding elements in Right from Left.</summary>*)
    class operator Subtract(const Left: Vector;const Right: Vector): Vector;

    (*<summary>Multiply all elements in Left with Right.</summary>*)
    class operator Multiply(const Left: Vector; const Right: TCplx): Vector;
    (*<summary>Multiply all elements in Right with Left.</summary>*)
    class operator Multiply(const Left: TCplx; const Right: Vector): Vector;

    (*<summary>Multiply all elements in Left with Right.</summary>*)
    class operator Multiply(const Left: Vector; const Right: double): Vector;
    (*<summary>Multiply all elements in Right with Left.</summary>*)
    class operator Multiply(const Left: double; const Right: Vector): Vector;
    (*<summary>Multiply all elements in Left with corresponding elements in Right.</summary>*)
    class operator Multiply(const Left: Vector; const Right: TMtxVec): Vector;
    (*<summary>Multiply all elements in Left with corresponding elements in Right.</summary>*)
    class operator Multiply(const Left: TMtxVec; const Right: Vector): Vector;
    (*<summary>Multiply all elements in Left with corresponding elements in Right.</summary>*)
    class operator Multiply(const Left: Vector; const Right: Vector): Vector;

    (*<summary>Divide all elements in Left with Right.</summary>*)
    class operator Divide(const Left: Vector; const Right: TCplx): Vector;
    (*<summary>Divide Left with all elements Right.</summary>*)
    class operator Divide(const Left: TCplx; const Right: Vector): Vector;
    (*<summary>Divide all elements in Left with Right.</summary>*)
    class operator Divide(const Left: Vector; const Right: double): Vector;
    (*<summary>Divide Left with all elements Right.</summary>*)
    class operator Divide(const Left: double; const Right: Vector): Vector;

    (*<summary>Divide all elements in Left with coresponding elements in Right.</summary>*)
    class operator Divide(const Left: Vector; const Right: TMtxVec): Vector;
    (*<summary>Divide all elements in Left with coresponding elements in Right.</summary>*)
    class operator Divide(const Left: TMtxVec; const Right: Vector): Vector;
    (*<summary>Divide all elements in Left with coresponding elements in Right.</summary>*)
    class operator Divide(const Left: Vector; const  Right: Vector): Vector;

    (*<summary>Negates all values inside AValue.</summary>*)
    class operator Negative(const AValue: Vector): Vector;

    

    (*<summary>Explicitely convert array of complex values to Vector.</summary>
     
<remarks>Copies all values from the complex array to the result.
</remarks>
*)
    class operator Explicit(const AValue: TCplxArray): Vector;
    (*<summary>Explicitely convert array of double values to Vector.</summary>
      
<remarks>Copies all values from the double array to the result.
</remarks>
*)
    class operator Explicit(const AValue: TDoubleArray): Vector;
    (*<summary>Explicitely convert array of single values to Vector.</summary>
      
<remarks>Copies all values from the AValue array to the result.
</remarks>
*)
    class operator Explicit(const AValue: TSingleArray): Vector;
    (*<summary>Explicitely convert TVec to Vector.</summary>
      
<remarks>Copies all values from AValue to the result.
</remarks>
*)
    class operator Explicit(const AValue: TVec): Vector;

    (*<summary>Explicitely convert TVecInt to Vector.</summary>
      
<remarks>Copies all values from AValue to the result.
</remarks>
*)
    class operator Explicit(const AValue: TVecInt): Vector;

    (*<summary>Explicitely convert VectorInt to Vector.</summary>
      
<remarks>Copies all values from AValue to the result.
</remarks>
*)
    class operator Explicit(const AValue: VectorInt): Vector;

    (*<summary>Explicitely convert Vector to VectorInt.</summary>
      
<remarks>Copies all values from AValue to the result.
</remarks>
*)
    class operator Explicit(const AValue: Vector): VectorInt;

    (*<summary>Explicitely convert Vector to array of doubles.</summary>
      
<remarks>Copies all values from AVector to an array of double.
</remarks>
*)
    class operator Explicit(const AValue: Vector): TDoubleArray;
    (*<summary>Explicitely convert Vector to array of doubles.</summary>
      
<remarks>Copies all values from AVector to an array of single.
</remarks>
*)
    class operator Explicit(const AValue: Vector): TSingleArray;

    
    

    
    (*<summary>Implicit type conversion from Vector to PSCplx.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Vector.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Vector): Math387.PPSCplx;

    (*<summary>Implicit type conversion from Vector to an array of double.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Vector.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Vector): System.PDouble;

    (*<summary>Implicit type conversion from Vector to PSingle.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Vector.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Vector): System.PSingle;

    (*<summary>Implicit type conversion from Vector to PCplx.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Vector.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Vector): Math387.PPCplx;

    (*<summary>Implicit type conversion from Vector to an array of TCplx.</summary>
      
<remarks>Returns a pointer to the internal array of values.
      Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Vector): TCplxArray;

    (*<summary>Implicit type conversion from Vector to an array of double.</summary>
      
<remarks>Returns a pointer to the internal array of values.
      Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Vector): TDoubleArray;

    (*<summary>Implicit type conversion from Vector to an array of TCplx.</summary>
      
<remarks>Returns a pointer to the internal array of values.
      Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Vector): TSCplxArray;

    (*<summary>Implicit type conversion from Vector to an array of double.</summary>
      
<remarks>Returns a pointer to the internal array of values.
      Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Vector): TSingleArray;

    

    
    (*<summary>Implicit type conversion from Vector to TVec.</summary>
      
<remarks>Returns a pointer to the internal TVec object.
</remarks>
*)
    class operator Implicit(const AValue: Vector): TVec;    
    (*<summary>Returns a pointer to the internal TVec object.</summary>*)
    class operator Implicit(const AValue: Vector): TMtxVec;   
    (*<summary>Returns a pointer to the internal TVec object.</summary>*)
    class operator Implicit(const AValue: Vector): TDenseMtxVec;   
    (*<summary>Returns a pointer to the internal TVec object.</summary>*)
    class operator Implicit(const AValue: Vector): TMtxVecBase;   
    (*<summary>Returns a pointer to the internal TVec object.</summary>*)
    
    class operator Implicit(const AValue: Vector): TObject;  
    


    (*<summary>Constructor of the record.</summary>
      
<remarks>Returns a Vector with internal TVec object created from  object cache (CreateIt),
      if FromObjectCache is True. Pass false to the constructor,
      if the variable is a global variable. Object cache has limited size and is to be
      used only for local variables.
</remarks>
*)
    constructor Create(FromObjectCache: boolean); overload;
    (*<summary>Constructor of the record.</summary>
      
<remarks>Returns a Vector with internal TVec object created explicitely with Length property set to
      aLength and Complex property set to IsComplex. Call this constructor, if the Vector type
      variable is a global variable with a long life span.
</remarks>


      <Example>
       <code>
        var a,b: Vector;
            bvec: TVec;
        begin
            a := Vector.Create(true); //create from object cache via CreateIt

            //this constructor can be omitted, because it is implictely called
            //the first time that the variable is used.
            //However:

            b := Vector.Create(10);

            //Similar to

            bvec := TVec.Create;
            try
                bvec.Size(10);
            finally
                bvec.Free;  //b is freed on the exit from the procedure
            end;
        end;
      </code>
      </Example>

     <SeeAlso cref="TVec.Equal"/>
     <SeeAlso cref="TMtxVec.IsEqual"/>*)
    constructor Create(const aLength: integer; const aIsComplex: boolean; const aIsDouble: boolean); overload;
    
    constructor Create(const aLength: integer; const aIsComplex: boolean); overload;
    
  public
    (*<summary>Defines the length in number of samples.</summary>
      
<remarks>Defines the number of samples that the Vector can store.
      The length property does not map directly to memory reallocation
      when it is changed. Until the amount of preallocated memory
      is not exceed, there is no reallocation going on.

      Changing the Length property will preserve the existing
      values, but only if the new property value is smaller than the
      amount of preallocated memory. To properly resize the memory allocated
      use the <see cref="Resize"/> method.

      It is recommended that vector sizes do not exceed the size of
      preallocated memory to increase performance. The size
      of preallocated memory can be controlled via the Controller global
      variable which is defined in the MtxVec unit.
</remarks>
*)
    property Length: integer read get_Length write set_Length;

    (*<summary>Defines the precision (single, float) and type (real, complex) of the floating point operations. </summary>*)

    property FloatPrecision: TMtxFloatPrecision read get_FloatPrecision write Set_FloatPrecision;
    (*<summary>Enables/disable inline condition checking.</summary>
      
<remarks>Enables/disables inline condition checking. When true, TVec methods perform additional (range)
      checking before operations are executed. The drawback is slight loss of speed. If ConditionCheck is
      set to false then no additional checking is performed. This speeds up the execution but disables some
      safeguards. For short vectors the loss of speed can be significant. The more parameters
      the method requires the more error checking is performed. Some methods (parameterless) don't use the ConditionCheck property at all.
      ConditionCheck property is initially True. This property is an additional safeguard against array overrun or underrun errors.
      It allows you to work with explicit range checking while writing and debugging the application and once your code is running you
      can turn it off. By functionality it is similar to assertions. (See Assert Delphi procedure). You can also use compiler
      directives to check, if assertions are on and then set ConditionCheck to True.
</remarks>


      <SeeAlso cref="CondEnable"/>
      <SeeAlso cref="CondDisable"/>*)
    property ConditionCheck: boolean read get_ConditionCheck write set_ConditionCheck;
    (*<summary>Vector Caption.</summary>
      
<remarks>Use this property to set/get the string caption for the vector.
      This can be usefull for associating description with data when making
      a user interface.
</remarks>
*)
    property Caption: string read get_Caption write set_Caption;
    (*<summary>Stores an integer value as a part of the object.</summary>
      
<remarks>Tag has no predefined meaning.
      The Tag property is provided for the convenience of developers.
      It can be used for storing an additional
      integer value or it can be typecast to any 32-bit value such as a
      component reference or even a pointer.
</remarks>
*)
    property Tag: integer read get_Tag write set_Tag;
    (*<summary>Defines if object values are complex.</summary>
      
<remarks>If true, <see cref="Vector"/> will treat it's elements as complex numbers.
      Two successive number in the values array be treated as real and imaginary
      part of the complex number. When property is false, object will treat it's
      elements as real numbers. You should always set the value of
      the Complex property before setting object size (<see cref="Vector.Length"/>
      for vector or <see cref="Matrix.Rows"/>,<see cref="Matrix.Cols"/> for matrix).
      Setting Complex from true to false does not cause memory reallocation.
      It simply doubles the value of the Length property. Setting Complex from
      false to true halves the vector length or number of matrix columns, but
      retains all data. Complex property is initially false.
</remarks>


      <Example>
      <code>
      var a,b,c,d: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);
          b.SetIt(False,[8,9,6,7]);
          b.Complex := True;
          c.Mul(a,b);   // = [(1+2i)*(8*9i), (3+4i)*(6+7i)]
      end;
      </code>
      </Example>

      <SeeAlso cref="Length"/>*)
    property Complex: boolean read get_Complex write set_Complex;

    (*<summary>FFT storage format.</summary>
      
<remarks>The FFT storage format specifies how will the result of an operation
      be stored in the destination. This affects both 1D and 2D FFT's.
</remarks>
*)
    property FFTStorageFormat: TFFTStorageFormat read get_FFTStorageFormat write set_FFTStorageFormat;

    (*<summary>Leave FFT scrambeled.</summary>
      
<remarks>The last stage (or first) of an FFT, is a sorting operation.
      This sorting will be left out, if this property will be set to True.
      This can improve performance for certain applications, if you used
      properly.
</remarks>
*)
    property FFTScrambled: boolean read get_FFTScrambled write set_FFTScrambled;

    (*<summary>Defines if FFT transform length is odd.</summary>
      
<remarks>The property should be set to True, if the length of a forward real to complex FFT
      is odd and if the result of an inverser complex to real FFT should be odd.
</remarks>
*)
    property FFTOddLength: boolean read get_FFTOddLength write set_FFTOddLength;

    (*<summary>Sizing the object will not allocate less than Capacity samples.</summary>
               
<remarks>To free memory allocated before, first set Capacity to 0.
               In case of complex numbers the size is half here specified.
</remarks>
*)
    property Capacity: Int64 read get_Capacity write set_Capacity;

    (*<summary>Specifies increment step for the Capacity property.</summary>
               
<remarks>If this property is 0, the Capacity will never be modified on its own.
               When the value 1, the capacity will continue increasing to match largest value
               requested. When the value is more than 1, the capacity will be increasing with
               the factor specified.
</remarks>
*)
    property CapacityStep: double read get_CapacityStep write set_CapacityStep;
  public 
    property IsDouble: boolean read get_IsDouble write set_IsDouble;
    (*<summary>Obtains a pointer to the real value of the vector at Index.</summary>
      
<remarks>The function returns @Values[i]. Under .NET this is a pointer
      to unmanaged memory.
</remarks>


     <SeeAlso cref="PCValues1D"/>*)
    function PValues1D(const Index: integer): PPDouble;
    function PSValues1D(const Index: integer): PPSingle;

    (*<summary>Obtains a pointer to the complex value of the vector at Index.</summary>
      
<remarks>The function returns @CValues[i]. Under .NET this is a pointer
      to unmanaged memory.
</remarks>
*)
    function PCValues1D(const Index: integer): PPCplx;
    function PSCValues1D(const Index: integer): PPSCplx;


    (*<summary>Additional parameter for certain Lapack methods.</summary>
      
<remarks>Additional parameter for certain Lapack methods. When this value
      is used, it is mentioned in the method description.
      This parameter has been made a field of the object, to reduce
      the number of parameters required by a method, because it is not
      used very often.
</remarks>
*)
    property Beta: TCplx read get_Beta write set_Beta;
    (*<summary>Additional parameter for certain Lapack methods.</summary>
      
<remarks>Additional parameter for certain Lapack methods. When this value
      is used, it is mentioned in the method description.
      This parameter has been made a field of the object, to reduce
      the number of parameters required by a method, because it is not
      used very often.
</remarks>
*)
    property Alfa: TCplx read get_Alfa write set_Alfa;

    
    property RealValues: string read get_RealValues;
    property ComplexValues: string read get_ComplexValues;
    

    (*<summary>Defines the rounding used by streaming routines.</summary>
      
<remarks>Defines the rounding used by streaming routines.
</remarks>


      <SeeAlso cref="SaveToStream"/>
      <SeeAlso cref="SaveToFile"/>*)
    property Rounding: TRounding read get_Rounding write set_Rounding;
    (*<summary>Defines the precision used by streaming routines.</summary>
      
<remarks>Defines the rounding used by streaming routines.
</remarks>


      <SeeAlso cref="SaveToStream"/>
      <SeeAlso cref="SaveToFile"/>*)
    property Precision: TPrecision read get_Precision write set_Precision;
    (*<summary>Returns true, if the currrent subrange of the vector was also the last subrange in the vector.</summary>
      
<remarks>Returns true, if the currrent subrange of the vector was also the last subrange in the vector.
      This property be used together with <See Method="BlockNext"/> and <See Method="BlockInit"/>.
</remarks>

      <SeeAlso cref="BlockInit"/>
      <SeeAlso cref="BlockNext"/>*)
    property BlockEnd: boolean read Get_BlockEnd;
    (*<summary>Set to true after the SetSubIndex or SetSubRange call.</summary>
      
<remarks>This property is set to true after the <see cref="SetSubIndex"/> or <see cref="SetSubRange"/> call.
      If IsSubRange is true then the TVec method/function will be performed on subrange of values. Use
      <see cref="SetFullRange"/> to set IsSubRange back to False and thus reset sub range to full vector
      length.
</remarks>


      <SeeAlso cref="SetFullRange"/>*)
    property IsSubRange: boolean read get_IsSubRange;
    (*<summary>Returns the current depth of SubRange stack.</summary>*)
    property SubRangeLevel: integer read get_SubRangeLevel;
    (*<summary>The tolerance used by <see cref="IsEqual"/>.</summary>
      
<remarks>The tolerance used by <see cref="IsEqual"/> when the comparison type
      is relative.
</remarks>
*)
    property ZeroTolerance: double read get_ZeroTolerance write set_ZeroTolerance;

    

    (*<summary>Allows setting/getting the real value at position Indx.</summary>
      
<remarks>Allows setting/getting the real value at position Indx.
     This property reads/writes to the same memory as <see cref="CValues"/> properties.
</remarks>
*)
    property Values[const Indx: integer]: double read get_Values write set_Values; default;
    (*<summary>Allows setting/getting the complex value at position Indx.</summary>
      
<remarks>Allows setting/getting the complex value at position Indx.
      This property reads/writes to the same memory as <see cref="Values"/> properties.
</remarks>
*)
    property CValues[const Indx: integer]: TCplx read get_CValues write set_CValues;

    (*<summary>Allows setting/getting the real value at position Indx.</summary>
      
<remarks>Allows setting/getting the real value at position Indx.
     This property reads/writes to the same memory as <see cref="SCValues"/> and <see cref="IValues"/> properties.
</remarks>
*)
    property SValues[const Indx: integer]: single read get_SValues write set_SValues;
    (*<summary>Allows setting/getting the complex value at position Indx.</summary>
      
<remarks>Allows setting/getting the complex value at position Indx.
      This property reads/writes to the same memory as <see cref="SValues"/>
</remarks>
*)
    property SCValues[const Indx: integer]: TSCplx read get_SCValues write set_SCValues;

    (*<summary>Allows copying/assignment of subranges.</summary>
      
<remarks>Reading this property will return a sub-ranged Vector. Similar to calling b.SetSubRange(a, Indx, Len);
      Writing this property will copy source to the specified subrange. The size of the value being assigned
      needs to match the range specified.
</remarks>
*)
    property Select[const Indx, Len: integer]: Vector read GetSelect write SetSelect;

    (*<summary>Allows copying/assignment of subranges.</summary>
      
<remarks>Reading this property will return a copied selection of subranged vector by calling Dst.GatherByIncr(Src, startIndex, Step);
      Writing this property will copy source to the specified range by using Data.ScatterByIncr.
      The size of the value being assigned needs to match the index range specified.
      This property does not obtain a "view" unless Step equals to 1.
</remarks>
*)
    property SelectIndex[const startIndex, Step, stopIndex: integer]: Vector read GetSelectIndex write SetSelectIndex;

    

    (*<summary>Returns content as a string.</summary>
               
<remarks>Values will be separated by line breaks.
</remarks>
*)
    function ToString: string; 

    (*<summary>Parses string content as vector.</summary>
               
<remarks>Values need to be separated by the tab charachter.
               Rows of values need to be separated by line breaks.
               For other parsing options call StringToValues.
               The Parse method works in pair with the ToString method both meant to be a reverse of the other,
               but do not preserve any other property of the matrix except only values.
               Use SaveToStream/LoadFromStream methods for binary storage option, which uses up to 10x less memory and is a lot faster to save and load.
</remarks>
*)
    class function Parse(const Src: string): Vector; static;

    
    procedure AssignWithoutCopy(const Src: Vector);
    procedure Assign(const Src: Vector);
    

    (*<summary>Initializes block processing.</summary>
      
<remarks>Initializes block processing. Because the size of the CPU cache is limited, significant performance gains can be obtained by
      splitting long vectors in to a series of short ones, which can all fit in the CPU cache entirely. The BlockInit method is
      to be used together with <see cref="BlockNext"/> and <See Method="BlockEnd"/> methods to initialize a block processing
      while loop. BlockInit will call <See Method="SetSubRange"/> to obtain subrange of the data in TVec. The <see cref="Length"/>
      of the subranged vector is determined by the global  <see cref="Math387.MtxVecBlockSize"/> variable
      declared in <See Unit="Math387"/> unit. Default value of MtxVecBlockSize is preset to 800 vector elements for double precision
      and 1600 elements for single precision. BlockInit supports nested calls and from witihin a blocked while loop you can call
      procedures and functions which are also blocked. If you use block processing, typical performance gains will range from
      2 to a maximum of 6. Block processing can not be used, or it is difficult to apply, in cases where vector elements are
      not independent of each other. Block processing is a requirement, if threading is to be implemented.
      Without block processing, it is possible that multi-threading will not result in performance improvement regardless of core count, because
      the performance would be memory bandwidth limited.

      The block processing while loop must be written like this:

      <code>
      a.BlockInit;
      while not A.BlockEnd do
      begin
        // .... user defined function
      a.BlockNext.
      end;
      </code>
</remarks>


      <Example>Normal vectorized procedure:

      <code>
      procedure ParetoPDF(const X: TVec; a, b: double; const Res: TVec); overload;
      begin
        Res.Size(X);
        Res.Power(X,-(a+1));
        Res.Mul(Power(b,a)*a);;
      end;
      </code>

      Vectorized and blocked version of the Pareto probability distribution procedure:

      <code>
      procedure ParetoPDF(const X: TVec; a, b: double; const Res: TVec); overload;
      begin
        Res.Size(X);
        Res.BlockInit;
        X.BlockInit;
        while not X.BlockEnd do
        begin
          Res.Power(X,-(a+1));
          Res.Mul(Power(b,a)*a);
          Res.BlockNext;
          X.BlockNext;
        end;
      end;
      </code>

      The block version of the ParetoPDF will execute faster then the non-blocked version in cases
      where X contains 5000-10000 elements or more (double precision). Below that value the two
      versions will perform about the same, except for very short vector sizes (below 50 elements),
      where the non-blocked version will have a slight advantage, because of the absence of block
      processing methods overhead. The time is saved  between the calls  to Res.Power(X,-(a+1))
      and  Res.Mul(Power(b,a)*a), where the same memory (stored in Res vector) is accesed in
      two consecutive calls. That memory is loaded in the CPU cache on the first call, if the
      Length of the Res vector is short enough to fit in. As an excercise you can also try to
      compare the performance of the vectorized and blocked version of the function with the
      single value version (ParetoPDF(X: double; a, b: double; Res: double) and measure
      the execution time of both versions for long vectors (100 000 elements) and short
      vectors (10 elements).

      The differences with block processing will be more noticable on old CPU's without
      support for SSE2/SSE3.
      </Example>

      <SeeAlso cref="BlockNext"/>
      <SeeAlso cref="BlockEnd"/>*)
    procedure BlockInit; overload;
    (*<summary>Initializes block processing.</summary>*)
    procedure BlockInit(ABlockSize: integer); overload;

    (*<summary>Initializes block processing.</summary>*)
    procedure BlockInit(const Src: TDenseMtxVec); overload;

    (*<summary>Initializes block processing.</summary>
               
<remarks>Block processing can be applied on possibly already subranged Src object.
               Src may not be freed or go out of scope until block processing loop has finished. There would
               be no error raised other than AV.
</remarks>
*)
    procedure BlockInit(const Src: TDenseMtxVec; ABlockSize: integer); overload;

    (*<summary>Obtains the next subrange of the data.</summary>
      
<remarks>Obtains the next subrange of the data in TVec. The routine must be used together with
      <see cref="BlockEnd"/> and <see cref="BlockInit"/> methods.
</remarks>


      <SeeAlso cref="BlockInit"/>
      <SeeAlso cref="BlockEnd"/>*)
    procedure BlockNext;

    (*<summary>Deinitializes block processing before the final block is processed.</summary>
               
<remarks>Call this routine before breaking out of a while-loop prematurely.

        <code>

        Vec.BlockInit
        While not Vec.BlockEnd do
        Begin
            If Vec.Min &lt; 0 then //check some condition, if you need to exit
            begin
              Vec.BlockFinish;  //finish the loop
              Break;  //and break out
            end;
            Vec.BlockNext;
        end

        </code>
</remarks>
*)
    procedure BlockFinish;

    (*<summary>Replaces all NAN values with Value.</summary>
               
<remarks>The function will replace all occurences of NAN. If the vector is complex, it will replace any real/imag parts, which are NAN.
</remarks>
*)
    function ReplaceNAN(const Value: double): TMtxVec; overload;

    (*<summary>Replaces all NAN values with Value within calling object elements [Index]..[Index+Len-1].</summary>
               
<remarks>The function will replace all occurences of NAN. If the vector is complex, it will replace any real/imag parts, which are NAN.
               An exception is raised, if array borders are overrun.
</remarks>
*)
    function ReplaceNAN(const Value: double; Index, Len: integer): TMtxVec; overload;

    (*<summary>Prevents calls to <see cref="SetSubRange"/>.</summary>
      
<remarks>Prevents calls to <see cref="SetSubRange"/> method. This can be usefull
      guard when an object is already working on a subrange and the user
      would like to further subrange an already subranged object.
</remarks>


      <Example>

      <code>
      var a,b: Vector;
      begin
          a.SetIt(false, [1,2,3,4,5,6,7,8,9]);
          a.SetSubRange(0,2);  //a = [1,2]
          a.DisableSubrange;
          a.SetSubRange(2,2); //exception raised here

          b.SetSubRange(a,2,2); //but this will work
          a.SetFullRange; //b is not changed, it still points to [4,5]
      end;

    </code>
    </Example>


      <SeeAlso cref="DisableSubrange"/>
      <SeeAlso cref="EnableSubrange"/>*)
    procedure DisableSubrange;

    (*<summary>Enables calls to <see cref="SetSubRange"/>.</summary>
      
<remarks>Enables calls to <see cref="SetSubRange"/> by removing
      the block set by <see cref="DisableSubrange"/>.
</remarks>
*)
    procedure EnableSubrange;

    (*<summary>Prevents calls to <see cref="Select"/>.</summary>
      
<remarks>Prevents calls to <see cref="Select"/> method. This can be usefull
      guard when an object is already working on a subrange and the user
      would like to further subrange an already subranged object.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(false, [1,2,3,4,5,6,7,8,9]);
          a.Select(0,2);  //a = [1,2]
          a.DisableSelect;
          a.Select(2,2); //exception raised here

          b.Select(a,2,2); //but this will work
          a.SelectAll; //b is not changed, it still points to [4,5]
      end;
      </code>
      </Example>

      <SeeAlso cref="DisableSubrange"/>
      <SeeAlso cref="EnableSubrange"/>*)
    procedure DisableSelect;

    (*<summary>Enables calls to <see cref="Select"/>.</summary>
      
<remarks>Enables calls to <see cref="Select"/> by removing
      the block set by <see cref="DisableSelect"/>.
</remarks>
*)
    procedure EnableSelect;

    (*<summary>Resets any defined selection.</summary>
      <SeeAlso cref="Select"/>
      <SeeAlso cref="SetSubIndex"/>*)
    procedure SelectAll; overload;

    (*<summary>Resets any defined subrange.</summary>

      <SeeAlso cref="SetSubRange"/>
      <SeeAlso cref="SetSubIndex"/>*)
    procedure SetFullRange;
    procedure SetFullRangeLevel;

    (*<summary>Defines a sub vector/matrix.</summary>
      
<remarks>The method will define a subarray starting at
      Index and ending at Index+Len-1. No copying will occur, only
      pointers will be shifted.

      All values of the original <see cref="Vector"/> will be preserved.
      An exception will be raised if an attempt is made to
      change the size of calling object.

      A sub-vector/matrix is vector/matrix which does not neccessarily have its own
      memory allocated. Instead it adopts the memory of the
      source object and all operations done on the either of the objects
      affect the same elements. The use of subvectors/submatrices increases
      CPU cache reuse, lower's memory requirements, increases
      application performance and improves code readability.

      Note
        To again obtain a view of the full vector/matrix, see <see cref="SetFullRange"/>
</remarks>
*)
    procedure SetSubRange(Index: integer; Len: integer); overload;
    (*<summary>Defines a sub vector/matrix and pushes previous subrange to internal stack.</summary>
              
<remarks>Call SetSubRangeLevel, to pop the stack.
</remarks>
*)
    procedure SetSubRangeLevel(Index: integer; Len: integer); overload;










































    (*<summary>Sets the subarray size to full size.</summary>
      
<remarks>This method is the same as the <see cref="SetFullRange"/> method.
</remarks>
*)
    procedure SetSubRange; overload;

    (*<summary>Defines a subarray.</summary>
      
<remarks>The method will define a sub array starting at
      BeginIndex and ending at EndIndex (inclusive).
      All values of the original vector/matrix will be preserved.
      An exception will be raised if an attempt is made to
      change the size of calling vector/matrix.

      A subarray is array which does not have its own
      memory allocated. Instead it adopts the memory of the
      source object and all operations done on the either of the objects
      affect the same elements. The use of subarrays increases
      CPU cache reuse, lower's memory requirements, increases
      application performance and improves code readability.

      Note
        To again obtain a view of the full vector see <see cref="SetFullRange"/>
</remarks>
*)
    procedure SetSubIndex(BeginIndex, EndIndex: integer); overload;


    (*<summary>Finds a match for X in sorted object values using binary search.</summary>
               
<remarks>The data in the vector must be sorted in ascending order for this function to work correctly.
</remarks>

      <returns>the Index of last matched element. If no matching elements are found, the result is -1.</returns>*)

    function BinarySearch(const X: double): Integer; overload;
    function BinarySearch(const X: double; const Index: integer; Len: integer): Integer; overload;

    function BinarySearch(const X: TCplx): Integer; overload;
    function BinarySearch(const X: TCplx; const Index: integer; Len: integer): Integer; overload;

    (*<summary>Finds exact or closest Index match for X in sorted object values using binary search.</summary>
               
<remarks>The data in the vector must be sorted in ascending order for this function to work correctly.
               The closest match is the Index of first bigger or smaller value in the array.

      To ensure bigger value write:

      <code>
      Data := [0,2,3];
      Data.BinarySearch(Value, XIndex);
      if Data[XIndex] &gt; Value then Dec(XIndex);
      </code>

      To ensure smaller value write:

      <code>
      Data := [0,2,3];
      Data.BinarySearch(1, XIndex);
      if Data[XIndex] &lt; Value then Inc(XIndex);
      </code>
</remarks>

	  
	  <returns>True and exact Index in XIndex, if found and False and the Index of the next bigger or smaller value in XIndex, if not found. </returns>*)

    function BinarySearch(const X: double; var XIndex: integer): boolean; overload;
    function BinarySearch(const X: double; var XIndex: integer; const Index: integer; Len: integer): boolean; overload;

    function BinarySearch(const X: TCplx; var XIndex: integer): boolean; overload;
    function BinarySearch(const X: TCplx; var XIndex: integer; const Index: integer; Len: integer): boolean; overload;

    (*<summary>Sine.</summary>
      
<remarks>Calculate the sine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[1,-2,3,4]);
          a.Sin; // Computes complex sine
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcSin"/>
      <SeeAlso cref="SinCos"/>*)
    function Sin: TMtxVec; overload;
    (*<summary>Calculate the sine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sin(Index: integer; Len: integer): TMtxVec; overload;
    (*<summary>Calculate the sine of all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sin(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the sine of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are storedin calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sin(const X: TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload; 

    (*<summary>Cosine.</summary>
      
<remarks>Calculate the cosine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[1,-2,3,4]);
          a.Cos; // Computes complex sine
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcCos"/>
      <SeeAlso cref="SinCos"/>*)
    function Cos: TMtxVec; overload;
    (*<summary>Calculate the cosine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cos(Index: integer; Len: integer): TMtxVec; overload;
    (*<summary>Calculate the cosine of all X object elements</summary>
      
<remarks>store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cos(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the cosine of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of calling object and the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cos(const X: TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload;

    (*<summary>Tangens.</summary>
      
<remarks>Calculate the tangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[1,-2,3,4]);
          a.Tan; // Computes complex tangens
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcTan"/>
      <SeeAlso cref="ArcTan2"/>*)
    function Tan: TMtxVec; overload;
    (*<summary>Calculate the tangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Tan (Index: integer; Len: integer): TMtxVec; overload;
    (*<summary>Calculate the tangens of all X object elements.</summary>
      
<remarks>Xtore the results in the calling object.  Size and <see cref="Complex"/> properties of calling object are
      adjusted automatically.
</remarks>
*)
    function Tan(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the tangens of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored
      in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Tan(const X : TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload;

    (*<summary>Cotangens.</summary>
      
<remarks>Calculate the cotangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[1,-2,3,4]);
          a.Cot; // Computes complex cotangens
      end;
      </code>
      </Example>

      <SeeAlso cref="Tan"/>
      <SeeAlso cref="ArcCot"/>*)
    function Cot: TMtxVec; overload;
    (*<summary>Calculate the cotangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cot(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the cotangens of all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cot(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the cotangens of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cot(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Secant.</summary>
      
<remarks>Calculate the secant of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[1,-2,3,4]);
          a.Sec; // Computes complex secant
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcSec"/>
      <SeeAlso cref="Csc"/>*)
    function Sec: TMtxVec; overload;
    (*<summary>Calculate the secant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sec(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the secant of all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> properties of calling
      object are adjusted automatically.
</remarks>
*)
    function Sec(const X: TMtxVec): TMtxVec; overload;
     (*<summary>Calculate the secant of X object elements [XIndex]...[XIndex+Len-1].</summary>
     
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and
     <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sec(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Cosecant.</summary>
      
<remarks>Calculate the cosecant of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[1,-2,3,4]);  // a = [1-2i, 3+4i]
          a.Csc; // Computes complex cosecant
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcCsc"/>
      <SeeAlso cref="Sec"/>*)
    function Csc: TMtxVec; overload;
    (*<summary>Calculate the cosecant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Csc(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the cosecant of all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> properties of calling
      object are adjusted automatically.
</remarks>
*)
    function Csc(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the cosecant of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and
      <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Csc(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>The inverse sine.</summary>
      
<remarks>Calculate the inverse sine of all calling object elements in-place. Values must be between -1 and 1.
      The return values will be in the range [0,PI], in radians.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
        a.SetIt(True,[1,-0.5,0.11,0.9]);
        a.ArcSin;  //or
        b := ArcSin(a);  //or
        a := ArcSin(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Sin"/>*)
    function ArcSin: TMtxVec; overload;
    (*<summary>Calculate the inverse sine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSin(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the inverse sine of all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> properties of calling object
      are adjusted automatically.
</remarks>
*)
    function ArcSin(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the inverse sine of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSin(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>The inverse cosine.</summary>
      
<remarks>Calculate the inverse cosine of all calling object elements in-place. Values must be between -1 and 1.
      The return values will be in the range [0,PI], in radians.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
        a.SetIt(True,[1,-0.5,0.11,0.9]);
        a.ArcCos;  // or
        b := ArcCos(a); // or
        a := ArcCos(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Cos"/>*)
    function ArcCos: TMtxVec; overload; 
    (*<summary>Calculate the inverse cosine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCos(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosine of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCos(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosine of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCos(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse tangens of Y/X.</summary>
      
<remarks>Calculates the inverse tangens of Y/X, and returns an angle in the correct quadrant. The results are stored in
      calling object elements. Size and <see cref="Complex"/> properties of calling object are adjusted automatically
      to match those of X and Y objects. An exception is raised if X and Y size and <see cref="Complex"/> properties do not match.

      The result will fall in the range from -PI to PI radians. Note that <see cref="ArcTan"/> is calculated as ArcTan2(1, X).
</remarks>


      <SeeAlso cref="ArcTan"/>*)
    function ArcTan2(Y, X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of Y/X by using Y elements [YIndex]..[YIndex+Len-1], X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1].
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTan2(Y, X: TMtxVec; YIndex, XIndex, Index: integer; Len: integer): TMtxVec; overload; 

    (*<summary>Inverse tangens.</summary>
      
<remarks>Calculate the inverse tangens for all calling object elements in-place. The return values are expressed in radians.
</remarks>


      <Example>
      <code>
      var A,B: Vector;
      begin
        A.SetIt(2,2,True,[1,0, 2,0
                          2,0  4,1]);  // 2x2, complex matrix
        B.ArcTan(A); // or
        B := ArcTan(A);  // or
        A := ArcTan(A);
      end;
      </code>
      </Example>

      <SeeAlso cref="Tan"/>
      <SeeAlso cref="ArcCot"/>
      <SeeAlso cref="ArcTan2"/>*)
    function ArcTan: TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTan(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> properties of calling
      object are adjusted automatically.
</remarks>
*)
    function ArcTan(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTan(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse cotangens.</summary>
      
<remarks>Calculate the inverse cotangens for all calling object elements in-place. The return values are expressed in radians.
</remarks>


      <Example>
      <code>
      var A,B: Vector;
      begin
        A.SetIt(2,2,True,[1,0, 2,0
                        2,0  4,1]);  // 2x2, complex matrix
        B.ArcCot(A); //or
        B := ArcCot(A);
      end;
      </code>
      </Example>

      <SeeAlso cref="Cot"/>
      <SeeAlso cref="ArcTan"/>*)
    function ArcCot: TMtxVec; overload; 
    (*<summary>Calculate the inverse cotangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCot(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse cotangens of all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCot(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse cotangens of X object elements [XIndex]...[XIndex+Len-1].</summary>
     
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCot(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse secant.</summary>
      
<remarks>Calculate the inverse secant for all calling object elements in-place.
</remarks>


      <SeeAlso cref="Sec"/>
      <SeeAlso cref="ArcCsc"/>*)
    function ArcSec: TMtxVec; overload; 
    (*<summary>Calculate the inverse secant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSec(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse secant of all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> properties of calling
      object are adjusted automatically.
</remarks>
*)
    function ArcSec(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse secant of X object elements [XIndex]...[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSec(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse cosecant.</summary>
      
<remarks>Calculate the inverse cosecant for all calling object elements in-place.
</remarks>


      <SeeAlso cref="Csc"/>
      <SeeAlso cref="ArcSec"/>*)
    function ArcCsc: TMtxVec; overload; 
    (*<summary>Calculate the inverse cosecant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsc(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosecant of all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCsc(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosecant of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsc(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic sine.</summary>
      
<remarks>Calculate the hyperbolic sine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(False,[1,1.5,2,0.3]);
          a.Sinh; // or
          a := Sinh(a); // no speed loss because of copy, internally becomes a.Sinh
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcSinh"/>
      <SeeAlso cref="SinhCosh"/>*)
    function Sinh: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic sine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sinh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic sine of all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sinh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic sine for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sinh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic cosine.</summary>
      
<remarks>Calculate the hyperbolic cosine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,1.5,2,0.3]);
          a.Cosh;  //or
          a := Cosh(a); //internally becomes a.Cosh (in-place operation)
          b.Cosh(a);
          b := Cosh(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcCosh"/>
      <SeeAlso cref="SinhCosh"/>*)
    function Cosh: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosine for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cosh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosine for all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cosh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosine for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored
      in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cosh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic tangens.</summary>
      
<remarks>Calculate the hyperbolic tangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,1.5,2,0.3]);
          a.Tanh; //or
          a := Tanh(a); //same as a.Tanh  (in place operation)
          b := Tanh(a); //not in place
          b.Tanh(a);    //not in place
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcTanh"/>
      <SeeAlso cref="Coth"/>*)
    function Tanh: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic tangens for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Tanh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic tangens for all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Tanh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic tangens for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored
      in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Tanh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic cotangens.</summary>
      
<remarks>Calculate the hyperbolic cotangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,1.5,2,0.3]);
          a.Coth;
          a := Coth(a); //internally becomes a.Coth
          b.Coth(a);   //same as
          b := Coth(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcTanh"/>
      <SeeAlso cref="Coth"/>*)
    function Coth: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cotangens for calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Coth(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cotangens for all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Coth(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cotangens for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored
      in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Coth(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic secant.</summary>
      
<remarks>Calculate the hyperbolic secant of all caling object elements in-place.
</remarks>

      <SeeAlso cref="ArcSech"/>
      <SeeAlso cref="Csch"/>*)
    function Sech: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic secant for calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sech(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic secant for all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sech(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic secant for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored
      in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sech(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic cosecant.</summary>
      
<remarks>Calculate the hyperbolic cosecant of all caling object elements in-place.
</remarks>


      <SeeAlso cref="ArcCsch"/>
      <SeeAlso cref="Sech"/>*)
    function Csch: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosecant for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Csch(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosecant for all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Csch(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosecant for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored
      in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Csch(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 


    (*<summary>Absolute values.</summary>
      
<remarks>Calculate the absolute value of all calling object elemets in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
        a.SetIt(True,[1,-2,3,4]);
        a.Abs;
        a := Abs(a); //same as a.Abs
        b.Abs(a);   //same as b := Abs(a);
        b := Abs(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Mag"/>*)
    function Abs: TMtxVec; overload; 
    (*<summary>Calculate the absolute value for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Abs(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the absolute value for all X object.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> property
      of calling object are adjusted automatically.
</remarks>
*)
    function Abs(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the absolute value of X object elements [XIndex]..[XIndex+Len-1].</summary> 
<remarks>and
      Store the results in calling object elements [Index]..[Index+Len-1].
      An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Abs(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic sine.</summary>
      
<remarks>Calculate the inverse hyperbolic sine for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Sinh"/>*)
    function ArcSinh: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic sine for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSinh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic sine for all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/>
      properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcSinh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic sine for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSinh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic cosine.</summary>
      
<remarks>Calculate the inverse hyperbolic cosine for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Cosh"/>*)
    function ArcCosh: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosine for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCosh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosine for all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCosh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosine for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCosh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic tangens.</summary>
      
<remarks>Calculate the inverse hyperbolic tangens for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Tanh"/>*)
    function ArcTanh: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic tangens for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTanh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic tangens for all X object elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> properties
      of calling object are adjusted automatically.
</remarks>
*)
    function ArcTanh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic tangens for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Arctanh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic cotangens.</summary>
      
<remarks>Calculate the inverse hyperbolic cotangens for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Coth"/>*)
    function ArcCoth: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cotangens for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCoth(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverser hyperbolic cotangens for all X object elements.</summary>
      
<remarks>Store the results in calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCoth(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cotangens for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored
      in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCoth(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic secant.</summary>
      
<remarks>Calculate the inverse hyperbolic secant for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Sech"/>*)
    function ArcSech: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic secant for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSech(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic secant for all X object elements.</summary>
      
<remarks>Store the results in calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcSech(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic secant for X object elements [XIndex]..[XIndex+Len-1].</summary>
     
<remarks>The results are stored
      in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSech(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic cosecant.</summary>
      
<remarks>Calculate the inverse hyperbolic cosecant for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Csch"/>*)
    function ArcCsch: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosecant for calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsch(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosecant for all X object elements.</summary>
      
<remarks>Store the results in calling object.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCsch(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosecant for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsch(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The cube root.</summary>
      
<remarks>Calculate the cube root of all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var v,w: Vector;
      begin
          v.SetIt(false,[1,8]);
          v.Cbrt; // v = [1,2], same as:
          v := Cbrt(v);
          w := Cbrt(v); //same as:
          w.Cbrt(v);
      end;
      </code>
      </Example>

      <SeeAlso cref="InvCbrt"/>*)
    function Cbrt: TMtxVec; overload; 
    (*<summary>Calculate the cube root of calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cbrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the cube root of all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cbrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the cube root of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cbrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Rounds towards positive infinity.</summary>
      
<remarks>Rounds all calling object elements towards positive infinity in-place.

      <code>
      Ceil(-2.8) = -2
      Ceil(2.8) = 3
      Ceil(-1.0) = -1
      </code>
</remarks>
*)
    function Ceil: TMtxVec; overload;
    (*<summary>Rounds calling object elements [Index]..[Index+Len-1] towards positive infinity in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Ceil(Index,Len: integer): TMtxVec;  overload;
    (*<summary>Rounds all Src object elements towards positive infinity.</summary>
      
<remarks>Stores the result in the calling object.
      Size and <see cref="Complex"/> properties of the calling object are adjusted
      automatically.
</remarks>
*)
    function Ceil(const Src: TMtxVec): TMtxVec;  overload;
    (*<summary>Rounds Src object elements [SrcIndex]..[SrcIndex+Len-1] towards positive infinity.</summary>
      
<remarks>Dtores the result in the calling object elements [Index]..[Index+Len-1]
      Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Ceil(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec;  overload;

    (*<summary>Natural logarithm.</summary>
      
<remarks>Calculate the natural log for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);
          a.Ln;    //same as:
          a := Ln(a);
          b.Ln(a); //same as:
          b := Ln(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp"/>*)
    function Ln: TMtxVec; overload; 
    (*<summary>Calculate the natural algorithm for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function Ln(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the natural logarithm for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Ln(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the natural logarithm for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Ln(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Log base 10.</summary>
      
<remarks>Calculate the log base 10 for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[10,100,1000,10000]);  // a = [10,100,1000,10000]
          a.Log10;     // a = [1,2,3,4], same as:
          a := Log10(a);
          b.Log10(a);  //same as
          b := Log10(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp10"/>*)
    function Log10: TMtxVec; overload; 
    (*<summary>Calculate the log base 10 for all X elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function Log10(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the log base 10 for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Log10(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the log base 10 for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the
      calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Log10(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Log base 2.</summary>
      
<remarks>Calculate the log base 2 for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,4,8]);
          a.Log2;  //same as:
          a := Log2(a);
          b := Log2(a); //same as:
          b.Log2(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp2"/>*)
    function Log2: TMtxVec; overload; 
    (*<summary>Calculate the log base 2 for all X elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function Log2(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the log base 2 for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Log2(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the log base 2 for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Log2(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Exponent (e^).</summary>
      
<remarks>Calculate the exponent (e^) for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,4,8]);
          a.Exp;  //same as:
          a := Exp(a);
          b := Exp(a); //same as:
          b.Exp(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Ln"/>*)
    function Exp: TMtxVec; overload; 
    (*<summary>Calculate the exponent (e^) for all X elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function Exp(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the exponent (e^) for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Exp(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the exponent (e^) for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the
      calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Exp(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Exponent base 2 (2^).</summary>
      
<remarks>Calculate the exponent base 2 (2^) for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);  // a = [1,2,3,4]
          a.Exp2;   // a = [2,4,8,16]
          a := Exp2(a);
          b.Exp2(a); //same as
          b := Exp2(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Log2"/>*)
    function Exp2: TMtxVec; overload; 
    (*<summary>Calculate the exponent base 2 (2^) for all X elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function Exp2(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 2 (2^) for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Exp2(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 2 (2^) for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the
      calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Exp2(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Exponent base 10 (10^).</summary>
      
<remarks>Calculate the exponent base 10 (10^) for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);  // a = [1,2,3,4]
          a.Exp10;        // a = [10,100,1000,10000]
          a := Exp10(a);
          b.Exp10(a);  //same as
          b := Exp10(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Log10"/>*)
    function Exp10: TMtxVec; overload; 
    (*<summary>Calculate the exponent base 10 (10^) for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function Exp10(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 10 (10^) for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Exp10(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 10 (10^) for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Exp10(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary> Sums items from Src with matching corresponding indexes from Bins and places result in self.</summary>
               
<remarks>The size of self is set to Bins.Max+1 provided that sufficient memory is available.
               BinsMax with default value of -1 indicates that Bins.Max call is made internally.
               The routine does not perform additional range checking, if BinsMax is provided
               explicitely (memory overwrite is possible).
</remarks>
*)
    function GroupSum(const Bins: TMtxVecInt; const Src: TMtxVec; const BinsMax: integer = -1): TVec; overload;
    (*<summary> Sums items from Src with matching corresponding indexes from Bins and places result in self.</summary>
               
<remarks>The size of self is checked to be BinsMax+1. The routine does not initialize the calling vector to 0.
               The routine does not perform additional range checking, because BinsMax is provided
               explicitely (memory overwrite is possible).
</remarks>
*)
    function GroupSumIteration(const Bins: TMtxVecInt; const Src: TMtxVec; const BinsMax: integer): TVec; overload;

    (*<summary>Gets the imaginary part of a complex object.</summary>
      
<remarks>Gets the imaginary part of a complex object Vec and stores the real results in the calling object.
      Size and <see cref="Complex"/> properties of the calling object are set implicitly to match
      Vec object. Vec <see cref="Complex"/> must be true otherwise the exception will be raised.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);  // a= [1+2i, 3+4i]
          b.ImagPart(a);  // b = [2, 4]
      end;
      </code>
      </Example>

      <SeeAlso cref="RealPart"/>
      <SeeAlso cref="RealToCplx"/>*)
    function ImagPart(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Gets the imaginary part of complex object Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Stores the result in calling object. An exception is raised if the calling object is complex, if Vec is not complex or
      if array borders are overrun/underrun.
</remarks>
*)
    function ImagPart(const Vec: TMtxVec; VecIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Power (integer exponent).</summary>
      
<remarks>Calculate the power ^(Exponent) for all caling object elements using the integer parameter Exponent.
      For non integer exponents, the <see cref="Power"/> and <see cref="PowerVec"/> methods can be used.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);
          a.IntPower(3);     //same as:
          a := IntPower(a,3);
          b.IntPower(a,3); //same as:
          b := IntPower(a,3);
      end;
      </code>
      </Example>

      <SeeAlso cref="Power"/>
      <SeeAlso cref="PowerVec"/>*)
    function IntPower(Exponent: Integer): TMtxVec; overload; 
    (*<summary>Calculate the power Base^(Exponent) for all Base object elements using the integer Exponent value.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> properties
      of calling object are adjusted automatically.
</remarks>
*)
    function IntPower(Base: TMtxVec; Exponent: Integer): TMtxVec; overload; 

    (*<summary>Invert elements.</summary>
      
<remarks>Calculates the inverse of all calling object elements in-place without
      limiting inverse operation.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);  // a = [1, 2, 3, 4]
          b.Inv(a); // b = [1.0, 0.5, 0.3333, 0.25]
          b := Inv(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Divide"/>*)
    function Inv: TMtxVec; overload; 
    (*<summary>Calculate the inverse of calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Inv(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of all calling object elements in-place. The computation occurs after first limiting the
      magnitude of each element by the lower bound of Threshold.</summary>
      
<remarks>The limiting operation is performed to avoid
      division by zero. Since Threshold represents a magnitude, it is always real and must always be positive.
      For complex versions, the magnitude of the input is limited, but the phase remains unchanged.
      Zero-valued input is assumed to have zero phase.
</remarks>
*)
    function Inv(Threshold: double): TMtxVec; overload; 
    (*<summary>Calculate the inverse of calling object elements [Index]..[Index+Len-1] in-place after limiting
      the magnitude of each element by the lower bound of Threshold.</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Inv(Threshold: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of all X object elements without limiting  operating.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Inv(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse of X object elements [XIndex]..[XIndex+Len-1] without limiting  operating.</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1]. An exception is raised if X and calling object
      <see cref="Complex"/> property does not match or array borders are overrun/underrun.
</remarks>
*)
    function Inv(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of all X object elements anmd store the results to calling object elements.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling obhect are adjusted automatically. The computation occurs after first limiting the
      magnitude of each element by the lower bound of Threshold. The limiting operation is performed to avoid
      division by zero. Since Threshold represents a magnitude, it is always real and must always be positive.
      For complex versions, the magnitude of the input is limited, but the phase remains unchanged.
      Zero-valued input is assumed to have zero phase.
</remarks>
*)
    function Inv(const X: TMtxVec; Threshold: double): TMtxVec; overload; 
    (*<summary>Calculate the inverse of X object elements [XIndex]..[XIndex+Len-1] after limiting
      the magnitude of each element by the lower bound of Threshold.</summary>
      
<remarks>Store the results in calling object elements
      [Index]..[Index+Len-1]. An exception is raised if X and calling object <see cref="Complex"/> property do not
      match or array borders are overrun/underrun.
</remarks>
*)
    function Inv(const X: TMtxVec; Threshold: double; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Converts elements from cartesian to polar coordinate form.</summary>
      
<remarks>Converts all calling object elements from cartesian to polar coordinate form, storing the magnitude (radius)
      component of corresponding elements in the AmpltVec and the phase (angle) component of corresponding elements in
      the PhaseVec. If you want to use this method then the calling matrix <see cref="Complex"/> property must be
      true. If this is not the case, an exception is raised. Size and <see cref="Complex"/> properties of AmpltVec and
      PhaseVec are set automatically.
</remarks>


      <Example>
      <code>
      var A,Amplt,Phase: Vector;
      begin
            A.SetIt(2,True,[1,0, 2,0
                          2,0  4,1]);

            A.CartToPolar(Amplt,Phase);
      end;
      </code>
      </Example>

      <SeeAlso cref="PolarToCart"/>*)
    procedure CartToPolar(AmpltVec, PhaseVec: TMtxVec); overload; 
    (*<summary>Convert calling object elements [Index] to [Index+Len-1] from cartesian to polar form.</summary>
      
<remarks>Store the results in AmpltVec (radius values) and PhaseVec(phase values). Size and <see cref="Complex"/>
      properties of the calling vector must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>
      is True and array borders are overrun or underrun.
</remarks>
*)
    procedure CartToPolar(AmpltVec, PhaseVec: TMtxVec; AmpltIndex, PhaseIndex, Index, Len: integer); overload; 

    (*<summary>Copy object values.</summary>
      
<remarks>Copy each of Vec elements to the calling object. Size and <see cref="Complex"/>
      properties of the calling object are set implicitly to match Vec object.
</remarks>


      <Example>
      <code>
      var a,b,c: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);  // a = [1,2,3,4]
          b.Copy(a);                // b = [1,2,3,4]
          c.Copy(a,b);  //concatenate a and b and store in c = [1,2,3,4,1,2,3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Assign"/>*)
    function Copy(const Vec: TMtxVec): TMtxVec; overload; 


    (*<summary>Copy object values.</summary>
      
<remarks>Copy each of Src elements to the calling object. Size and <see cref="Complex"/>
      properties of the calling object are set implicitly to match Src object.
</remarks>


      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a,b,c;
          MtxVec.CreateIt(out a, out b, out c);
          try
          {
            a.SetIt(true,new double[] {1,2,3,4});  // a = [1,2,3,4] i.e 1+2i ; 3+4i
            b.Copy(a, mvSingle);                // convert to single precision
          }
          finally
          {
            MtxVec.FreeIt(ref a,ref b,ref c);
          }
        }
      }
      </code></example>

      <SeeAlso cref="Assign"/>*)
    function Copy(const Src: TMtxVec; const dstFloatPrecision: TMtxFloatPrecision): TMtxVec; overload; 


    (*<summary>Copy Vec elements [VecIndex]..[VecIndex+Len-1]  in the calling object
       elements [Index]..[Index+Len-1].</summary>
       
<remarks>Size and <see cref="Complex"/> properties must be set explicitly. An exception is raised
       if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function Copy(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Copy and convert values from TVecInt.</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
</remarks>
*)
    function Copy(const Src: TVecInt; const dstFloatPrecision: TMtxFloatPrecision):TMtxVec; overload;

    
    (*<summary>Copy and convert values from TVecInt.</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               Existing value of FloatPrecision is preserved.
</remarks>
*)
    function Copy(const Src: TVecInt):TMtxVec; overload;
    

    (*<summary>Copy and convert values from TVecInt at indexes [SrcIndex]...[SrcIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
               properties of the calling object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    function Copy(const Src: TVecInt; SrcIndex, Index, Len: integer):TMtxVec; overload;

    (*<summary>Copy and convert values to TVecInt.</summary>
               
<remarks>Applies appropriate conversion and copy data to TVecInt.
               The value IntPrecision is preserved.
</remarks>
*)
    procedure CopyTo(const Dst: TVecInt; Rounding: TRounding); overload;

    (*<summary>Copy and convert values to TVecInt at indexes [DstIndex]...[DstIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="TMtxVecInt.IntPrecision"/>
               properties of the destination object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    procedure CopyTo(const Dst: TVecInt; Rounding: TRounding; DstIndex, Index, Len: integer); overload;

    (*<summary>Copy and convert values to specified dstFloatPrecision.</summary>
               
<remarks>Dst will be sized to hold all calling object data in specified dstFloatPrecision.
               The single/double and Complex/Not Complex conversion cant be handled concurrently.
</remarks>
*)
    procedure CopyTo(const Dst: TMtxVec; const dstFloatPrecision: TMtxFloatPrecision); overload;

    (*<summary>Copy and convert values to Dst.FloatPrecision at indexes [DstIndex]...[DstIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from the calling object.
               The results are stored in Dst object elements [Index]...[Index+Len-1]. Size and <see cref="TMtxVec.FloatPrecision"/>
               properties of the destination object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    procedure CopyTo(const Dst: TMtxVec; const DstIndex, Index: integer; Len: integer); overload;

    (*<summary>Copy and if needed convert values to Dst.</summary>
               
<remarks>Existing value of Dst.FloatPrecision is preserved.
</remarks>
*)
    
    procedure CopyTo(const Dst: TMtxVec); overload;
    

    (*<summary>Sets vector size to zero.</summary>
      
<remarks>Calling Clear sets <see cref="Length"/> property to 0 and <see cref="Complex"/> property to false.
</remarks>
*)
    procedure Clear;

    (*<summary>Saves the current value of ConditionCheck property and sets it to false.</summary>

      
<remarks>You can restore back to the original setting by calling <See Method="CondEnable"/> method.
</remarks>


      <SeeAlso cref="CondEnable"/>
      <SeeAlso cref="ConditionCheck"/>*)
    procedure CondDisable;
    (*<summary>Sets the ConditionCheck property to whatever it was before the CondDisable was used.</summary>
      
<remarks>Sets the <see cref="ConditionCheck"/> property to whatever it was before the <see cref="CondDisable"/> was used.
</remarks>


      <SeeAlso cref="CondDisable"/>
      <SeeAlso cref="ConditionCheck"/>*)
    procedure CondEnable;

    (*<summary>Conjugate.</summary>
      
<remarks>Conjugate all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var c: Vector;
      begin
          c.SetIt(True,[1,2,3,4]);  // c = [1+2i, 3+4i]
          c.Conj;                   // c = [1-2i, 3-4i]
      end;
      </code>
      </Example>*)
    function Conj: TMtxVec; overload; 
    (*<summary>Conjugate calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Conj(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Conjugate each of Vec elements and store the results in the calling object.</summary>
      
<remarks>The Size and <see cref="Complex"/> properties of the calling object are set implicitly to match Vec vector.
</remarks>
*)
    function Conj(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Conjugate Vec elements Vec[VecIndex]..Vec[VecIndex+Len-1].</summary>
      
<remarks>Store them in the calling object
      elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>
      is true and array borders are overrun.
</remarks>
*)
    function Conj(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Copies values from an array.</summary>
      
<remarks>Copies values from a complex array. The size and <see cref="Complex"/> properties of the
      calling object are set implicitly.
</remarks>


      <SeeAlso cref="Copy"/>
      <SeeAlso cref="CopyTo"/>
      <SeeAlso cref="Round"/>
      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="CopyToArray"/>*)
    function CopyFromArray(const Src: TCplxArray): TMtxVec; overload; 
    (*<summary>Copies values from the Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
    object values [Index]..[Index+len-1].</summary>
    
<remarks>The size of the calling object is not changed.
    If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TCplxArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from a real Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TDoubleArray): TMtxVec; overload; 
    (*<summary>Copies values from the double precision floating point Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
      object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TDoubleArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from a real single precision floating point Src array.</summary>
    
<remarks>The size and <see cref="Complex"/> properties of the      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TSingleArray): TMtxVec; overload; 
   (*<summary>Copies values from the single precision floating point Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
    object values [Index]..[Index+len-1].</summary>
    
<remarks>The size of the calling object is not changed.
    If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TSingleArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from an integer type Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TIntegerArray): TMtxVec; overload; 
    (*<summary>Copies values from a 4 byte signed integer type Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
      object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TIntegerArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Copies values from an 2 byte signed integer type Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TSmallIntArray): TMtxVec; overload; 
    (*<summary>Copies values from a 2 byte signed integer type Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
      object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TSmallIntArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from a 1 byte unsigned integer type Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: Math387.TByteArray): TMtxVec; overload;
    (*<summary>Copies values from a 1 byte unsigned integer type Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
      object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: Math387.TByteArray; SrcIndex,Index,Len: integer): TMtxVec; overload;

    (*<summary>Copy values to an array.</summary>
      
<remarks>Copy complex values to Dst array. The size of the array is set automatically.
      If the calling object is not complex an exception will be raised.
</remarks>


      <SeeAlso cref="Copy"/>
      <SeeAlso cref="CopyTo"/>
      <SeeAlso cref="Round"/>
      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="CopyFromArray"/>*)
    function CopyToArray(var Dst: TCplxArray): TMtxVec; overload; 
    (*<summary>Copy complex values from the calling object [Index]..[Index+len-1] to the Dst
       array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
</remarks>
*)
    function CopyToArray(var Dst: TCplxArray; DstIndex, Index,Len: integer): TMtxVec; overload; 
     (*<summary>Copy values to Dst array.</summary>
      
<remarks>The size of the array is set automatically. If the calling
      object is complex, the size of the Dst array will be equal to 2*<see cref="Length"/>.
      If the calling object is not complex an exception will be raised.
</remarks>
*)
    function CopyToArray(var Dst: TDoubleArray): TMtxVec; overload; 
    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements.
</remarks>
*)
    function CopyToArray(var Dst: TDoubleArray; DstIndex, Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies the calling object data to an array of single precision floating point data.</summary>

      
<remarks>Note
        Any values exceeding the range are clipped.
</remarks>
*)
    function CopyToArray(var Dst: TSingleArray): TMtxVec; overload; 
    
    function CopyToArray(var Dst: TSingleArray; DstIndex, Index,Len: integer): TMtxVec; overload; 

    (*<summary>Copies values from the calling object to the Dst array and converts floating point data
       to integer numbers.</summary>
       
<remarks>The rounding method used is specified with the Rounding parameter.
</remarks>
*)
    function CopyToArray(var Dst: TIntegerArray; Rounding: TRounding): TMtxVec; overload; 

    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       integer array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements. The method converts floating point values to integer.
       Values exceeding the range of the integer type are clipped.
</remarks>
*)
    function CopyToArray(var Dst: TIntegerArray; Rounding: TRounding; DstIndex, Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from the calling object to the Dst array and converts floating point data
       to 2 byte signed integer numbers.</summary>
       
<remarks>The rounding method used is specified with the Rounding parameter.
</remarks>
*)
    function CopyToArray(var Dst: TSmallIntArray; Rounding: TRounding): TMtxVec; overload; 
    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       integer array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements. The method converts floating point values to integers.
       Values exceeding the range of a 2 byte signed integer type are clipped.
</remarks>
*)
    function CopyToArray(var Dst: TSmallIntArray; Rounding: TRounding; DstIndex, Index,Len: integer): TMtxVec; overload; 
     (*<summary>Copies values from the calling object to the Dst array.</summary>
      
<remarks>Converts floating point data to 1 byte unsigned integer numbers. The rounding method used is specified with the Rounding parameter.
</remarks>
*)
    function CopyToArray(var Dst: Math387.TByteArray; Rounding: TRounding): TMtxVec; overload; 

    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       integer array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements. The method converts floating point values to integers.
       Values exceeding the range of 1 byte unsigned integer type are clipped.
</remarks>
*)
    function CopyToArray(var Dst: Math387.TByteArray; Rounding: TRounding; DstIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Split complex calling object in real and imaginary part.</summary>
      
<remarks>Split calling object into real and imaginary components. Store all real components in ReVec and
      all imaginary components in ImVec. Size and <see cref="Complex"/> properties of ReVec and ImVec
      are set implicitly to match with the calling vector. An execption is raised if calling object is not complex.
</remarks>


      <Example>
      <code>
      var a,b,c: Vector;
      begin
          a.SetIt(True,[1,-2,3,4]);
          a.CplxToReal(b,c);
      end;
      </code>
      </Example>

      <SeeAlso cref="RealToCplx"/>*)
    procedure CplxToReal(ReVec, ImVec: TMtxVec); overload; 
    (*<summary>Split calling object elements [Index]..[Index+Len-1] into real and imaginary components.</summary>
      
<remarks>Store real components in ReVec elements [ReIndex]..[ReIndex+Len-1] and imaginary components in ImVec elements
      [ImIndex]..[ImIndex+Len-1]. Size and <see cref="Complex"/> properties must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/>  is true and array borders are overrun or underrun.
</remarks>
*)
    procedure CplxToReal(ReVec, ImVec: TMtxVec; ReIndex, ImIndex, Index, Len: integer); overload; 

    (*<summary>Extends a real object to a complex object.</summary>
      
<remarks>Extend the calling object to complex vector. After the calling of ExtendToComplex the imaginary part becomes the same as real part if Zeros
      is false. If Zeros is true the imaginary part is set to zero. The use of the in-place version of the method is discouraged because
      it requires 3*N copy operations, while the not-in-place version requires only 2*N copy operations.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);
          b.ExtendToComplex(a,True);
      end;
      </code>
      </Example>

      <SeeAlso cref="RealToCplx"/>
      <SeeAlso cref="ImagPart"/>
      <SeeAlso cref="RealPart"/>*)
    function ExtendToComplex(Zeros: boolean = True): TMtxVec; overload; 
    (*<summary>Extend Vec object to complex calling object.</summary>
      
<remarks>If Zeros is true then the calling vector imaginary part is set to zero,
      otherwise the calling object imaginary part is the same as calling object real part.
</remarks>
*)
    function ExtendToComplex(const Src: TMtxVec; Zeros: Boolean): TMtxVec; overload; 

    (*<summary>Converts the source to complex.</summary>
      
<remarks>Converts the source to complex by setting the imaginary part to either zero (zeros = True)
      or same as real (zeros = false). Does not set size of the calling vector.
      If there is not sufficient space available to store the result an exception
      will be raised.
</remarks>
*)
    function ExtendToComplex(const Src: TMtxVec; Zeros: Boolean; SrcIndex,DstIndex, Len: integer): TMtxVec; overload; 

    (*<summary>Sets angle in [-2Pi,2Pi].</summary>
     <returns>ThetaRad within [-2Pi,2Pi] interval.</returns>
     
<remarks>Calling this function prior to passing the value to trigonometric functions can significantly improve numerical accuracy.
     For arguments larger than 10000, the computation of sine/cosine is speeded up by about 10x
     for SSE2/SSE3. The performance gains for classic FPU math are also significant.
     The cost of this function call is approx 30% of the cost of the sine function.

     It is important to mention that the sine/cosine appear within many other functions especially
     complex versions of trigonometric functions. FixAngle method is never used
     implicitely within TMtxVec methods. To achieve maximum performance make
     sure that the arguments passed to complex trigonometric functions are "small" or scaled down.

     Note
      The vector must be real.
</remarks>
*)
    function FixAngle: TMtxVec; overload;

    (*<summary>FixAngle for calling object complex elements [Index]..[Index+Len-1] in-place.</summary>
     
<remarks>An exception is raised if calling object <see cref="Complex"/> property is True or if array borders are overrun/underrun.
</remarks>
*)
    function FixAngle(Index,Len: integer): TMtxVec;  overload;

    (*<summary>Sets angle in [-2Pi,2Pi] for all Src elements.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/>
      properties of the calling vector are set implicitly to match the Src object.
</remarks>
*)
    function FixAngle(const Src: TMtxVec): TMtxVec;  overload;

    (*<summary>Sets angle in [-2Pi,2Pi] for Src elements [SrcIndex]..[SrcIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function FixAngle(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec;  overload;

    (*<summary>Rounds towards negative infinity.</summary>
      
<remarks>Rounds all calling object elements towards negative infinity in-place.

      <code>
      Floor(-2.8) = -3
      Floor(2.8) = 2
      Floor(-1.0) = -1
      </code>
</remarks>
*)
    function Floor: TMtxVec; overload;
    (*<summary>Rounds calling object elements [Index]..[Index+Len-1] towards negative infinity in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Floor(Index,Len: integer): TMtxVec;  overload;
    (*<summary>Rounds all Src object elements towards negative infinity.</summary>
      
<remarks>Stores the result in the calling object.
      Size and <see cref="Complex"/> properties of the calling object are adjusted
      automatically.
</remarks>
*)
    function Floor(const Src: TMtxVec): TMtxVec;  overload;

    (*<summary>Rounds Src object elements [SrcIndex]..[SrcIndex+Len-1] towards negative infinity-</summary>
      
<remarks>Store the result in the calling object elements [Index]..[Index+Len-1]
      Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Floor(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec;  overload;

    (*<summary>A complex exponential <c>e^(j*W)</c>.</summary>
      
<remarks>Calculate the calling object complex exponential in-place. An exception is raised if
      calling object is complex. If object is complex, you should use the <See Method="Exp"/> method instead.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);
          a.Expj;   // a = [e^i, e^2i, e^3i, e^4i]
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp"/>*)
    function Expj: TMtxVec; overload; 
    (*<summary>Calculate the <c>e^(j*W)</c>, a complex exponential.</summary>
      
<remarks>Omega must be a real object. If omega is complex, then use the <See Method="Exp"/> method.
</remarks>
*)
    function Expj(Omega: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the complex exponential for Omega elements [OmegaIndex]..[OmegaIndex+Len-1].</summary>
      
<remarks>Store the results in calling object elemets [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling vector must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>
      is True and array borders are overrun or underrun.
</remarks>
*)
    function Expj(Omega: TMtxVec; OmegaIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Finds a match for X in object values.</summary>
      
<remarks>Compare real value X with all calling object elements and return the Index of last matched element.
      If no matching elements are found, the result is -1.

      Note
        This method also supports the NAN and INF search.
</remarks>


      <Example>
      <code>
      var a: Vector;
        ind: Integer;
      begin
          a.SetIt(False,[2,5,1,6]);
          ind := a.Find(1.0); // returns 2 (the arrays are zero based)
      end;
      </code>
      </Example>*)
    function Find(const X: double): integer; overload; 
    (*<summary>Compare complex value X with all calling object elements.</summary>
     <returns>the Index of last matched element.</returns>
      
<remarks>If no matching elements are found, the result is -1. An exception is raised if
       calling object <see cref="Complex"/> property is false.
</remarks>
*)
    function Find(const X: TCplx): integer; overload; 

    (*<summary>Fractional part of values.</summary>
      
<remarks>Calculates the fractional part for all object values in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
        ind: Integer;
      begin
          a.SetIt(False,[1,5.5,-1.6,6]); // a = [1, 5.5, -1.6, 6]
          a.Frac;  // a = [0, 0.5, -0.6, 0]
      end;
      </code>
      </Example>

      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="Round"/>*)
    function Frac: TMtxVec; overload; 
    (*<summary>Calculates the fractional part for all X object values.</summary>
      
<remarks>Stores the result in calling object. Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Frac(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculates the fractional part for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Frac(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Calculates the fractional part for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Stores the result in calling object elements [Index]..[Index+Len-1]. An exception is raised if array borders
      are overrun or underrun.
</remarks>
*)
    function Frac(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>First element in object Values array.</summary>
      <returns>first real element in object Values array.</returns>
      <SeeAlso cref="Last"/>
      <SeeAlso cref="Firstc"/>*)
    property First: double read get_First;

    (*<summary>First element in object CValues array.</summary>
      <returns>first complex element in object CValues array. An exception is raised if calling object
      <see cref="Complex"/> property is false.</returns>

      <SeeAlso cref="Lastc"/>
      <SeeAlso cref="First"/>*)
    property Firstc: TCplx read get_Firstc;

    (*<summary>Flips the real and imaginary part of complex numbers.</summary>
      
<remarks>Flips the real and imaginary part of complex numbers for all calling object elements in-place.
</remarks>

      <SeeAlso cref="FlipConj"/>*)
    function Flip: TMtxVec; overload; 
    (*<summary>Flips the real and imaginary part of complex numbers for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Flip(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Flips the real and imaginary part of complex numbers for all X object elements.</summary>
      
<remarks>Store the results in the
      calling object. Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Flip(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Flips the real and imaginary part of complex numbers for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]
      An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Flip(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Flips the real and imaginary part of complex numbers and conjugates the complex numbers.</summary>
      
<remarks>Performs the following operation:

      <code>
      a + bi ==> b - ai
      </code>

      Method flips the real and imaginary part and conjugates calling object complex elements in-place.
</remarks>

      <SeeAlso cref="Flip"/>
      <SeeAlso cref="Conj"/>*)
    function FlipConj: TMtxVec; overload; 
    (*<summary>Flip calling object complex elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is false or if array borders are overrun/underrun.
</remarks>
*)
    function FlipConj(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Flip all X object complex elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function FlipConj(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Flip X object complex elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in calling object
      elements [Index]..[Index+Len-1]. An exception is raised if calling object <see cref="Complex"/> property
      is false or if array borders are overrun/underrun.
</remarks>
*)
    function FlipConj(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse of square root 1/(v)^1/2.</summary>
      
<remarks>Calculate the inverse square root (1/(element)^(1/2)) of all calling object elements in-place.
</remarks>


      <Example>
      <code>
      v.SetIt(false,[1,16]);
      v.InvSqrt; // returns [1,0.25]
      </code>
      </Example>

      <SeeAlso cref="Sqrt"/>*)
    function InvSqrt: TMtxVec; overload; 
    (*<summary>Calculate the inverse of square root for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function InvSqrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of square root for all X elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function InvSqrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse of square root for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the
      calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function InvSqrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse of cube root 1/(v)^1/3.</summary>
      
<remarks>Calculate the inverse cube root (1/(element)^(1/3)) of all calling object elements in-place.
</remarks>


      <Example>
      <code>
      v.SetIt(false,[1,8]);
      v.InvCbrt; // returns [1,0.5]
      </code>
      </Example>

      <SeeAlso cref="Cbrt"/>*)
    function InvCbrt: TMtxVec; overload; 
    (*<summary>Calculate the inverse of cube root for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function InvCbrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of cube root for all X elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function InvCbrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse of cube root for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the
      calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function InvCbrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The Reminder after division X/Y.</summary>
      
<remarks>Calculates reminder after division according to formula: X[i]-y[i]*Trunc(X[i]/y[i]). The results will be saved to the calling vector.
      X and Y must be a real and have the same length. Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>


      <Example>
      <code>
      var a,b,c: Vector;
      begin
          a.SetIt(false,[0,1,10,-1,-10]); // a = [0, 1, 10,    -1, -10];
          b.SetIt(false,[0,1,PI,-1,-PI]); // b = [0, 1, PI,    -1, -PI];
          c.Rem(a,b);                     // c = [0, 0, 0.5752, 0, -0.5752]
      end;
      </code>
      </Example>*)
    function Rem(const X, Y: TMtxVec): TMtxVec; overload;
    (*<summary>Calculates reminder after division X/Y according to formula: z[i] = X[xi]-y[yi]*Trunc(X[xi]/y[yi]), where i in [Index..Index+Len], xi in [XIndex..XIndex+Len], yi in [YIndex..YIndex+Len].</summary>
      
<remarks>The results will be saved to the calling vector. X must be a real. An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Rem(const X, Y: TMtxVec; XIndex, YIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Calculates reminder after division X/Y according to formula X[i]-y*Trunc(X[i]/y).</summary>
      
<remarks>X must be a real. The results will be saved to the calling vector.
      Size and <see cref="Complex"/> properties of the calling vector are set implicitly to match the X object.
</remarks>
*)
    function Rem(const X: TMtxVec; Y: double): TMtxVec; overload;
    (*<summary>Calculates reminder after division X/Y according to formula: z[i] = X[xi]-y*Trunc(X[xi]/y), where i in [Index..Index+Len], xi in [XIndex..XIndex+Len].</summary>
      
<remarks>X must be a real. The results will be saved to the calling vector. An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Rem(const X: TMtxVec; Y: double; XIndex, Index, Len: integer): TMtxVec; overload;


    (*<summary>Magnitude.</summary>
      
<remarks>Calculate the magnitude for all calling object elements in-place.
      This method has the same function as the <See Method="Abs"/> method.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(false,[1,-2,3,4]); // a = [1,-2, 3,4]
          a.Mag;      // a = [1, 2, 3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Abs"/>
      <SeeAlso cref="PhaseSpectrum"/>*)
    function Mag: TMtxVec; overload; 
    (*<summary>Calculate the magnitude for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Mag(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the magnitude for all X elements.</summary>
      
<remarks>Store the results in the calling object elements.
      Size and and <see cref="Complex"/> properties of the calling vector are set
      implicitly to match Vec vector.
</remarks>
*)
    function Mag(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the magnitude for X elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the calling
      object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the
      calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and array
      borders are overrun.
</remarks>
*)
    function Mag(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Multiply object elements with Value.</summary>
      
<remarks>Multiply all calling object elements with Value in-place.
      This method is the same as the <see cref="Mul"/> method overloads
      multiplying with vector elements with a scalar.
</remarks>


      <Example>
      <code>
      var v: Vector;
      begin
          v.SetIt(false,[2,3,5]);  // v = [2,3,5]
          v.Scale(3); // v = [6,9,15]
      end;
      </code>
      </Example>

      <SeeAlso cref="Add"/>*)
    function Scale(Factor: double): TMtxVec; overload;  
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Scale(Factor: double; Index, Len: integer): TMtxVec; overload;  
    (*<summary>Multiply all calling object elements with a complex Value in-place.</summary>*)
    function Scale(Factor: TCplx): TMtxVec; overload;  
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with complex Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Scale(Factor: TCplx; Index, Len: integer): TMtxVec; overload;  

    (*<summary>Scatter object elements.</summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      according to the IndexType, Increment and Offset parameters.

      The Indexes vector is used only if IndexType is either indVector
      or indMask. If IndexType is indVector, the values from the Indexes
      object denote the Index positions in the calling object to which
      the values should be copied from the Src.
      The Indexes vector must have the indexes stored in the IValues
      array. The IValues integer arrays points the same memory as Values
      array.

      The Increment and Offset parameters are used only if TIndexType
      is indIncrement. They define the target offset and a fixed
      step (increment) between calling vector elements.

      If IndexType is indMaks the Indexes object must have the same
      size as the Src object. The routine will copy only those elements
      from the Src to the calling object, for which there is a 1 at the coresponding
      Index in the Indexes object.The elements in the calling object are stored consecutively.

      See the <see cref="Gather"/> method to see how to perform gathering.

      The performance of the CPU heavily depends on the assumption that elements are stored at consecutive memory locations.
      If it is neccessary to apply a set of operations only to elements at specific indexes, performance-wise it can prove to be
      very helpfull, if the elements are gathered first.
</remarks>


      <SeeAlso cref="Gather"/>*)
    function Scatter(const Src: TMtxVec; const Indexes: TVecInt = nil; IndexType: TIndexType = indVector; Increment: integer = 1; Offset: integer = 0): TMtxVec; overload; 

    (*<summary>Scatter object elements.</summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      at indices: Increment*i + Offset
</remarks>
*)
    function ScatterByIncr(const Src: TMtxVec; Increment: integer = 1; Offset: integer = 0): TMtxVec; overload; 

    (*<summary>Scatter object elements.</summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      at indices stored in the Indexes parameter.
</remarks>
*)
    function ScatterByIndexes(const Src: TMtxVec; const Indexes: TVecInt): TMtxVec; overload; 

    (*<summary>Scatter object elements. </summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      at indices set to 1 in the Mask parameter.
</remarks>
*)
    function ScatterByMask(const Src: TMtxVec; const Mask: TVecInt; allow_resizing: boolean = False): TMtxVec; overload; 

    (*<summary>Copies those values from MaskVec, at which aMask is different from 0.</summary>*)
    function Mask(const MaskVec: TMtxVec; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Copies those values from MaskVecNot, at which aMask is equal to 0.</summary>*)
    function MaskNot(const MaskVecNot: TMtxVec; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is different from 0.</summary>*)
    function Mask(const Value: double; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is equal to 0.</summary>*)
    function MaskNot(const Value: double; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is different from 0.</summary>*)
    function Mask(const Value: TCplx; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is equal to 0.</summary>*)
    function MaskNot(const Value: TCplx; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Sets object values.</summary>
      
<remarks>Set object values. Method call does not change object's size or <see cref="Complex"/> property, but
      it does check for array overrun. The elements of A array are copied to the calling object elements, starting at Index.
      If the calling object is complex, then real parts of complex numbers are on even (0,2,4..) and imaginary parts
      on odd indexes.(1,3,5,..).
</remarks>
*)
    function SetIt(Index: integer; const A: array of double): TMtxVec; overload;
    (*<summary>The elements of A array, starting at AIndex, are copied to the calling object elements, starting at Index.</summary>
      
<remarks>If the calling object is complex, then real parts of complex numbers in the A array are on even (0,2,4..) and imaginary parts
      on odd indexes.(1,3,5,..).
</remarks>
*)
    function SetIt(Index, AIndex, Len: integer;  const A: array of double): TMtxVec; overload;

    (*<summary>Sets object values (single).</summary>
      
<remarks>The single elements of A array are copied to the calling object elements [Index]..[Index+Length(A)-1]. An
      exception is raised if calling object array borders are overrun/underrun.

      Note
        Use this method for integer array only.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetInteger"/>
      <SeeAlso cref="SetCplx"/>
      <SeeAlso cref="SetDouble"/>*)
    function SetSingle(Index: integer; const A: array of single): TMtxVec; overload;
    function SetSingle(Index: integer; aIndex, Len: integer; const A: array of single): TMtxVec; overload;

    (*<summary>Sets object values (double).</summary>
      
<remarks>The double elements of A array are copied to the calling object elements [Index]..[Index+Length(A)-1]. An
      exception is raised if calling object array borders are overrun/underrun.

      Note
        Use this method for integer array only.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetInteger"/>
      <SeeAlso cref="SetCplx"/>
      <SeeAlso cref="SetSingle"/>*)
    function SetDouble(Index: integer; const A: array of double): TMtxVec; overload;
    function SetDouble(Index: integer; aIndex, Len: integer; const A: array of double): TMtxVec; overload;

    (*<summary>Sets object values (integer).</summary>
      
<remarks>The integer elements of A array are copied to the calling object elements [Index]..[Index+Length(A)-1]. An
      exception is raised if calling object array borders are overrun/underrun.

      Note
        Use this method for integer array only.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetDouble"/>
      <SeeAlso cref="SetCplx"/>
      <SeeAlso cref="SetSingle"/>*)
    function SetInteger(Index: integer; const A: array of Integer): TMtxVec; overload;
    function SetInteger(Index: integer; aIndex, Len: integer; const A: array of Integer): TMtxVec; overload;

    (*<summary>Square.</summary>
      
<remarks>Calculate the square of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);
          a.Sqr; // a=[1,4,9,16]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sqrt"/>
      <SeeAlso cref="Power"/>*)
    function Sqr: TMtxVec; overload; 
    (*<summary>Calculate the square of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqr(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the square of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sqr(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the square of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object are not changed.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqr(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Square root.</summary>
      
<remarks>Calculate the square root of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(False,[1,4,9,16]);
          a.Sqrt; // a= [1, 2, 3, 4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sqr"/>*)
    function Sqrt: TMtxVec; overload; 
    (*<summary>Calculate the square root of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the square root of all X object elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function Sqrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the square root of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of calling object are not changed. An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Last complex element in object CValues array.</summary>
      <returns>last complex element in object CValues array.</returns>

      <SeeAlso cref="Firstc"/>
      <SeeAlso cref="Last"/>*)
    property Lastc: TCplx read get_Lastc;

    (*<summary>Last element in object Values array.</summary>
      <returns>last real element in object Values array.</returns>

      <SeeAlso cref="First"/>
      <SeeAlso cref="Lastc"/>*)
    property Last: double read get_Last;

    (*<summary>Log base N.</summary>
      
<remarks>Calculate the log base N for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(False,[1,2,3,4]); // a = [1,2,3,4]
          a.LogN(10.0);  // log base 10, the slow way a = [Log10(1), Log10(2),...]
      end;
      </code>
      </Example>

      <SeeAlso cref="Power"/>*)
    function LogN(N: double): TMtxVec; overload; 
    (*<summary>Calculate the log base N of calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function LogN(N: double; Index, Len: integer):TMtxVec; overload; 
    (*<summary>Calculate the log base N of all X object elements.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> properties of the calling object
      are adjusted automatically.
</remarks>
*)
    function LogN(N: double; X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the log base N of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object are not changed. An exception is raised if array borders are overrun.
</remarks>
*)
    function LogN(N: double; X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Multiply object elements with Value.</summary>
      
<remarks>Multiply all calling object elements with Value in-place.
</remarks>


      <Example>
      <code>
      var v: TVec;
      begin
        v:= TVec.Create;
        try
          v.SetIt(false,[2,3,5]);  // v = [2,3,5]
          v.Mul(3); // v = [6,9,15]
        finally
          v.Free;
        end;
      end;
      </code>
      </Example>

      <SeeAlso cref="Add"/>*)
    function Mul(Value: double): TMtxVec; overload; 
    (*<summary>Multiply all calling object elements with complex Value in-place.</summary>*)
    function Mul(Value: TCplx): TMtxVec; overload; 
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Mul(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with
      complex Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Mul(Value: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Multiply each element of Vec with Value.</summary>
      
<remarks>Store the result in the calling object.
      Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Multiply each element of Vec with complex Value.</summary>
      
<remarks>Store the result in the calling object.
      Size of the calling object is set automatically.
      <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: TCplx): TMtxVec; overload; 
    (*<summary>Multiply Vec elements [VecIndex]..[VecIndex+Len-1] with Value.</summary>
      
<remarks>Store the result in calling object elements [Index]..[Index+Len-1].
      Size of the calling object is not changed. An exception is raised if array borders are overrun or underrun.
      <see cref="Complex"/> propertiy of the calling object is set implicitly.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Multiply Vec elements [VecIndex]..[VecIndex+Len-1] with complex Value.</summary>
      
<remarks>Store the result in calling object elements [Index]..[Index+Len-1].
      Size of the calling object is not changed. An exception is raised if array borders are overrun or underrun.
      <see cref="Complex"/> propertiy of the calling object is set to True.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Multiply elements by imaginary unit I.</summary>
      
<remarks>Multiply calling vector elements with "I".
</remarks>
*)
    function MulI: TMtxVec; overload; 
    (*<summary>Multiply calling object elements [Index]..[Index+Len-1] with I in-place.</summary>*)
    function MulI(Index: integer; Len: integer): TMtxVec; overload; 
    (*<summary>Multiply X elements with I.</summary>
      
<remarks>Store the result in the calling object.
</remarks>
*)
    function MulI(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Multipy X elements [XIndex]..[XIndex+Len-1] with I.</summary>
      
<remarks>Store the result in the calling object at locations [Index]..[Index+Len-1].
</remarks>
*)
    function MulI(const X: TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload; 

        (*<summary>Normalize data.</summary>
      
<remarks>Normalizes values in the calling object by subtracting a constant Offset from Elements and dividing the result by constant Factor:

      <IMG name="TVec21"/>

      The results are stored in calling object. Use this method if you want to do a multiply and add (scale and offset) operations in a single method call.
</remarks>

      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a;
          MtxVec.CreateIt(out a);
          try
          {
            a.SetIt(false,new double[] {1,2,3,4});  // a = [1,2,3,4]
            a.Normalize(2,3);
          }
          finally
          {
            MtxVec.FreeIt(ref a);
          }
        }
      }
      </code></example>

      <SeeAlso cref="TDenseMtxVec.Offset"/>
      <SeeAlso cref="Scale"/>*)
    function Normalize(const SubOffset, DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize by subtracting a complex constant SubOffset from Vec elements and dividing the result by complex constant DivFactor.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised, if object is complex.
</remarks>
*)
    function Normalize(const SubOffset, DivFactor: TCplx): TMtxVec; overload; 
    (*<summary>Normalize objects complex values [Index]..[Index+Len-1] by subtracting a complex constant SubOffset from Vec elements and dividing the result by complex constant DivFactor.</summary>
       
<remarks>An exception is raised, if object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const SubOffset, DivFactor: TCplx; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize object values [Index]..[Index+Len-1] by subtracting a real constant SubOffset from Vec elements and dividing the result by
      complex constant DivFactor.</summary>
      
<remarks>Store the results in calling vector values [Index]..[Index+Len-1]. An exception
      is raised, if Vec or calling object is complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const SubOffset, DivFactor: double; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize object by subtracting a complex constant SubOffset from elements and dividing the result by
      real constant DivFactor.</summary>  
<remarks>An exception is raised, if object is not complex.
</remarks>
*)
    function Normalize(const SubOffset: TCplx; const DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize objects complex values [Index]..[Index+Len-1] by subtracting a complex constant SubOffset from elements and dividing the result by
      real constant DivFactor.</summary>
      
<remarks>Store the results in calling vector complex values [Index]..[Index+Len-1]. An exception
      is raised, if the calling object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const SubOffset: TCplx; const DivFactor: double; Index,Len: integer): TMtxVec; overload; 

    (*<summary>Normalize object.</summary>
      
<remarks>Normalizes Vec object by subtracting a constant Offset from Vec elements and dividing the result by constant Factor:

      <IMG name="TVec21"/>

      The results are stored in calling object. Use this method if you want to do a multiply and add (scale and offset) operations
      in a single method call.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);
          b.Normalize(a,2,3);
      end;
      </code>
      </Example>

      <SeeAlso cref="Offset"/>
      <SeeAlso cref="Scale"/>*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize Vec object by subtracting a complex constant SubOffset from Vec elements and dividing the result by
      complex constant DivFactor.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Vec is complex.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: TCplx): TMtxVec; overload; 
    (*<summary>Normalize Vec object complex values [VecIndex]..[VecIndex+Len-1] by subtracting a complex constant SubOffset from Vec elements and dividing the result by
      complex constant DivFactor.</summary>
      
<remarks>Store the results in calling vector complex values [Index]..[Index+Len-1]. An exception
      is raised if Vec or calling object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: TCplx; VecIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize Vec object values [VecIndex]..[VecIndex+Len-1] by subtracting a real constant SubOffset from Vec elements and dividing the result by
      complex constant DivFactor.</summary>
      
<remarks>Store the results in calling vector values [Index]..[Index+Len-1]. An exception
      is raised if Vec or calling object is complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: double; VecIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize Vec object by subtracting a complex constant SubOffset from Vec elements and dividing the result by
      real constant DivFactor.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Vec is complex.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset: TCplx; DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize Vec object complex values [VecIndex]..[VecIndex+Len-1] by subtracting a complex constant SubOffset from Vec elements and dividing the result by
      real constant DivFactor.</summary>
      
<remarks>Store the results in calling vector complex values [Index]..[Index+Len-1]. An exception
      is raised if Vec or calling object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset: TCplx; DivFactor: double; VecIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Converts the polar magnitude/phase pairs to cartesian pairs.</summary>
      
<remarks>Convert all AmpltVec and PhaseVec elements (combined) from polar to cartesian form. If AmpltVec and PhaseVec size is not the same
      , an exeption is raised. The results are stored as complex numbers (X=Re, y=Im) in the calling
      object.  Size and <see cref="Complex"/> properties of the calling object are set implicitly to
      match AmpltVec and PhaseVec objects.
</remarks>


      <Example>
      <code>
      var a,b,c: Vector;
      begin
          a.SetIt(false,[1,2,3,4]);  // a = [1,2,3, 4] //magnitude
          b.SetIt(false,[1,0,1,-1]); // b = [1,0,1,-1] /phase
          c.PolarToCart(a,b); // result stored in c = projections to Re and Im axis
      end;
      </code>
      </Example>

      <SeeAlso cref="CartToPolar"/>*)
    function PolarToCart(AmpltVec, PhaseVec: TMtxVec): TMtxVec; overload; 
    (*<summary>Convert  AmpltVec elements [AIndex]..[AIndex+Len-1] and PhaseVec elements [PIndex]..[PIndex+Len-1] from polar form
      (radius,angle) to cartesian form (X,y).</summary>
      
<remarks>The results are stored as complex numbers (X=Re, y=Im) in the calling
      object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the calling
      object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun/underrun.
</remarks>
*)
    function PolarToCart(AmpltVec, PhaseVec: TMtxVec; AIndex, PIndex,Index, Len: integer): TMtxVec; overload; 

    (*<summary>Raises base object elements to any power.</summary>
      
<remarks>Raises Base calling object elements to any power. The <see cref="IntPower"/> is faster, if Exponent is an integer.
      Real valued power can handle only positive Exponent. <see cref="IntPower"/> can handle negative exponent also.
      To compute a power to the negative exponent in general case or when the base is negative,
      use the complex version of the function.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);
          a.Power(1.2);
      end;
      </code>
      </Example>

      <SeeAlso cref="IntPower"/>
      <SeeAlso cref="PowerVec"/>*)
    function Power(Exponent: double): TMtxVec; overload; 
    (*<summary>Raises all calling vector elements to complex power Exponent in-place.</summary>
       
<remarks>If the calling vector is real and has negative elements, the result will be NAN
       at those entries. To obtain a valid result in this case, extend the calling
       vector to complex with <See Method="ExtendToComplex"/> method. In all real/complex
       combinations, the Power method will not automatically assume that a number is complex
       to speed up the computation. Alternatively the user can of course always
       convert the real numbers to complex before passing them to the Power routine.
</remarks>
*)
    function Power(Exponent: TCplx): TMtxVec; overload; 

    (*<summary>The phase angles (spectrum) of object elements.</summary>
      
<remarks>Calculates the phase angles (spectrum) of all Vec object elements. Phase values are returned in radians and are in the range
     [-PI,PI]. Size and <see cref="Complex"/> properties of the calling
      object are set implicitly to match Vec object. The phase angles are calculated from the following equation:

      <IMG name="TVec23"/>
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);  // a = [1 + 2i, 3 - 4i]
          b.PhaseSpectrum(a);  // b = [arctan2(1,2), arctan2(3,-4)];
      end;
      </code>
      </Example>

      <SeeAlso cref="PowerSpectrum"/>
      <SeeAlso cref="ArcTan2"/>*)
    function PhaseSpectrum(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculates the power spectrum from the Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1]. An exception is raised
      if array borders are overrun/underrun.
</remarks>
*)
    function PhaseSpectrum(const Vec: TMtxVec; VecIndex, Index,Len: integer): TMtxVec; overload; 

    (*<summary>The power spectrum from object complex values.</summary>
      
<remarks>Calculates the power spectrum from the Vec object complex values and stores the results (power spectrum)
      in the real calling object. Size and <see cref="Complex"/> properties of the calling object are set
      implicitly to match Vec object. The spectrum elements are squares of the magnitudes of the complex input elements:

      <IMG name="Tvec22"/>
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(True,[1,2,3,-4]); // a = [1 + 2i, 3 - 4i]
          b.PowerSpectrum(a);   // b = [1*1 + 2*2, 3*3+(-4)*(-4)]
      end;
      </code>
      </Example>

      <SeeAlso cref="PhaseSpectrum"/>*)
    function PowerSpectrum(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculates the power spectrum from the Vec complex elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in calling object real elements [Index]..[Index+Len-1]. An exception is raised
      if calling object <see cref="Complex"/> property is true or if array borders are overrun/underrun.
</remarks>
*)
    function PowerSpectrum(const Vec: TMtxVec; VecIndex, Index,Len: integer): TMtxVec; overload; 

    (*<summary>Raises base elements to exponent power.</summary>
      
<remarks>Raises Base value to Exponent object values powers and store the results to calling object values.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>


      <SeeAlso cref="PowerVec"/>*)
    function Power(Base: double; Exponent: TMtxVec): TMtxVec; overload; 
    (*<summary>Raises Base complex value to Exponent object values powers and store the results to calling object values.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Power(Base: TCplx; Exponent: TMtxVec): TMtxVec; overload; 
    (*<summary>Raises each of Base object elements to corresponding power</summary>
      
<remarks>Powers are stored in Exponenet elements:

      <code>
      Power[i] = Base[i]^Exponent[i]
      </code>

      Size and <See crfef="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Base and Exponent sizes do not match.
</remarks>
*)
    function Power(Base, Exponent: TMtxVec): TMtxVec; overload; 
    (*<summary>Raises each of the Base object elements to complex Exponent power.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Power(Base: TMtxVec; Exponent: TCplx): TMtxVec; overload; 
    (*<summary>Raises each of the Base object elements to real Exponent power.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Power(Base: TMtxVec; Exponent: double): TMtxVec; overload; 

    (*<summary>Raises Base object elements to Exponent object elements power.</summary>
      
<remarks>Raises Base elements to Exponent elements power. Only positive exponents can be handled
      if exponent object <see cref="Complex"/> property is True.
</remarks>


      <Example>
      <code>
      var a,b,c: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);
          b.SetIt(True,[3,3,2,2]);
          c.PowerVec(a,b); // c = [1,8,9,16]
      end;
      </code>
      </Example>

      <SeeAlso cref="Power"/>*)
    function PowerVec(Base, Exponent: TMtxVec): TMtxVec;

    (*<summary>Elements product.</summary>
      <returns>the product of all calling object elements.</returns>
      
<remarks>Formula:

      <IMG name="TVec25"/>

      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Vector;
          c: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          c := a.Product; // c= 24
      end;
      </code>
      </Example>

      <SeeAlso cref="Productc"/>*)
    function Product: double; overload; 
    (*<summary>Returns the product for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Product(Index,Len: integer): double; overload; 
    (*<summary>Calculate the product of all calling object complex elements.</summary>
      
<remarks>Store the result in complex variable X.
</remarks>
*)
    procedure Product(out X: TCplx); overload; 
    (*<summary>Calculate the product for calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>Store the result in complex variable X. An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    procedure Product(out X: TCplx; Index,Len: integer); overload; 
    (*<summary>Calculate the product of all calling object elements.</summary>
      
<remarks>Store the result in real variable X.
</remarks>
*)
    procedure Product(out X: double); overload; 
    (*<summary>Calculate the product for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Store the result in real variable X. An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    procedure Product(out X: double; Index,Len: integer); overload; 

    (*<summary>Elements product.</summary>
      <returns>the complex product of all calling object complex elements.</returns>

      
<remarks><IMG name="TVec25"/>

      An exception is raised if calling object <see cref="Complex"/> property is false.
</remarks>

      <SeeAlso cref="Product"/>*)
    function Productc: TCplx; overload; 
    (*<summary>Returns the complex product for calling object complex elements [Index]..[Index+Len-1].</summary>
       
<remarks>An exception is raised if array borders are overrun or underrun or if <see cref="Complex"/> propety is false.
</remarks>
*)
    function Productc(Index,Len: integer): TCplx; overload; 

    (*<summary>The pseudo random sample generator with Gaussian distribution.</summary>
      
<remarks>Fills the calling object values with pseudo random samples following the Gaussian distribution with
      parameters: Mean = 0, StdDev = 1 ("Standard disctribution"). The value for the seed is obtained
      from the CPU clock.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.Size(500,False);
          a.RandGauss;
      end;
      </code>
      </Example>

      <SeeAlso cref="RandUniform"/>*)
    function RandGauss: TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the Gaussian distribution.</summary>
       
<remarks>Parameters: AMean and AStdDev. The value for the seed is obtained from the CPU clock.
</remarks>
*)
    function RandGauss(AMean, AStdDev: double): TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the Gaussian distribution.</summary>
        
<remarks>Parameters: AMean, AStdDev and with Seed.
</remarks>
*)
    function RandGauss(Seed: cardinal; AMean, AStdDev: double): TMtxVec; overload; 

    (*<summary>The pseudo random sample generator with continuous uniform distribution.</summary>
      
<remarks>Fills the calling object values with pseudo random samples following the continuous uniform distribution
      using the parameters Low = 0, High = 1. The value for the seed is obtained from the CPU clock.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.Size(100,False);
          a.RandUniform(0,5);
      end;
      </code>
      </Example>

      <SeeAlso cref="RandGauss"/>*)
    function RandUniform: TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the continuous uniform distribution.</summary>
      
<remarks>Parameters Low and High. The value for the seed is obtained from the CPU clock.
</remarks>
*)
    function RandUniform(aLow, aHigh: double): TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the continuous uniform distribution.</summary>
      
<remarks>Parameters Low and High and Seed.
</remarks>
*)
    function RandUniform(Seed: cardinal; aLow, aHigh: double): TMtxVec;   overload; 

    (*<summary>Gets real part of complex object values.</summary>
      
<remarks>The method method gets the real part of a complex object Vec and stores the real results in the calling
      object. Size and <see cref="Complex"/> properties of the calling object are set implicitly to match
      Vec object. Vec <see cref="Complex"/> property must be true otherwise an exception is raised.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
          a.SetIt(True,[1,2,3,4]); // = [1+2i, 3+4i]
          b.RealPart(a); // b = [1,3]
      end;
      </code>
      </Example>

      <SeeAlso cref="ImagPart"/>*)
    function RealPart(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Gets the real part of a Vec object complex elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Stores the results in calling object real elements [Index]..[Index+Len-1].
      An exception is raised if array borders are overrun or underrun or if Vec object <see cref="Complex"/>
      propety is false.
</remarks>
*)
    function RealPart(const Vec: TMtxVec; VecIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Read values content from stream to object.</summary>
      
<remarks>Reads values content from SrcStream stream to calling objct. No other values describing the data type or length are read
      from the DstStream. Number type is defined by the Precision parameter, which can be obtained from <see cref="ReadHeader"/> method
      call.

      Note
        Use this method separately only, if you want user defined storage format.
</remarks>


      <Example>
      <code>
      var b: Vector;
          AStream: TFileStream;
          Precision: TPrecision;
      begin
        AStream := TFileStream.Create('C:\test.bin',fmOpenRead);
        try
          Precision := b.ReadHeader(AStream); // Read info for b
          b.ReadValues(AStream,Precision); // Read values of b
        finally
          AStream.Free;
        end;
      end;
      </code>
      </Example>

      <SeeAlso cref="ReadHeader"/>
      <SeeAlso cref="WriteValues"/>
      <SeeAlso cref="LoadFromStream"/>*)
    
    
    function ReadValues(const Src: TStream; Precision: TPrecision): Int64; overload;
    

    (*<summary>Constructs a complex object from two real objects.</summary>
      
<remarks>Construct a complex object from the ReVec (real part) and the ImVec (imaginary part) objects.
      The results are stored in the calling object. Size and <see cref="Complex"/> properties of the calling
      object are set implicitly to match ReVec and ImVec objects. An exception is raised if ReVec or ImVec <see cref="Complex"/>
      property is True.
</remarks>


      <Example>
      <code>
      var a,b,c: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);
          b.SetIt(True,[2,2,3,4]);
          c.RealToCplx(a,b);
      end;
      </code>
      </Example>

      <SeeAlso cref="CplxToReal"/>*)
    function RealToCplx(const ReVec, ImVec: TMtxVec): TMtxVec; overload; 
    (*<summary>Construct a complex object from the ReVec elements [ReIndex]..[ReIndex+Len-1] (real part) and the ImVec
      elements [ImIndex]..[ImIndex+Len-1] (imaginary part).</summary>
      
<remarks>The results are stored to calling object
      elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the calling
      object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and array borders
      are overrun. An exception is also raised if ReVec or ImVec <see cref="Complex"/> property is True.
</remarks>
*)
    function RealToCplx(const ReVec, ImVec: TMtxVec; ReIndex, ImIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Resets object properties to default values.</summary>
      
<remarks>Resets object properties to default values. The method is used by the Object cache management
      to reset the properties of the object freed with a call to <see cref="MtxVec.FreeIt"/>.
</remarks>
*)
    procedure Reset;

    (*<summary>Search and replace a value.</summary>
      
<remarks>Replaces the SearchValue with a ReplaceValue, where the searchValue is compared with Tol to the values of the calling object.
</remarks>
*)
    function Replace(SearchValue, ReplaceValue: double; Tol: double = 0.0001): TMtxVec; overload; 
    (*<summary>Replaces the SearchValue with a ReplaceValue, where the searchValue is compared with Tol to the calling object elements
      [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Replace(SearchValue, ReplaceValue: double; Index, Len: integer; Tol: double = 0.0001): TMtxVec; overload; 
    (*<summary>Search and replace a complex value.</summary>*)
    function Replace(SearchValue, ReplaceValue: TCplx; Tol: double = 0.0001): TMtxVec; overload; 
    (*<summary>Replaces the SearchValue with a ReplaceValue, where the searchValue is compared with Tol to the calling object elements
      [Index]..[Index+Len-1].</summary>
       
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Replace(SearchValue, ReplaceValue: TCplx; Index, Len: integer; Tol: double = 0.0001): TMtxVec; overload; 

    (*<summary>Root mean square (RMS).</summary>
      
<remarks>Calculate the root mean square value for all calling object
      elements in-place. The root mean square (RMS)
      is defined by the equation:

      <IMG name="TVec02"/>
</remarks>


      <Example>
      <code>
      var a: Vector;
          c: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          c := a.RMS;
      end;
      </code>
      </Example>

      <SeeAlso cref="StdDev"/>*)
    function RMS: double; overload; 
    (*<summary>Calculate the RMS for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function RMS(Index, Len: integer): double; overload; 

    (*<summary>Elements rounded to the nearest whole number.</summary>
      
<remarks>Rounds all calling object elements to the nearest whole number.
      The result can be stored to an array of integers or as floating
      point number.
</remarks>


      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="Frac"/>*)
    function Round: TMtxVec; overload; 
    (*<summary>Round calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Round(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Round all Src object elements and store the results in calling object elements.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Round(const Src: TMtxVec): TMtxVec; overload; 
    (*<summary>Rounds the calling object elements to 4 byte integers and stores the
       result in the Dst array.</summary>
       
<remarks>The size of the Dst array is set automatically.
       If the complex property is True then the length of the array will be equal to
       Self.Length*2.
</remarks>
*)
    procedure Round(var Dst: TIntegerArray); overload; 
    (*<summary>Round Src object elements [SrcIndex]..[SrcIndex+Len-1] and store the results to calling object elements
      [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> property of the calling object must be set explicitly.
      An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Round(const Src: TMtxVec; SrcIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Initialize elements to Value.</summary>
      
<remarks>Set all calling object elements to Value.
      If the calling object is complex
      then the real part is set to Value and the imaginary is set to zero.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
        a.Size(4,False);
        a.SetVal(1); // a = [1,1,1,1]
      end;
      </code>
      </Example>

      <SeeAlso cref="SetZero"/>*)
    function SetVal(Value: double): TMtxVec; overload; 
    (*<summary>Set all calling object elements [Index]..[Index+Len-1] to real Value.</summary>
      
<remarks>If the calling object is complex then the real part is set to Value and the imaginary is set to zero.
      An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function SetVal(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Set all calling object complex elements to complex Value.</summary>*)
    function SetVal(Value: TCplx): TMtxVec; overload; 
    (*<summary>Set calling object complex elements [Index]..[Index+Len-1] to complex Value.</summary>
       
<remarks><see cref="Complex"/> properties of the calling object are set to true even before the call it was false.
       An exception is raised if calling object array borders are overrun/underrun.
</remarks>
*)
    function SetVal(Value: TCplx; Index: integer; Len: integer): TMtxVec; overload; 

    (*<summary>Initializes object elements to zero.</summary>
      
<remarks>Set all calling object elements to zero.
</remarks>


      <SeeAlso cref="SetVal"/>*)
    function SetZero: TMtxVec; overload; 
    (*<summary>Initializes calling object elements [Index]..[Index+Len-1] to zero.</summary>
      
<remarks>An exception is raised if array borders are overrun
</remarks>
*)
    function SetZero(Index, Len: integer): TMtxVec; overload; 

    (*<summary>Changes elements sign.</summary>
      
<remarks>Changes all calling object elements sign (v -> -v) in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
        a.SetIt(False,[1,2,-3,4]);
        a.Sign; // a = [-1,-2,3,-4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Mul"/>*)
    function Sign: TMtxVec; overload; 
    (*<summary>Change calling object elements [Index]..[Index+Len-1] sign in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Sign(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Change all X object elements sign and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sign(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Change X object elements [XIndex]..[XIndex+Len-1] sign and store the results in calling
      object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Sign(const X: TMtxVec; XIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary> Computes signum function of calling object elements. </summary>
                 
<remarks>Signum(X) is 1 for X &gt; 0 , equal to zero for X = 0  and  -1 for X &lt; 0.
</remarks>
*)
    function Sgn: TMtxVec; overload; 

    (*<summary> Computes signum function of calling object elements [Index..Index+Len-1]. </summary>
                 
<remarks>Signum(X) is 1 for X &gt; 0 , equal to zero for X = 0  and  -1 for X &lt; 0.
</remarks>
*)
    function Sgn(Index,Len: integer): TMtxVec; overload; 

    (*<summary> Computes signum function from Src elements and stores the result in the calling object.  </summary>
                 
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
                 Signum(X) is 1 for X &gt; 0 , equal to zero for X = 0  and  -1 for X &lt; 0.
</remarks>
*)
    function Sgn(const Src: TMtxVec): TMtxVec; overload; 

    (*<summary> Computes signum function from Src elements [SrcIndex..SrcIndex+Len-1] and stores the result in
                 the calling object [Index..Index+Len-1].  </summary>
                 
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
                 Signum(X) is 1 for X &gt; 0 , equal to zero for X = 0  and  -1 for X &lt; 0.
</remarks>
*)
    function Sgn(const Src: TMtxVec; SrcIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Signum.</summary>
      
<remarks>Calculates the signum of all Src object elements and multiplies
      it with the calling object elements accordingly.
      Signum(X) is 1 for X &gt; 0 , equal to zero for X = 0  and  -1 for X &lt; 0.

      Note
        The length of Src and of the calling object must match
        or an exception will be raised.

      Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function SgnMul(const Src: TMtxVec): TMtxVec; overload; 

    (*<summary>Size the object.</summary>
      
<remarks>Assignes the size of the Src object to the calling object.
      If the calling object is a TVec object then the Src can be of any type,
      otherwise TMtx can only obtain size from a TMtx object and TSparseMtx
      can only obtain size from a TSparseMtx object.

      If the calling object and Src are of different types, the complex property can be
      different, if both objects have a matching <see cref="Length"/> property.
      In this case only the Complex property of the calling object will changed,
      while all other properties describing the size of the object (rows, cols, length,
      nonZeros) will be preserved. This is different from simply setting the Complex property.
      Changing the Complex property directly would also change the Length, Cols and NonZeros
      properties.
</remarks>
*)
    function Size(const Src: TMtxVec): TMtxVec ; overload; 
    (*<summary>Also allows the complex property of the calling object to become of
       AComplex value instead of Src.Complex value.</summary>
       
<remarks>It is also possible to pass the calling object as the Src with a different AComplex value.
       The value of the complex property can be changed
       without knowing the actual type of the object.
</remarks>
*)
    function Size(const Src: TMtxVec; AComplex: boolean): TMtxVec ; overload;

    (*<summary>Sizes the array.</summary>
      
<remarks>Sizes the Dst array so that it can hold all the values stored in the calling
      object. If the <see cref="Complex"/> property is false an exception will
      be raised.
</remarks>
*)
    procedure SizeToArray(var Dst: TCplxArray); overload; 
    (*<summary>Sizes double precision array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
      Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TDoubleArray); overload; 
    (*<summary>Size single precision array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
      Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TSingleArray); overload; 
    (*<summary>Sizes integer array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
      Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TIntegerArray); overload; 
    (*<summary>Sizes integer array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
      Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TSmallIntArray); overload; 
    (*<summary>Sizes integer array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
      Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: Math387.TByteArray); overload; 

    (*<summary>Compares two objects and returns True, if they are equal.</summary>
      
<remarks>Compares two objects and returns True, if they are equal. The IsEqual
      uses cmpAbsolute comparison method with comparison tolerance
      of 10*EPS by default.

      The method compares only <see cref="Complex"/> and <see cref="Length"/> properties and
      coresponding values. To compare matrices or sparse matrices, use the Equal method.
</remarks>


      <SeeAlso cref="Matrix.Equal"/>
      <SeeAlso cref="TSparseMtx.Equal"/>
      <SeeAlso cref="Vector.Equal"/>*)
    function IsEqual(const Vec: TMtxVec): boolean; overload; 
    (*<summary>Compares Vec elements [VecIndex]..[VecIndex+Len-1] with calling object
       elements [Index]..[Index+Len-1].</summary>*)
    function IsEqual(const Vec: TMtxVec; VecIndex, Index, Len: integer): boolean; overload; 
    (*<summary>Compares Vec elements with coresponding calling object elements with Compare
      method and specified Precision.</summary>*)
    function IsEqual(const Vec: TMtxVec; Precision: double; Compare: TCompare = cmpAbsolute): boolean; overload; 
    (*<summary>Compares Vec elements [VecIndex]..[VecIndex+Len-1] with calling object
       elements [Index]..[Index+Len-1] with Compare
       method and specified Precision.</summary>*)
    function IsEqual(const Vec: TMtxVec; VecIndex, Index, Len: integer; Precision: double; Compare: TCompare = cmpAbsolute): boolean; overload;

    (*<summary>Compares complex Value with all calling object elements.</summary>*)
    function IsEqual(Value: TCplx): boolean; overload;
    (*<summary>Compares real Value with all calling object elements.</summary>*)
    function IsEqual(Value: double): boolean; overload;
    (*<summary>Compares real Value with all calling object elements with Compare
      method and specified Tolerance.</summary>*)
    function IsEqual(Value: double; Tolerance: double; Compare: TCompare): boolean; overload;
   (*<summary>Compares complex Value with all calling object elements with Compare
      method and specified Tolerance.</summary>*)
    function IsEqual(Value: TCplx; Tolerance: double; Compare: TCompare): boolean; overload;

    (*<summary>Standard deviation.</summary>
      
<remarks>Calculate the standard deviation of all calling object elements. The result is a real value.
      An exception is raised if calling vector <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Vector;
          c: double;
          aMean: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          aMean := a.Mean;
          c := a.StdDev(aMean); //if both Mean and StdDev are required this is faster
          // c := a.StdDev; //this is an alternative.
      end;
      </code>
      </Example>

      <SeeAlso cref="Mean"/>*)
    function StdDev: double; overload; 
    (*<summary>Returns the standard deviation of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or if array
      borders are overrun/underrun.
</remarks>
*)
    function StdDev(Index,Len: integer): double; overload; 
    (*<summary>Returns the standard deviation of all calling object complex elements.</summary>
       
<remarks>The average of all calling object elements must be passed as a AMean parameter.
       An exception is raised if calling object <see cref="Complex"/> property is false.
</remarks>
*)
    function StdDev(AMean: TCplx): TCplx; overload; 
    (*<summary>Returns the standard deviation of calling object complex elements [Index]..[Index+Len-1].</summary>
       
<remarks>The average of all calling object elements must be passed as a AMean parameter.
       An exception is raised if calling object <see cref="Complex"/> property is false
       or if array borders are overrun/underrun.
</remarks>
*)
    function StdDev(AMean: TCplx; Index, Len: integer): TCplx; overload; 
    (*<summary>Returns the standard deviation of all calling object elements.</summary>
       
<remarks>The average of all calling object elements must be passed as a AMean parameter.
       An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    function StdDev(AMean: double): double; overload; 
    (*<summary>Returns the standard deviation of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The average of the coresponding elements must be passed as a parameter.
      An exception is raised if calling object <see cref="Complex"/> property is true
      or if array borders are overrun/underrun.
</remarks>
*)
    function StdDev(AMean: double; Index, Len: integer): double; overload; 

    (*<summary>Returns the standard deviation of all calling object elements.</summary>
       
<remarks>The average of all calling object elements must be passed as a AMean parameter.
       An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    procedure MeanAndStdDev(var aMean, aStdDev: double); overload; 
    (*<summary>Returns the standard deviation of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The average of the coresponding elements must be passed as a parameter.
      An exception is raised if calling object <see cref="Complex"/> property is true
      or if array borders are overrun/underrun.
</remarks>
*)
    procedure MeanAndStdDev(var aMean, aStdDev: double; Index, Len: integer); overload; 

    (*<summary>Sine and cosine.</summary>
      
<remarks>Calculates the sine and cosine for all calling object elements and stores the sines
      to SinX and cosines to CosX. Size and <see cref="Complex"/> property of SinX and CosX are
      adjusted automatically.

      Note
        Use this method if you require both sine and cosine.
</remarks>


      <Example>
      <code>
      var a,s,c: Vector;
      begin
          a.SetIt(false[0,PIDIV2,PI]);
          a.Sincos(s,c); // s=[0,1,0], c =[1,0,-1]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sin"/>
      <SeeAlso cref="Cos"/>*)
    procedure SinCos(SinX, CosX: TMtxVec); overload; 
    (*<summary>Calculates the sine and cosine for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Stores the sines to SinX elemets [SinXIndex]..[SinXIndex+Len-1] and cosines to CosX elements
      [CosXIndex]..[CosXIndex+Len-1] elements.
      Size and <see cref="Complex"/> property of SinX and CosX objects are not set automatically.
      An exception is raised if <see cref="ConditionCheck"/> and array borders are overrun/underun.
</remarks>
*)
    procedure SinCos(SinX, CosX: TMtxVec; SinXIndex, CosXIndex, Index, Len: integer); overload; 

    (*<summary>Hyperbolic sine and cosine.</summary>
      
<remarks>Calculates the hyperbolic sine and hyperbolic cosine for all calling object elements and stores
      the sines to SinhX and cosines to CoshX. Size and <see cref="Complex"/> property of SinhX and CoshX
      are adjusted automatically.

      Note
        Use this method if you require hyperbolic sine and hyperbolic cosine.
</remarks>


      <Example>
      <code>
      var a,s,c: Vector;
      begin
          a.SetIt(false[0,PIDIV2,PI]);
          a.SinhCosh(s,c);
      end;
      </code>
      </Example>

      <SeeAlso cref="Sinh"/>
      <SeeAlso cref="Cosh"/>*)
    procedure SinhCosh(SinhX, CoshX: TMtxVec); overload; 
    (*<summary>Calculates the hyperbolic sine and hyperbolic cosine for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Stores the sines to SinhX elemets [SinhIndex]..[SinhIndex+Len-1] and cosines to CoshX elements [CoshIndex]..[CoshIndex+Len-1] elements.
      Size and <see cref="Complex"/> property of SinhX and CoshX objects are not set automatically.
      An exception is raised if <see cref="ConditionCheck"/> and array borders are overrun/underun.
</remarks>
*)
    procedure SinhCosh(SinhX, CoshX: TMtxVec; SinhIndex, CoshIndex, Index, Len: integer); overload; 

    (*<summary>Sums vector values.</summary>
      
<remarks>Returns the sum of all calling object elements. An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Vector;
          b: double;
      begin
        a.SetIt(False,[1,2,3,4]);
        b := a.Sum; // b = 10
      end;
      </code>
      </Example>

      <SeeAlso cref="Sumc"/>*)
    function Sum: double; overload; 
    (*<summary>Returns the sum of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is True or array borders are overrun/underrun.
</remarks>
*)
    function Sum(Index,Len: integer): double; overload; 
    (*<summary>Calculates the sum of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Stores the result in real ASum variable. An exception is raised if calling object <see cref="Complex"/> property is True or array borders are overrun/underrun.
</remarks>
*)
    procedure Sum(out ASum: double; Index, Len: integer); overload; 
    (*<summary>Calculates the sum of all calling object complex elements.</summary>
      
<remarks>Stores the result in complex ASum variable.
      An exception is raised if calling object <see cref="Complex"/> property is False.
</remarks>
*)
    procedure Sum(out ASum: TCplx); overload; 
    (*<summary>Calculates the sum of calling object complex elements [Index]..[Index+Len-1]-</summary>
      
<remarks>Stores the result in complex ASum variable.
      An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    procedure Sum(out ASum: TCplx; Index, Len: integer); overload; 

    (*<summary>Sum (complex value).</summary>
      
<remarks>Returns the complex sum of all calling object complex elements.
      An exception is raised if calling object <see cref="Complex"/> property is False.
</remarks>

      <SeeAlso cref="Sum"/>*)
    function Sumc: TCplx; overload; 
    (*<summary>Returns the complex sum of calling object complex elements [Index]..[Index+Len-1].</summary>
       
<remarks>An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    function Sumc(Index,Len: integer): TCplx; overload; 

    (*<summary>Threshold bottom operation.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is a lower bound for threshold operation.
      All values smaller than Value will be replaced with Value.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[2,0.1,3,4]);
          a.ThreshBottom(0.2); // a = [2,0.2,3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshBottom(Value: double): TMtxVec; overload; 
    (*<summary>Perform the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshBottom(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThreshBottom(const Src: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation on Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshBottom(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold top operation.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is an <b>upper</b> bound for threshold operation.
      All values bigger than Value will be replaced with Value.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[2,0.1,3,4]);
          a.Threshtop(0.2); // a = [0.2,0.1,0.2,0.2]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshTop(Value: double): TMtxVec; overload; 
    (*<summary>Perfrom the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshTop(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThreshTop(const Src: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshTop(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 


      (*<summary>Threshold top and bottom centered around zero.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is an <b>upper</b> bound for threshold operation.
      All values smaller than Value will be replaced with Value and all values bigger than -Value will be replaced with -Value.
      The comparison checks if abs(Values[i]) &lt; Value.
</remarks>


      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a;
          MtxVec.CreateIt(out a);
          try
          {
            a.SetIt(false, new double[] {2,-0.1,3,4});
            a.ThreshAbsLT(0.2); // a = [2,-0.2,3,4]
          }
          finally
          {
            MtxVec.FreeIt(ref a);
          }
        }
      }
      </code></example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshAbsLT(const Value: double): TMtxVec; overload; 
    (*<summary>Perfrom the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsLT(const Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> properties of the calling object are
      adjusted automatically.
</remarks>
*)
    function ThreshAbsLT(const Src: TMtxVec; const Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the
      calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck" text="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsLT(const Vec: TMtxVec; const Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 


    (*<summary>Threshold top and bottom centered around zero.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is an <b>upper</b> bound for threshold operation.
      All values bigger than Value will be replaced with Value and all values smaller than -Value will be replaced with -Value.
      The comparison checks if abs(Values[i]) &gt; Value.
</remarks>


      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a;
          MtxVec.CreateIt(out a);
          try
          {
            a.SetIt(false, new double[] {2, -1, 3, 4});
            a.ThreshAbsGT(0.2); // a = [0.2, -0.2, 0.2, 0.2]
          }
          finally
          {
            MtxVec.FreeIt(ref a);
          }
        }
      }
      </code></example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshAbsGT(const Value: double): TMtxVec; overload; 
    (*<summary>Perfrom the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsGT(const Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> properties of the calling object are
      adjusted automatically.
</remarks>
*)
    function ThreshAbsGT(const Src: TMtxVec; const Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the
      calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck" text="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsGT(const Vec: TMtxVec; const Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold less than operation.</summary>
      
<remarks>Perform operation on all calling object values. The LTValue parameter is an <b>lower</b> bound for threshold operation.
      All values less than LTLevel will be replaced with LTValue.
      For complex number comparation is applied with norm of complex value.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[2,0.1,3,4]);
          a.ThresholdLT(2.3,1.5); // a = [1.5,1.5,3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThresholdGT"/>
      <SeeAlso cref="ThresholdGT_LT"/>*)
    function ThresholdLT(LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perfrom "less than" threshold operation on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThresholdLT(LTLevel, LTValue: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation on Vec elements from range [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      An exception will be raised if Vec.Complex and Complex of the calling object are not equal.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel, LTValue: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perfrom "less than" threshold operation for complex numbers.</summary>
      
<remarks>If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(LTLevel: double; LTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perfrom "less than" threshold operation for complex numbers on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
      If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(LTLevel: double; LTValue: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation for complex numbers on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
      If Vec object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel: double; LTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation for complex numbers on Vec elements from range [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      If Vec object or calling object contain none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel: double; LTValue: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold greater than operation</summary>
      
<remarks>Perform operation on all calling object values. The GTValue parameter is an <b>upper</b> bound for threshold operation.
      All values bigger than LTLevel will be replaced with GTValue.

      Note
        For complex number comparation is applied with norm of complex value.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[2,0.1,3,4]);
          a.ThresholdGT(2.3,3.4); // a = [2,0.1,3.4,3.4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThresholdLT"/>
      <SeeAlso cref="ThresholdGT_LT"/>*)
    function ThresholdGT(GTLevel, GTValue: double): TMtxVec; overload; 
    (*<summary>Perfrom "greater than" threshold operation on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThresholdGT(GTLevel, GTValue: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "greater than" threshold operation on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel, GTValue: double): TMtxVec; overload; 
    (*<summary>Perform "greater than" threshold operation on Vec elements from range [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      An exception will be raised if Vec.Complex and Complex of the calling object are not equal.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel, GTValue: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perfrom "greater than" threshold operation for complex numbers.</summary>
      
<remarks>If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(GTLevel: double; GTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perfrom "greater than" threshold operation for complex numbers on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
      If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(GTLevel: double; GTValue: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "greater than" threshold operation for complex numbers on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
      If Vec object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel: double; GTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perform "greater than" threshold operation for complex numbers on Vec elements from range [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      If Vec object or calling object contain none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel: double; GTValue: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold greater than and less than operation.</summary>
      
<remarks>Perform operation on all calling object values. The LTValue parameter is an <b>lower</b> bound for threshold operation.
      The GTValue parameter is an <b>upper</b> bound for threshold operation.
      All values less than LTLevel will be replaced with LTValue. All values bigger than GTLevel will be replaced with GTValue.
      Operation is available only for none Complex values.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(True,[2,0.1,3,4]);
          a.ThresholdGT_LT(2.3,3.4,1,0.5); // a = [2,0.5,3.4,3.4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThresholdLT"/>
      <SeeAlso cref="ThresholdGT"/>*)
    function ThresholdGT_LT (GTLevel, GTValue, LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perform "greater than and less than" threshold operation on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
      An exception will be raised if the calling object contains complex numbers.
</remarks>
*)
    function ThresholdGT_LT (GTLevel, GTValue, LTLevel, LTValue: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "greater than and less than" threshold operation on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
      An exception will be raised if Vec object contains complex numbers.
</remarks>
*)
    function ThresholdGT_LT (const Vec: TMtxVec; GTLevel, GTValue, LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perform "greater than and less than" threshold operation on Vec elements from range [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      An exception will be raised if Vec object or the calling object contain complex numbers.
</remarks>
*)
    function ThresholdGT_LT(const Vec: TMtxVec; GTLevel, GTValue, LTLevel, LTValue: double; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Rounds a real number towards zero and returns the fractional part.</summary>
      
<remarks>Rounds all calling object elements towards zero to an integer and stores
      the result in the TruncDst object as floating point numbers. The fractional
      part is stored in the FracDst.
</remarks>


      <SeeAlso cref="Frac"/>
      <SeeAlso cref="Round"/>*)
    procedure TruncAndFrac(TruncDst: TMtxVec; FracDst: TDenseMtxVec); overload;

    (*<summary>Truncate calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Store the results to TruncDst object elements
      [TruncIdx]..[TruncIdx+Len-1]. The fractional parts are saved in FracDst elements
      [FracIdx]..[FracIdx+Len-1]. Size and <see cref="Complex"/> property of calling object must be set
      explicitly to match those of Src object. An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    procedure TruncAndFrac(TruncDst: TMtxVec; FracDst: TDenseMtxVec; TruncIdx, FracIdx, Index, Len: integer); overload;

    (*<summary>Rounds a real number towards zero.</summary>
      
<remarks>Rounds all calling object elements towards zero to an integer and stores
      the result in the calling object again as floating point numbers.
</remarks>


      <SeeAlso cref="Frac"/>
      <SeeAlso cref="Round"/>*)
    function Trunc: TMtxVec; overload; 
    (*<summary>Truncate calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Trunc(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Truncate all Src object elements and store the results in calling object elements.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Trunc(const Src: TMtxVec): TMtxVec; overload; 
    (*<summary>Truncate all calling object elements and store the result in the Dst integer array.</summary>
      
<remarks>Length of the array is automatically adjusted. If the calling object is Complex, the length
      of the Dst array is equal to 2*<see cref="Length"/>.
</remarks>
*)
    procedure Trunc(var Dst: TIntegerArray); overload; 
    (*<summary>Truncate Src object elements [SrcIndex]..[SrcIndex+Len-1] and store the results to calling object elemenents
      [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object must be set explicitly to match those of Src
      object. An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Trunc(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec; overload; 

  (*<summary>Write object header and values to a file.</summary>
    
<remarks>Write the header describing the calling object and the values array of the calling object to the file,
    specified by the FileName. If the file already exist, the data is overwritten by default. If Append is
    True, the data is appended to the end of the file. The data is always saved with default
    precision. (single or double).

     * In case of '.csv' extension a comma is used as a column delimiter for matrices.
     * In case of '.txt' extension a tab is used as a column delimiter for matrices.
     * For all other extensions, the expected format is binary.

    Note
      It is recommended you use a *.mtx extension when you're saving/loading matrix to/from file.
      Similarly, you should use a *.Vec extension when you're saving/loading vector to/from file.
</remarks>


    <Example>
    <code>
    var Mtx: Matrix;
    begin
        Mtx.SetIt(2,2,False,[3,1,-1,5]);
        Mtx.SaveToFile('c:\test.mtx'); // Write info and header for Mtx to file
    end;
    </code>
    </Example>

    <SeeAlso cref="LoadFromFile"/>
    <SeeAlso cref="SaveToStream"/>
    <SeeAlso cref="LoadFromStream"/>*)
    procedure SaveToFile(const FileName: string; Append: boolean = False);

    (*<summary>Reads the header information and the values array content from the file.</summary>
      
<remarks>Reads the header information and the values array content from the file specified by FileName parameter.

     * In case of '.csv' extension a comma is used as a column delimiter for matrices.
     * In case of '.txt' extension a tab is used as a column delimiter for matrices.
     * For all other extensions, the expected format is binary.
</remarks>


      <Example>
      <code>
      var b: Vector;
      begin
          b.LoadFromFile('c:\test.Vec'); // Read header and values for b
      end;
      </code>
      </Example>

      <SeeAlso cref="SaveToFile"/>
      <SeeAlso cref="LoadFromStream"/>*)
    procedure LoadFromFile(const FileName: string);

    (*<summary>Reads the header information and the values array content from a stream.</summary>
      
<remarks>Reads the header information and the values array content from the SrcStream. The return value indicates
      the number of elements read.
</remarks>


      <Example>
      <code>
      var b: Vector;
          AStream: TFileStream;
      begin
          b.SetIt(False,[0,0,1,3,2]);
          AStream := TFileStream.Create('C:\test.Vec',fmCreate);
          try
            b.LoadFromStream(AStream); // Read info and header for b
          finally
            AStream.Free;
          end;
      end;
      </code>
      </Example>

      <SeeAlso cref="SaveToStream"/>
      <SeeAlso cref="LoadFromFile"/>*)
    
    
    function LoadFromStream(const Src: TStream): Int64; overload;
    

    

    

    (*<summary>Writes the header information and the Values content to a stream.</summary>
      
<remarks>Writes the header information and the Values content to a DstStream stream.
      Number type is defined by the Precision parameter. Rounding defines the rounding for integer types.
      When saving double precision as single precision, all overflows are saved as INF (-INF). When saving
      to integer types all overflows are clipped. Attempt to save single precision as double precision
      will raise an exception.
</remarks>


      <Example>
      <code>
      var b: Vector;
          AStream: TFileStream;
      begin
        b.SetIt(False,[0,0,1,3,2]);
        AStream := TFileStream.Create('C:\test.Vec',fmCreate);
        try
          b.SaveToStream(AStream); // Write info and header for b
        finally
          AStream.Free;
        end
      end;
      </code>
      </Example>

      <SeeAlso cref="LoadFromStream"/>
      <SeeAlso cref="WriteHeader"/>
      <SeeAlso cref="WriteValues"/>
      <SeeAlso cref="SaveToFile"/>*)
    procedure SaveToStream(const Dst: TStream); overload;
    

    

    
    (*<summary>Writes object Values content to a stream.</summary>
      
<remarks>Writes the calling object Values content to the DstStream stream. No other values describing the data type or length are written
      to the DstStream. Number type is defined by the Precision parameter. Rounding defines the rounding for integer types. When
      saving double precision as single precision, all overflows are saved as INF (-INF). When saving to integer types all overflows
      are clipped. Attempt to save single precision as double precision will raise an exception. The paramateres must be the same
      as for the <See Method="WriteHeader"/> method.

      Note
        Use this method separately only, if you want user defined storage format.
</remarks>


      <Example>
      <code>
      var b: Vector;
        AStream: TFileStream;
      begin
        b.SetIt(False,[0,0,1,3,2]);
        AStream := TFileStream.Create('C:\test.Vec',fmCreate);
        try
          b.WriteHeader(AStream); // Write info for b
          b.WriteValues(AStream); // Write values of b
        finally
          AStream.Free;
        end;
      end;
      </code>
      </Example>

      <SeeAlso cref="ReadValues"/>
      <SeeAlso cref="WriteHeader"/>
      <SeeAlso cref="SaveToStream"/>*)
    procedure WriteValues(const Dst: TStream;
                          Precision: TPrecision;
                          Rounding: TRounding = rnTrunc); overload;
    procedure WriteValues(const Dst: TStream); overload;
    

    
    
    (*<summary>Writes the header information for the calling vector to a stream.</summary>
      
<remarks>Writes the header information for the calling object to a DstStream stream. The header information contains information about object (size, complex, type of values
      in Values array, ...) which all define the state of the object. Number type is defined by the Precision parameter. Rounding defines the rounding for integer types.
      When saving double precision as single precision, all overflows are saved as INF (-INF). When saving to integer types all overflows are clipped.
</remarks>


      <Example>
      <code>
      var b: Vector;
          AStream: TFileStream;
      begin
        b.SetIt(False,[0,0,1,3,2]);
        AStream := TFileStream.Create('C:\test.bin',fmCreate);
        try
          b.WriteHeader(AStream); // Write info for b
          b.WriteValues(AStream); // Write values of b
        finally
          AStream.Free;
        end;
      end;
    </code>
    </Example>

    <SeeAlso cref="ReadHeader"/>
    <SeeAlso cref="WriteValues"/>
    <SeeAlso cref="WriteValues"/>*)
    procedure WriteHeader(const Dst: TStream;
                          Precision: TPrecision;
                          Rounding: TRounding = rnTrunc); overload;
    procedure WriteHeader(const Dst: TStream); overload;
    

    
    
    (*<summary>Reads the header information from a stream to object.</summary>
      
<remarks>Reads the header information from a DstStream stream to calling object. The header information contains all necessary information
      defining the object. The function returns the precision in which the data was stored.
      This information is required for the <see cref="ReadValues"/> method.
</remarks>


      <Example>
      <code>
      var b: Vector;
          AStream: TFileStream;
          Precision: TPrecision;
      begin
        AStream := TFileStream.Create('C:\test.bin',fmOpenRead);
        try
          Precision := b.ReadHeader(AStream); // Read info for b
          b.ReadValues(AStream,Precision); // Read values of b
        finally
          AStream.Free;
        end;
      end;
      </code>
      </Example>

      <SeeAlso cref="ReadValues"/>
      <SeeAlso cref="WriteValues"/>
      <SeeAlso cref="WriteHeader"/>*)
    function ReadHeader(const Src: TStream): TPrecision; overload;
    

    

    (*<summary>Adds Value to object elements.</summary>
      <SeeAlso cref="Sub"/>*)
    function Add(Value: double): TMtxVec; overload; 
    (*<summary>Adds complex Value to all calling object complex elements.</summary>*)
    function Add(Value: TCplx): TMtxVec; overload; 
    (*<summary>Adds Value to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Add(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds complex Value to calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Add(Value: TCplx; Index, Len: integer): TMtxVec; overload; 

    (*<summary>Adds Value to the each element of the Vec object.</summary>
      
<remarks>Stores the result in the calling object. Size and <see cref="Complex"/> properties of the calling
      object are set automatically.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Adds complex Value to each element of the Vec object.</summary>
      
<remarks>Store the result to the calling object.
       Size property of the calling object is set automatically.
       <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: TCplx): TMtxVec; overload; 
    (*<summary>Adds Value to each element of Vec object in range [VecIndex]..[VecIndex+Len-1].</summary>
        
<remarks>Store the results to elements [Index]..[Index+Len-1] of the calling object.
       Size of the calling object is not changed. An exception is raised if array borders are overrun.
       <see cref="Complex"/> property of the calling object is set implicitly.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds complex Value to each elements of the Vec object in range [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Stores the result to elements [Index]..[Index+Len-1] of the calling object.
      Size of the calling object is not changed. An exception is raised if array borders are overrun.
      <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Array addition.</summary>
      
<remarks>Add each of Vec elements to corresponding elements in the calling object.
</remarks>


      <SeeAlso cref="Sub"/>*)
    function Add(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Add each of Vec elements to corresponding elements in the calling object.</summary>
      
<remarks>In addition, the following formula is begin used:
      <code> result = result+ aScale*Vec . </code>

      The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match the Vec object.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: double): TMtxVec; overload; 
    (*<summary>Add each of Vec elements to corresponding elements in the calling object.</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ Cplx(RScale,IScale)*Vec . </code>
      When default values for parameters are being used the "normal" addition is being performed.

      The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match the Vec object.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; RScale: double; IScale: double): TMtxVec; overload; 
    (*<summary>Add each of Vec elements to corresponding elements in the calling object.</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ aScale*Vec . </code>

      The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match the Vec object.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: TCplx): TMtxVec; overload; 
    (*<summary>Add each of Vec2 elements to corresponding elements in Vec1.</summary>
      
<remarks>The results are stored in the calling object.
      Size and <see cref="Complex"/> properties of the calling object are set implicitly to match
      Vec1 and Vec2 vectors.
</remarks>
*)
    function Add(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Add Vec elements [VecIndex]..[VecIndex+Len-1] to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Add(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds Vec elements [VecIndex]..[VecIndex+Len-1] to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ Cplx(aScale)*Vec . </code>

      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds Vec elements [VecIndex]..[VecIndex+Len-1] to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ aScale*Vec . </code>

      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Add Vec1 elements [Vec1Index]..[Vec1Index+Len-1] to Vec2 elements [Vec2Index]..[Vec2Index+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1].
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Add(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Add a product of two vectors.</summary>
      
<remarks>Multiply Vec1 elements with coresponding Vec2 elements and add the result
      to the calling vector. The size of the calling vector is set
      implicitly.
</remarks>


      <SeeAlso cref="Mul"/>
      <SeeAlso cref="Add"/>*)
    function AddProduct(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 

    (*<summary>Multiply Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 elements [Vec2Index]..[Vec2Index+Len-1]
      add the results to the calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function AddProduct(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    
    (*<summary>Conjugate and multiply.</summary>
      
<remarks>Conjugate each of Vec elements and multiply them with corresponding elements in the calling object.
      The results are stored in the calling object. Size and <see cref="Complex"/>
      properties of the calling object are set implicitly to match Vec.
</remarks>


      <Example>
      <code>
      var a,b,c: Vector;
      begin
          a.SetIt(True,[1,2,3,4]);
          b.SetIt(True,[4,3,2,1]);
          c.ConjMul(a,b);
      end;
      </code>
      </Example>

      <SeeAlso cref="Conj"/>
      <SeeAlso cref="Mul"/>*)
    function ConjMul(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Conjugate Vec elements Vec[VecIndex]..Vec[VecIndex+Len-1] and multiply them with corresponding
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements
      [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties are <b>not</b> set.
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun or underrun.
</remarks>
*)
    function ConjMul(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Conjugate each of Vec2 elements and multiply them with corresponding elements in Vec1.</summary>
      
<remarks>The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match Vec1 and Vec2 objects.
</remarks>
*)
    function ConjMul(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Conjugate Vec2 elements [Vec2Index]..[Vec2Index+Len-1] and multiply them with corresponding Vec1 elements
      [Vec1Index]..[Vec1Index+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties of the calling vector must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function ConjMul(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    

    (*<summary> Compute X + Y*yScale </summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale with complex arguments.</summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale on sub arrays. </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale on sub arrays with complex arguments. </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X + Y*yScale) </summary>
       
<remarks>By making use of yScale, it is also possible to compute the following (at the same or higher speed):

       (X - Y)^2 = X^2 - 2XY  +Y^2
</remarks>
*)
    function AddScaledSqr(const X, Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X + Y*yScale) </summary>*)
    function AddScaledSqr(const X, Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X) + sqr(Y)*yScale </summary>
       
<remarks>By making use of yScale, it is also possible to compute the following (at the same or higher speed):

       X^2 - Y^2
</remarks>
*)
    function SqrAddScaled(const X, Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X) + sqr(Y)*yScale </summary>*)
    function SqrAddScaled(const X, Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X) + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X) + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y + Z </summary>*)
    function Add(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X + Y + Z on sub arrays </summary>*)
    function Add(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y + Z*zScale </summary>*)
    function AddScaled(const X, Y, Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X + Y + Z*zScale </summary>*)
    function AddScaled(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;


    (*<summary> Compute X + Y + zScalar </summary>*)
    function Add(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X + Y + zScalar </summary>*)
    function Add(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y + zScalar on sub arrays </summary>*)
    function Add(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y + zScalar on sub arrays </summary>*)
    function Add(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X, Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X, Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + zScalar on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + zScalar on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    

    (*<summary> Compute X - Y - Z </summary>*)
    function Sub(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X - Y - Z on sub array</summary>*)
    function Sub(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer;const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X, Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X, Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X - Y - Z*zScale </summary>*)
    function SubScaled(const X, Y, Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X - Y - Z*zScale </summary>*)
    function SubScaled(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;


    (*<summary> Compute X - Y - zScalar </summary>*)
    function Sub(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X - Y - zScalar </summary>*)
    function Sub(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y - zScalar on sub array</summary>*)
    function Sub(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y - zScalar on sub array</summary>*)
    function Sub(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X, Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X, Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    

    (*<summary> Compute X * Y / Z </summary>*)
    function MulAndDiv(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X * Y / Z on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    

    (*<summary> Compute (X + Y)*Z </summary>*)
    function AddAndMul(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y)*Z*zScale </summary>*)
    function AddAndMul(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z*zScale </summary>*)
    function AddAndMul(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y*yScale)*Z*zScale </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const yScale: double; const Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*Z*zScale </summary>*)
    function AddAndMul(const X, Y: TMtxVec;const yScale: TCplx; const Z: TMtxVec;const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: double; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X + Y)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y*yScale)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const yScale, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const yScale, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: TCplx; Index, Len: Integer): TMtxVec; overload;


    (*<summary> Compute (X + yScalar)*Z*zScale </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z*zScale </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const xScale, Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const xScale, Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X + yScalar)*zScalar </summary>*)
    function AddAndMul(const X: TMtxVec; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*zScalar </summary>*)
    function AddAndMul(const X: TMtxVec; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*zScalar on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*zScalar on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;


    

    (*<summary> Compute (X - Y)*Z </summary>*)
    function SubAndMul(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y)*Z*zScale </summary>*)
    function SubAndMul(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X - Y)*Z*zScale </summary>*)
    function SubAndMul(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer;const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer;const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y*yScale)*Z*zScale </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale: double; const Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*Z*zScale </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: double; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X - Y)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y*yScale)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: TCplx; Index, Len: Integer): TMtxVec; overload;


    (*<summary> Compute (X - yScalar)*Z*zScale </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z*zScale </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const xScale, Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const xScale, Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X - yScalar)*zScalar </summary>*)
    function SubAndMul(const X: TMtxVec; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*zScalar </summary>*)
    function SubAndMul(const X: TMtxVec; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*zScalar on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*zScalar on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;


    

    (*<summary> Compute X*Y + Z </summary>*)
    function MulAndAdd(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y + Z on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y*xyScale + Z </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y + Z*zScale </summary>*)
    function MulAndAdd(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale </summary>*)
    function MulAndAdd(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y + zScalar </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*Y + zScalar </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y + zScalar on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y + zScalar on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

    (*<summary> Compute X*Y - Z </summary>*)
    function MulAndSub(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y + Z on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y*xyScale - Z </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale - Z </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y - Z*zScale </summary>*)
    function MulAndSub(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X*Y - Z*zScale </summary>*)
    function MulAndSub(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y - zScalar </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*Y - zScalar </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

    (*<summary> Compute X/Y + Z </summary>*)
    function DivAndAdd(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y + Z on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y*xyScale + Z </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale + Z </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale + Z on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale + Z on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y + Z*zScale </summary>*)
    function DivAndAdd(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X/Y + Z*zScale </summary>*)
    function DivAndAdd(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y + zScalar </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X/Y + zScalar </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y + zScalar on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y + zScalar on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

        (*<summary> Compute X/Y - Z </summary>*)
    function DivAndSub(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y*xyScale - Z </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale - Z </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y - Z*zScale </summary>*)
    function DivAndSub(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X/Y - Z*zScale </summary>*)
    function DivAndSub(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y - Z*zScale on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y - Z*zScale on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y - zScalar </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X/Y - zScalar </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

    (*<summary> Compute X*xScale + Y*yScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X*xScale + Y*yScale) </summary>*)
    function AddScaledSqr(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X*xScale + Y*yScale) </summary>*)
    function AddScaledSqr(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X*xScale + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X*xScale + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale </summary>*)
    function SqrAddScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale </summary>*)
    function SqrAddScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*xScale + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*xScale + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + z on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + z on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*xScale - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;

    (*<summary> Compute X*xScale - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*Y*Z </summary>
       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Z parameter:

       X^2*Y
</remarks>
*)
    function Mul(const X, Y,Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Z parameter:

       X^2*zScalar
</remarks>
*)
    function Mul(const X,Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Z parameter:

       X^2*zScalar
</remarks>
*)
    function Mul(const X,Y: TMtxVec; const Z: TCplx): TMtxVec; overload;


    (*<summary> Compute X*Y*Z on sub array</summary>*)
    function Mul(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar on sub array</summary>*)
    function Mul(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar on sub array</summary>*)
    function Mul(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X / (Y*Z) </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing Y also for the Z parameter:

       X / (Y^2)
</remarks>
*)
    function Divide(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/( Y*Z ) on sub array</summary>*)
    function Divide(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X / (Y*zScale) </summary>*)
    function DivideC(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X / (Y*zScale) </summary>*)
    function DivideC(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X / (Y*zScalar) on sub array</summary>*)
    function DivideC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X / (Y*zScalar) on sub array</summary>*)
    function DivideC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X * Y * xyScale / Z </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2 * xyScale/ Z
</remarks>
*)
    function MulAndDiv(const X, Y: TMtxVec; const xyScale: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X * Y * xyScale / Z </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2 * xyScale/ Z
</remarks>
*)
    function MulAndDiv(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X * Y * xyScale / Z on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const xyScale: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X * Y * xyScale / Z on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X * Y / zScalar </summary>*)
    function MulAndDiv(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X * Y / zScalar </summary>*)
    function MulAndDiv(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;

    (*<summary> Compute X * Y / zScalar on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X * Y / zScalar on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute xScalar / (Y*Z) </summary>*)
    function Divide(const X: Double; const Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute xScalar / (Y*Z) </summary>*)
    function Divide(const X: TCplx; const Y, Z: TMtxVec): TMtxVec; overload;

    (*<summary> Compute xScalar / (Y*Z) on sub array</summary>*)
    function Divide(const X: Double; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute xScalar / (Y*Z) on sub array</summary>*)
    function Divide(const X: TCplx; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + Y*yScale)*Z*zScale</summary>

        
<remarks>The following is also possible at the same or higher speed:

        X^2 * xScale + XY * yScale

        by passing X also for the Z parameter.
</remarks>
*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*Z*zScale</summary>

        
<remarks>The following is also possible at the same or higher speed:

        X^2 * xScale + XY * yScale

        by passing X also for the Z parameter.
</remarks>
*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*Z*Scale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*Z*Scale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + Y*yScale)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X* xScale + yScalar)*Z*zScale</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X* xScale + yScalar)*Z*zScale</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X* xScale + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X* xScale + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + yScalar)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*Z*Scale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*Z*Scale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - Y*yScale)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - yScalar)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - yScalar)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + Z*zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + Z*zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer;const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + zScalar on sub array</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + zScalar on sub array</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;


    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: integer; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: integer; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale - zScalar</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - zScalar</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*yScalar - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X*yScalar - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*yScalar - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*yScalar - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X / Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing Z also for the Y parameter:

       (X / Z) * xyScale + Z * zScale
</remarks>
*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y)*xyScale + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing Z also for the Y parameter:

       (X / Z) * xyScale + Z * zScale
</remarks>
*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y)*xyScale + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X / Y) * xyScale - Z*zScale </summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - Z*zScale </summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X / Y) * xyScale - zScalar</summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - zScalar</summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

    (*<summary>Cumulative sum.</summary>
      
<remarks>Calculate the cumulative sum for calling object elements [Index]..[Index+Len-1] in-place.
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(false,[1,2,3,4];
          a.CumSum; // a = [1,3,6,10]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sum"/>*)
    function CumSum(Index, Len: Integer): TMtxVec; overload; 
    (*<summary>Calculate the cumulative sum for Vec elements [VecIndex]..[VecIndex+Len-1] and store the
      results in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the
      calling object must be set explicitly. Exception is raised if <see cref="ConditionCheck"/>  property is True
      and array borders are overrun.
</remarks>
*)
    function CumSum(const Vec: TMtxVec; VecIndex,Index,Len: Integer): TMtxVec; overload; 

    (*<summary>Calculate the cumulative product for all Vec elements.</summary>
              
<remarks>The size must be set by the user. The function will store all powers of Value:

              Values[Index + i] := IntPower(Value, i)

              at corresponding array Index
</remarks>
*)
    function CumProduct(Value: Double; Index, Len: integer): TMtxVec; overload;

    (*<summary>Calculate the cumulative product for all Vec elements.</summary>
              
<remarks>The size must be set by the user. The function will store all powers of Value:

              CValues[Index + i] := IntPower(Value, i)

              at corresponding array Index
</remarks>
*)
    function CumProduct(const Value: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary>Calculate the cumulative product for all Vec elements.</summary>
              
<remarks>The size must be set by the user. The function will store all powers of Value in

              Values[i] := IntPower(Value, i)

              at corresponding array index.
</remarks>
*)
    function CumProduct(Value: Double): TMtxVec; overload;

    (*<summary>Calculate the cumulative product for all Vec elements.</summary>
              
<remarks>The size must be set by the user. The function will store all powers of Value in

              CValues[i] := IntPower(Value, i)

              at corresponding array index.
</remarks>
*)
    function CumProduct(const Value: TCplx): TMtxVec; overload;

    (*<summary>The forward discrete cosine transform (DCT).</summary>
      
<remarks>Calculates the forward discrete cosine transform (DCT) of the Vec and writes the result in the calling vector.
      If Vec.Length is a power of 2, the function uses an efficient algorithm that is significantly faster than
      the direct computation of DCT. For other values of Vec Length, this function uses the direct formulas
      given below; however, the symmetry of cosine function is taken into account, which allows to perform
      about half of the multiplication operations in the formulas. In the following definition of DCT,
      N=Vec.Length and V is the calling vector:

      <IMG name="TVec18"/>
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      begin
        a.SetIt(False,[1,-2,3,4]);
        b.DCT(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="IDCT"/>
      <SeeAlso cref="FFT"/>*)
    function DCT(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Difference.</summary>
      
<remarks>Calculate the difference for Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the calling vector must be set explicitly.
      The following formula is used to calculate the difference:

      <IMG name="tvec19"/>

      An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function Difference(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Vector division.</summary>
      
<remarks>Divide each of Vec elements with corresponding elements in the calling object.
      Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.

      The threshold parameter is used to prevent against division by zero and
      numerical instabilities in the follow on processing.
      All values of Vec smaller than Threshold will be replaced with Threshold.
</remarks>


      <SeeAlso cref="Mul"/>*)
    function Divide(const Vec: TMtxVec; Threshold: double): TMtxVec; overload; 
    (*<summary>Divide each of Vec elements with corresponding elements in the calling object.</summary>
      
<remarks>Store the result in the calling object.
      Size and <see cref="Complex"/> property of the calling object are set automatically.
</remarks>
*)
    function Divide(const Vec: TMtxVec; Threshold: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide each of Vec1 elements with corresponding elements in the Vec2 object.</summary>
       
<remarks>Store the result in the calling vector.
</remarks>
*)
    function Divide(const Vec1, Vec2: TMtxVec; Threshold: double): TMtxVec; overload; 
    (*<summary>Divide Vec1 elements [Vec1Index]...[Vec1Index+Len-1] with corresponding elements
       [Vec2Index]...[Vec2Index+Len-1] from the Vec object.</summary>
        
<remarks>Store the result in the calling vector [Index]...[Index+Len-1].
</remarks>
*)
    function Divide(const Vec1, Vec2: TMtxVec; Threshold: double; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide each of Num elements with corresponding elements in Den.</summary>
      
<remarks>Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.

      Note
        The result of division by zero will be the INF constant. Division of zero
        by zero will result in NAN.
</remarks>
*)
    function Divide(Num, Den: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide each of calling vector elements with corresponding elements in the Vec object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.

      Note
        The result of division by zero will be the INF constant. Division of zero
        by zero will result in NAN.
</remarks>
*)
    function Divide(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide calling vector elements [Index]...[Index+Len-1] with corresponding elements
       [VecIndex]...[VecIndex+Len-1] from the Vec object.</summary>
       
<remarks>Store the result in the calling vector. The <see cref="Length"/>
       of the calling vector is not changed. An exception is raised if
       <see cref="ConditionCheck"/> is True and array borders are overrun
       or underrun.

       Note
        The result of division by zero will be the INF constant. Division of zero
         by zero will result in NAN.
</remarks>
*)
    function Divide(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide [NumIndex]..[NumIndex+Len-1] Num elements with [DenIndex]..[DenIndex+Len-1] elements in Den.</summary>
      
<remarks>Store result in the calling vector at positions [Index]..[Index+Len-1]
      <see cref="Size"/> and <see cref="Complex"/> property of the calling object are not changed.
      An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun or underrun.

      Note
        The result of division by zero will be the INF constant. Division of zero
        by zero will result in NAN.
</remarks>
*)
    function Divide(Num, Den: TMtxVec; NumIndex, DenIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Divide Value with elements of the calling object and store the result in the calling object.</summary>*)
    function DivideBy(Value: double): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements of the calling object and store the result in the calling object.</summary>
       
<remarks>Calling vector will be extended to complex, if the calling vector is real.
</remarks>
*)
    function DivideBy(Value: TCplx): TMtxVec; overload; 
    (*<summary>Divide Value with elements [Index]...[Index+Len-1] from the calling object.</summary>
      
<remarks>Store the result in the calling object at position [Index]...[Index+Len-1].
      An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function DivideBy(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements [Index]...[Index+Len-1] from the calling object.</summary>
      
<remarks>Store the result in the calling object at position [Index]...[Index+Len-1].
      Calling vector will be extended to complex, if the calling vector is real.
      An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function DivideBy(Value: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide Value with elements from Vec and store the result in the corresponding elements of the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are set automatically.
</remarks>
*)
    function DivideBy(Value: double; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements from Vec and store the result in the corresponding elements of the calling object.</summary>
      
<remarks>Size of the calling object is set automatically.
      <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function DivideBy(Value: TCplx; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide Value with Vec elements [VecIndex]..[VecIndes+Len-1].</summary>
      
<remarks>Store the result in the elements [Index]..[Index+Len-1] of the calling object.
      Size of the calling object is not changed. An exception will be raised if <see cref="ConditionCheck"/> is
      True and array borders are overrun or underrun.
      <see cref="Complex"/> property of the calling object is set implicitly.
</remarks>
*)
    function DivideBy(Value: double; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements [VecIndex]..[VecIndes+Len-1] from Vec.</summary>
      
<remarks>Store the result in the elements [Index]..[Index+Len-1] of the calling object. Size of the calling object is not changed. An exception will be raised
       if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
      <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function DivideBy(Value: TCplx; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Scalar product of two real arrays.</summary>
      
<remarks>Calculates the dot product (scalar value) of the calling object and Vec object and returns a real scalar value.
      The dot product is defined by the equation:

      <IMG name="TVec13"/>

      Both objects must be of equal size. If they are not, the method will return the dot product of the largest sub-array.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      prod: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          b.SetIt(False,[5,6,7,8]);
          prod := a.DotProd(b); // = 1*5 + 2*6 + * 3*7 + 4*8
      end;
      </code>
      </Example>

      <SeeAlso cref="DotProdc"/>*)
    function DotProd(const Vec: TMtxVec): double; overload; 
    (*<summary>Returns the scalar product between Vec elements [VecIndex]..[VecIndex+Len-1] and calling object elements
      [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="Complex"/> property is True.
      An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function DotProd(const Vec: TMtxVec; VecIndex, Index, Len: integer): double; overload; 

    (*<summary>Scalar product of two complex arrays.</summary>
      
<remarks>Calculates the dot product (scalar value) of the calling object and Vec object and returns a complex scalar value.
      An exception is raised if calling or Vec object <see cref="Complex"/> property is false.
      The dot product is defined by the equation:

      <IMG name="TVec13"/>

      Note
        Both objects must be of equal size. If they are not, the method will return the dot product of the largest sub-array.
</remarks>


      <Example>
      <code>
      var a,b: Vector;
      prod: TCplx;
      begin
          a.SetIt(True,[1,2,3,4]);
          b.SetIt(True,[5,6,7,8]);
          prod := a.DotProdc(b); //= (1+2i)*(5+6i)+(3+4i)*(7+8i)
      end;
      </code>
      </Example>

      <SeeAlso cref="DotProd"/>*)
    function DotProdc(const Vec: TMtxVec): TCplx; overload; 
    (*<summary>Returns the scalar product between Vec (complex) elements [VecIndex]..[VecIndex+Len-1] and calling object (complex) elements
      [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="Complex"/> property is False.
      An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function DotProdc(const Vec: TMtxVec; VecIndex, Index, Len: integer): TCplx; overload; 
    (*<summary>Returns the scalar product between Vec and calling object complex elements.</summary>
      
<remarks>If ConjVec is True, scalar product between calling object and conjugated Vec object elements is calculated.
      An exception is raised if Vec and calling object <see cref="Complex"/> property is False.
</remarks>
*)
    function DotProdc(const Vec: TMtxVec; ConjVec: boolean): TCplx; overload; 
    (*<summary>Returns the scalar product between Vec (complex) elements [VecIndex]..[VecIndex+Len-1] and calling object (complex) elements
      [Index]..[Index+Len-1].</summary>
      
<remarks>If ConjVec is True, scalar product between calling object and conjugated Vec object elements is calculated.
      An exception is raised if Vec and calling object <see cref="Complex"/> property is False.
      An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function DotProdc(const Vec: TMtxVec; ConjVec: boolean; VecIndex, Index, Len: integer): TCplx; overload; 

    (*<summary>Downsamples object values.</summary>
      
<remarks>Copy only every Factor sample from Src starting at SrcIndex up to Len to the calling object starting
      at Index. The phase parameter determines the initial sample offset. Phase must be less then Factor. Size and
      <see cref="Complex"/> properties of the calling object are set implicitly. An exception is raised if array borders are
      overrun/underrun.
</remarks>


      <SeeAlso cref="UpSample"/>*)
    function DownSample(const Src: TMtxVec; Factor, SrcIndex, Index, Len: integer; Phase: integer = 0): TMtxVec; overload; 

    (*<summary>Fast Furier Transformation (FFT) from complex to complex or from real to complex.</summary>
      
<remarks>Calculate the FFT from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object elements
      [Index]..[Index+Len-1]. The Len parameter must be a power of two. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>  is True and
      array borders are overrun. If Vec is complex, then complex to complex forward FFT is performed. If Vec is real, then real to
      complex forward FFT is performed.

      Note
        This is the indexed version of the FFT routine <See Method="FFT"/>. Look there
        for more information on FFT parameters and storage requirements.
</remarks>
*)
    function FFT(const Vec: TMtxVec; ConjugateExtend: boolean; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The forward Fast Fourier Transformation (FFT) from real to complex.</summary>
      
<remarks>Calculate the FFT from real Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object elements
      [Index]..[Index+Len-1]. The Len parameter must not be a power of two. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and Vec is not complex or if array borders are overrun.

      Note
        This is the indexed version of the FFT routine <See Method="FFTFromReal"/>. Look there
        for more information on FFT parameters and storage requirements.
</remarks>


      <SeeAlso cref="IFFT"/>
      <SeeAlso cref="Matrix.IFFT1D"/>*)
    function FFTFromReal(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse discrete cosine transform (DCT).</summary>
      
<remarks>Calculate the inverse discrete cosine transform (DCT) from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1]. The Len parameter must be the power of two. Size and <see cref="Complex"/>
      properties of the calling vector must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function IDCT(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse FFT from complex to complex.</summary>
      
<remarks>Calculate the inverse FFT from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1]. The Len parameter must be the power of two. Size and <see cref="Complex"/>
      properties of the calling vector must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.

      Note
        This is the indexed version of the FFT routine <see cref="TVec.IFFT"/>. Look there
        For more information on FFT parameters and storage requirements.
</remarks>


      <SeeAlso cref="IFFT"/>
      <SeeAlso cref="Matrix.IFFT1D"/>*)
    function IFFT(const Vec: TMtxVec; VecIndex, Index, Len: integer; NoScale: boolean=False): TMtxVec; overload; 

    (*<summary>The inverse FFT from complex to real.</summary>
      
<remarks>Calculate the inverse FFT from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1]. The Len parameter must not be a power of two. Size
      and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if
      <see cref="ConditionCheck"/> is True and array borders are overrun.

      Note
        This is the indexed version of the FFT routine <See Method="TVec.IFFTToReal"/>. Look there
        for more information on FFT parameters and storage requirements.
</remarks>


      <SeeAlso cref="IFFTToReal"/>
      <SeeAlso cref="Matrix.IFFT1DToReal"/>*)
    function IFFTToReal(const Vec: TMtxVec; VecIndex, Index, Len: integer; NoScale: boolean=False): TMtxVec; overload; 

    (*<summary>The Kurtosis (fourth central momentum).</summary>
      
<remarks>Calculate the calling object kurtosis by using mean value AMean and standard deviation AStdDev.
      Kurtosis is the fourth central moment, divided by fourth power of standard deviation:

      <IMG name="TVec06"/>
</remarks>


      <SeeAlso cref="Skewness"/>
      <SeeAlso cref="Mean"/>
      <SeeAlso cref="StdDev"/>*)
    function Kurtosis(AMean, AStdDev: double): double; overload; 
    (*<summary>Calculate the kurtosis for elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
      The AMean and AStdDev passed as parameters must be computed from the same
      elements (Index, Len) as the Kurtosis itself.
</remarks>
*)
    function Kurtosis(AMean, AStdDev: double; Index, Len: integer): double; overload; 

    (*<summary>Median.</summary>
      
<remarks>Calculate median value for all calling object elements.
</remarks>


      <Example>
      <code>
      var a: Vector;
          c: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          c := a.Median;
      end;
      </code>
      </Example>

      <SeeAlso cref="Mean"/>*)
    function Median: double; overload; 
    (*<summary>Calculate median value for calling vector elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Median(Index: integer; Len: integer): double; overload; 

    (*<summary>Vector multiplication.</summary>
      
<remarks>Multiply each of Vec elements with corresponding elements in the calling object.
      Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.
</remarks>


      <SeeAlso cref="Divide"/>*)
    function Mul(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Multiply Vec elements [VecIndex]..[VecIndex+Len-1] with calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="Complex"/> property do not match or if array
      borders are overrun/underrun.
</remarks>
*)
    function Mul(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Multiply all Vec1 elements with corresponding Vec2 elements.</summary>
      
<remarks>Store the results in calling object.
      Size and <see cref="Complex"/> property of calling object are adjusted automatically to match those of Vec1 and Vec2.
      An exception is raised if Vec1 and Vec2 size and <see cref="Complex"/> property do not match.
</remarks>
*)
    function Mul(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Multiply Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 object elements [Vec2Index]..[Vec2Index+Len-1]
      and store the results in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Mul(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Vectorised maximum.</summary>
      
<remarks>Compares Vec values with corresponding elements in the calling object and stores the bigger value in Self.
      Size and <see cref="TMtxVec.Complex"/> property of the calling object are set automatically.
      Supports real value data only.
</remarks>


      <SeeAlso cref="MinEvery"/>*)
    function MaxEvery(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec elements [VecIndex]..[VecIndex+Len-1] with calling object elements [Index]..[Index+Len-1] and store result in Self.</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="TMtxVec.Complex"/> property do not match or if array
      borders are overrun/underrun. Supports real value data only.
</remarks>
*)
    function MaxEvery(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Compare all Vec1 elements with corresponding Vec2 elements and store bigger value in Self.</summary>
      
<remarks>Stores the results in to the calling object.
      Size and <see cref="TMtxVec.Complex"/> property of calling object are adjusted automatically to match those of Vec1 and Vec2.
      An exception is raised if Vec1 and Vec2 size and <see cref="TMtxVec.Complex"/> property do not match.
      Supports real value data only.
</remarks>
*)
    function MaxEvery(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 object elements [Vec2Index]..[Vec2Index+Len-1] and store bigger value in Self.</summary>
      
<remarks>Stores the results in to the calling object elements [Index]..[Index+Len-1]. Size and <see cref="TMtxVec.Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck">ConditionCheck</see> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function MaxEvery(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 



    (*<summary>Vectorised minimum.</summary>
      
<remarks>Compares Vec values with corresponding elements in the calling object and stores the smaller value in Self.
      Size and <see cref="TMtxVec.Complex"/> property of the calling object are set automatically.
      Supports real value data only.
</remarks>


      <SeeAlso cref="MinEvery"/>*)
    function MinEvery(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec elements [VecIndex]..[VecIndex+Len-1] with calling object elements [Index]..[Index+Len-1] and store result in Self.</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="TMtxVec.Complex"/> property do not match or if array
      borders are overrun/underrun. Supports real value data only.
</remarks>
*)
    function MinEvery(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Compare all Vec1 elements with corresponding Vec2 elements and store the smaller value in Self.</summary>
      
<remarks>Stores the results in to the calling object.
      Size and <see cref="TMtxVec.Complex"/> property of calling object are adjusted automatically to match those of Vec1 and Vec2.
      An exception is raised if Vec1 and Vec2 size and <see cref="TMtxVec.Complex"/> property do not match.
      Supports real value data only.
</remarks>
*)
    function MinEvery(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 object elements [Vec2Index]..[Vec2Index+Len-1] and store the smaller value in Self.</summary>
      
<remarks>Stores the results in to the calling object elements [Index]..[Index+Len-1]. Size and <see cref="TMtxVec.Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck">ConditionCheck</see> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function MinEvery(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Maximum value.</summary>
      
<remarks>Returns the maximum value of all calling object elements. The result is a real value. An exception is
      raised is calling object <see cref="Complex"/> is true.
</remarks>


      <Example>
      <code>
      var a: Vector;
          b: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          b := a.Max; // b = 4
      end;
      </code>
      </Example>

      <SeeAlso cref="Min"/>
      <SeeAlso cref="Maxc"/>
      <SeeAlso cref="MaxMin"/>*)
    function Max: double; overload; 
    (*<summary>Returns the maximum value from calling object elements [Index]..[Index+Len-1]. The result is a real value.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Max(Index,Len: integer): double; overload; 
    (*<summary>Calculate the maximum value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result AMean is a real value. An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    procedure Max(out AMax: double; Index,Len: integer); overload; 
    (*<summary>Calculate the maximum value of all calling object elements.</summary>
      
<remarks>The AMax parameter returns the maximum value. The AIndex parameter returns the Index of maximum value.
      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    procedure Max(out AMax: double; out AIndex: integer); overload; 
    (*<summary>Calculate the maximum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMax parameter returns the maximum value. The AIndex parameter returns the Index of maximum value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrud/underrun.
</remarks>
*)
    procedure Max(out AMax: double; out AIndex: integer; Index, Len: integer); overload; 

    (*<summary>Maximum value.</summary>
      
<remarks>Returns the maximum value of all calling object complex elements. Complex elements are first compared by the amplitude
      and then by the argument. An exception is raised if calling object <see cref="Complex"/> is False.
</remarks>


      <SeeAlso cref="Max"/>*)
    function Maxc: TCplx; overload; 
    (*<summary>Returns the maximum value of calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result is a complex value. Complex elements are first compared by the amplitude and then by the argument. An exception is raised if calling object
      <see cref="Complex"/> property is False or array borders are overrud/underrun.
</remarks>
*)
    function Maxc(Index,Len: integer): TCplx; overload; 
    (*<summary>Calculate the maximum value of calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMax parameter returns complex maximum value. Returns the Index of maximum value. Complex elements are first compared by the amplitude and then by the argument.
      The AIndex parameter returns the Index of maximum value. An exception is raised if calling object <see cref="Complex"/>
      property is False or array borders are overrud/underrun.
</remarks>
*)
    function Maxc(out AMax: TCplx; Index, Len: integer): integer; overload; 

    (*<summary>Maximum and minimum value in a single pass.</summary>
      
<remarks>Calculates the maximum and minimum value of all calling object elements in a single pass. Maximum value is stored in AMax parameter,
      minimum value is stored in AMin parameter. Use this method if you require minimum AND maximum value.
</remarks>


      <SeeAlso cref="Min"/>
      <SeeAlso cref="Max"/>*)
    procedure MaxMin(out AMax,AMin: double); overload; 
    (*<summary>Calculates the maximum and minimum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Maximum value is stored in AMax parameter, minimum value is stored in AMin parameter.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrud/underrun.
</remarks>
*)
    procedure MaxMin(out AMax,AMin: double; Index, Len: integer); overload; 
    (*<summary>Calculates the maximum and minimum value of all calling object elements.</summary>
      
<remarks>Maximum value is returned in AMax parameter, minimum
      value in AMin parameter. The MaxIdx parameter returns the Index of maximum value. The MinIdx parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    procedure MaxMin(out AMax: double; out MaxIdx: integer; out AMin: double; out MinIdx: integer); overload; 
    (*<summary>Calculates the maximum and minimum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Maximum value is returned in AMax parameter, minimum
      value in AMin parameter. The MaxIdx parameter returns the Index of maximum value. The MinIdx parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true or if array borders are overrud/underrun.
</remarks>
*)
    procedure MaxMin(out AMax: double; out MaxIdx: integer; out AMin: double; out MinIdx: integer; Index, Len: integer); overload; 

    (*<summary>Mean value.</summary>
      
<remarks>Calculate the mean value of all calling object elements. The result is a real value.
      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Vector;
          b: double;
      begin
        a.SetIt(False,[1,2,3,4]);
        b := a.Mean; // b = 2.5
      end;
      </code>
      </Example>

      <SeeAlso cref="Sum"/>
      <SeeAlso cref="Meanc"/>*)
    function Mean: double; overload; 
    (*<summary>Returns real mean value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Mean(Index, Len: integer): double; overload; 
    (*<summary>Calculate the mean value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result AMean is a real value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun/underrun.
</remarks>
*)
    procedure Mean(out AMean: double; Index, Len: integer); overload; 

    (*<summary>Mean value.</summary>
      
<remarks>Returns the mean value of all calling object complex elements. The result is a complex value. An exception is
      raised is calling object <see cref="Complex"/> is False.
</remarks>

      <SeeAlso cref="Mean"/>*)
    function Meanc: TCplx; overload; 
    (*<summary>Returns complex mean value from calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    function Meanc(Index, Len: integer): TCplx; overload; 
    (*<summary>Calculate the mean value from all calling object complex elements.</summary>
      
<remarks>The result AMean is a complex value. An exception is raised if calling object <see cref="Complex"/> property is False.
</remarks>
*)
    procedure Meanc(out AMean: TCplx); overload; 
    (*<summary>Calculate the mean value from calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result AMean is a complex value.
      An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    procedure Meanc(out AMean: TCplx; Index, Len: integer); overload; 

    (*<summary>Minimum value.</summary>
      
<remarks>Calculate the minimum value of all calling object elements. The result is a real value. An exception is
      raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Vector;
          b: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          b := a.Min; // b = 1
      end;
      </code>
      </Example>

      <SeeAlso cref="Max"/>
      <SeeAlso cref="Minc"/>*)
    function Min: double; overload; 
    (*<summary>Calculate the minimum value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result is a real value. An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Min(Index,Len: integer): double; overload; 
    (*<summary>Calculate the minimum value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result AMin is a real value. An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    procedure Min(out AMin: double; Index,Len: integer); overload; 
    (*<summary>Calculate the minimum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMin parameter returns the minimum value. The AIndex parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrud/underrun.
</remarks>
*)
    procedure Min(out AMin: double; out AIndex: Integer; Index, Len: integer); overload; 
    (*<summary>Calculate the minimum value of all calling object elements.</summary>
      
<remarks>The AMin parameter returns the minimum value. The AIndex parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    procedure Min(out AMin: double; out AIndex: integer); overload; 

    (*<summary>Minimum value.</summary>
      
<remarks>Returns the minimum value of all calling object complex elements. Complex elements are first compared by the amplitude
      and then by the argument. An exception is raised if calling object <see cref="Complex"/> is False.
</remarks>

      <SeeAlso cref="Min"/>*)
    function Minc: TCplx; overload; 
    (*<summary>Returns the minimum value of calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result is a complex value.
      Complex elements are first compared by the amplitude and then by the argument. An exception is raised if calling object
      <see cref="Complex"/> property is False or array borders are overrud/underrun.
</remarks>
*)
    function Minc(Index,Len: integer): TCplx; overload; 
    (*<summary>Calculate the minimum value of calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMin parameter returns
      complex minimum value. Returns the Index of minimum value. Complex elements are first compared by the amplitude and then by the argument.
      An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    function Minc(out AMin: TCplx; Index, Len: integer): integer; overload; 

    (*<summary>The C-norm.</summary>
      
<remarks>Calculates the C  norm: ||V-Vec||, where V is the calling vector.
      If the NormC is called without any parameters, the NormC
      calculates the norm of the calling vector. The C norm of ||V-Vec|| is defined by the formula:

      <IMG name="TVec10"/>

      If RelativeError is true then the computed norm is divided by the
      norm of V, and the function returns the "relative error":

      <IMG name="TVec09"/>
</remarks>


      <Example>
      <code>
      var a,b: Vector;
        c: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          b.SetIt(False,[4,3,2,1]);
          c := a.NormC(b,False);
      end;
      </code>
      </Example>

      <SeeAlso cref="NormL1"/>
      <SeeAlso cref="NormL2"/>*)
    function NormC(const Vec: TDenseMtxVec; RelativeError: boolean = False): double; overload; 
    (*<summary>Calculates the C norm ||V-Vec|| between Vec elements [VecIndex]..[VecIndex+Len-1]
      and calling vector elements [Index]..[Index+Len-1].</summary>*)
    function NormC(const Vec: TDenseMtxVec; VecIndex,Index,Len: integer; RelativeError: boolean = False): double; overload; 
    (*<summary>Calculate the C-norm of calling vector.</summary>
      
<remarks>Computes:

       <code>
       NormC = max|a[i]|, 0 &lt; i &lt; Length-1
       </code>
</remarks>
*)
    function NormC: double; overload; 
    (*<summary>Calculates the C norm from calling vector elements [Index]..[Index+Len-1].</summary>*)
    function NormC(Index,Len: integer): double; overload; 

    (*<summary>The L1-norm.</summary>
       
<remarks>Calculates the L1  norm : ||V-Vec||, where V is calling vector.
       If the NormL1 is called without any parameters,
       the NormL1 calculates the norm of calling vector. The L1 norm of ||V-Vec|| is defined by the formula:

      <IMG name="TVec12"/>

      If RelativeError is true then the computed norm is divided by the
      norm of V, and the function returns the "relative error":

      <IMG name="TVec09"/>
</remarks>

      <Example>

    <code>
    var a,b: Vector;
      c: double;
    begin
        a.SetIt(False,[1,2,3,4]);
        b.SetIt(False,[4,3,2,1]);
        c := a.NormL1(b,True);
    end;
    </code>
    </Example>

      <SeeAlso cref="NormC"/>
      <SeeAlso cref="NormL2"/>*)
    function NormL1(const Vec: TDenseMtxVec; RelativeError: boolean = False): double; overload; 
    (*<summary>Calculates the L1 norm ||V-Vec|| between Vec elements [VecIndex]..[VecIndex+Len-1]
      and calling vector elements [Index]..[Index+Len-1].</summary>*)
    function NormL1(const Vec: TDenseMtxVec; VecIndex,Index,Len: integer; RelativeError: boolean = False): double; overload; 

    (*<summary>Calculate the L1-norm of the calling vector.</summary>

       
<remarks><code>
       NormL1 = Sum(|a[i]|), 0 &lt; i &lt; Length-1
       </code>
</remarks>
*)
    function NormL1: double; overload; 
    (*<summary>Calculates the L1 norm from calling vector elements [Index]..[Index+Len-1].</summary>*)
    function NormL1(Index,Len: integer): double; overload; 

    (*<summary>The L2-norm.</summary>
     
<remarks>Calculates the L2  norm : ||V-Vec||, where V is calling vector. If the NormL2 is called without any parameters,
     the NormL2 calculates the norm of calling vector. The L2 norm of ||V-Vec|| is defined by the formula:

      <IMG name="TVec11"/>

      If RelativeError is true then the computed norm is divided by the norm of V, and the function returns the "relative error":

      <IMG name="TVec09"/>
</remarks>


      <Example>
      <code>
      var a,b: Vector;
        c: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          b.SetIt(False,[4,3,2,1]);
          c := a.NormL2(b,True);
      end;
      </code>
      </Example>

      <SeeAlso cref="NormC"/>
      <SeeAlso cref="NormL1"/>*)
    function NormL2(const Vec: TDenseMtxVec; RelativeError: boolean = False): double; overload; 
    (*<summary>Calculates the L2 norm ||V-Vec|| between Vec elements [VecIndex]..[VecIndex+Len-1]
      and calling vector elements [Index]..[Index+Len-1].</summary>*)
    function NormL2(const Vec: TDenseMtxVec; VecIndex,Index,Len: integer; RelativeError: boolean = False): double; overload; 

    (*<summary>Calculate the L2-norm of the calling vector.</summary>

     
<remarks><code>
     NormaL2 = ( Sum(|a[i]|^2) )^0.5  , 0 &lt; i &lt; Length-1
     </code>
</remarks>
*)
    function NormL2: double; overload;  
    (*<summary>Calculates the L2 norm from calling vector elements [Index]..[Index+Len-1].</summary>*)
    function NormL2(Index,Len: integer): double;  overload; 

    (*<summary>Add/Subtract a value.</summary>
      
<remarks>Depreciated
        Use <see cref="Add"/> (Value) instead.
</remarks>
*)
    function Offset(Value: double): TMtxVec; overload;  
    (*<summary>Add/Subtract a complex value.</summary>*)
    function Offset(Value: TCplx): TMtxVec; overload;  
    (*<summary>Add/Subtract a value from [Index]..[Index+Len-1].</summary>*)
    function Offset(Value: double; Index,Len: integer): TMtxVec; overload;  
    (*<summary>Add/Subtract a complex value from [Index]..[Index+Len-1].</summary>*)
    function Offset(Value: TCplx; Index,Len: integer): TMtxVec; overload;  

    (*<summary>Calculate the range from all calling object elements.</summary>*)
    function Range: double; overload; 
    (*<summary>Returns real range value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Range(Index, Len: integer): double; overload; 
    (*<summary>Calculate the range from calling object elements [Index]..[Index+Len-1]. The result ARange is a real value.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun/underrun.
</remarks>
*)
    procedure Range(out ARange: double; Index, Len: integer); overload; 

     (*<summary>Reverse vector elements.</summary>
      
<remarks>The method reverses Vec vector elements from [VecIndex].. [VecIndex+Len-1]
      and stores them in the calling vector from [Index]...[Index+Len-1]
      by using the following equation:

      <IMG name="TVec24"/>

      This overload reverses calling vector elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(False,[1,2,3,4]);
          a.Reverse;   // a = [4,3,2,1]
      end;
      </code>
      </Example>

      <SeeAlso cref="Rotate"/>
      <SeeAlso cref="Shift"/>*)
    function Reverse(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Reverses the calling object elements [Index]..[Index+Len-1].</summary>
       
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Reverse(Index, Len: integer): TMtxVec; overload;

    (*<summary>A cyclic shift on vector elements in range.</summary>
      
<remarks>Performs cyclic shift on vector elements in specified range [Index..Index+Len].
      The number of elements to shift is specified in the Offset parameter.

      Offset can be any integer number, positive or negative.
</remarks>


      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Shift"/>*)
    function Rotate(Offset: integer; Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 

    (*<summary>A cyclic shift on vector elements in range.</summary>
      
<remarks>Performs cyclic shift on source vector elements in specified range [Index..Index+Len] and stores them to calling vector.
      The number of elements to shift is specified in the Offset parameter.

      Offset can be any integer number, positive or negative.
</remarks>


      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Shift"/>*)
    function Rotate(const Vec: TMtxVec; Offset: integer; VecIndex,Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 

    (*<summary>Shift vector elements in range.</summary>
      
<remarks>Shifts calling vector elements in specified range [Index..Index+Len].
      The number of elements by which to shift is specified in the Offset parameter.

      Offset can be any integer number, positive or negative.
</remarks>


      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Rotate"/>*)
    function Shift(Offset: integer; Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 

    (*<summary>A shift on vector elements in range.</summary>
      
<remarks>Performs shift on source vector elements in specified range [Index..Index+Len] and stores them to calling vector.
      The number of elements to shift is specified in the Offset parameter.

      Offset can be any integer number, positive or negative.
</remarks>


      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Shift"/>*)
    function Shift(const Vec: TMtxVec; Offset: integer; VecIndex,Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 

    (*<summary>Subtracts Value from object elements.</summary>
      
<remarks>Subtracts Value from all calling object elements.
</remarks>


      <SeeAlso cref="Add"/>*)
    function Sub(Value: double): TMtxVec; overload; 
    (*<summary>Subtracts complex Value from all calling object complex elements.</summary>*)
    function Sub(Value: TCplx): TMtxVec; overload; 
    (*<summary>Subtracts Value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sub(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Subtracts complex Value from calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sub(Value: TCplx; Index, Len: integer): TMtxVec; overload; 

    (*<summary>Subtract real Value from Src.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> property
      of calling object are adjusted automatically.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: double): TMtxVec; overload;
    (*<summary>Subtract complex Value from Src store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: TCplx): TMtxVec; overload;
    (*<summary>Subtract real Value from Src elements [SrcIndex]..[SrcIndex+Len-1] and store the result
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: double; SrcIndex, Index, Len: integer): TMtxVec; overload;
    (*<summary>Subtract complex Value from Src elements [SrcIndex]..[SrcIndex+Len-1] and store the result
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: TCplx; SrcIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Array subtraction.</summary>
      
<remarks>Subtract each of Vec elements from corresponding elements in the calling object.
      An exception is raised if Vec and calling object size and <see cref="Complex"/> properties do not match.
</remarks>

      <SeeAlso cref="Add"/>*)
    function Sub(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Subtract Vec2 elements from Vec1 elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Vec1 and Vec2 size and <see cref="Complex"/> property do not match.
</remarks>
*)
    function Sub(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Subtract Vec elements [VecIndex]..[VecIndex+Len-1] from corresponding calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Subtract Vec22 elements [Vec2Index]..[Vec2Index+Len-1] from Vec1 object elements [Vec1Index]..[Vec1Index+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Subtraction from value.</summary>
      
<remarks>Subtract each of calling object elements from Value.
</remarks>


      <SeeAlso cref="Add"/>
      <SeeAlso cref="Sub"/>*)
    function SubFrom(Value: double): TMtxVec; overload; 
    (*<summary>Subtract each of calling object elements from complex Value.</summary>
        
<remarks>If the calling vector is not complex, the conversion is performed automatically in a performance efficient way.
</remarks>
*)
    function SubFrom(Value: TCplx): TMtxVec; overload; 
    (*<summary>Subtract elements [Index]..[Index+Len-1] from Value and store the result in Self.</summary>
       
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True
       and array borders are overrun or underrun.
</remarks>
*)
    function SubFrom(Value: double; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Subtract elements [Index]..[Index+Len-1] from complex Value and store the result in Self.</summary>
       
<remarks>If the calling vector is not complex, the conversion to complex is performed automatically
       in performance efficient way. An exception is raised if <see cref="ConditionCheck"/> is True
       and array borders are overrun or underrun.
</remarks>
*)
    function SubFrom(Value: TCplx; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Substract Vec elements from Value and store the result in the calling object.</summary>
       
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function SubFrom(Value: double; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Substract complex Vec elements from Value and store the result in the calling object.</summary>
       
<remarks>Size property of the calling object is set automatically.
       <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function SubFrom(Value: TCplx; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Substract Vec elements [VecIndex]..[VecIndex+Len-1] from Value.</summary>
       
<remarks>Store the result to the calling object elements [Index]..[Index+Len-1].
       Size property of the calling object is not changed. An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
       <see cref="Complex"/> property of the calling object is adjusted automatically.
</remarks>
*)
    function SubFrom(Value: double; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Substract Vec elements [VecIndex]..[VecIndex+Len-1] from complex Value and store the result to the
       calling object elements [Index]..[Index+Len-1].</summary>
       
<remarks>Size property of the calling object is not changed. An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
       <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function SubFrom(Value: TCplx; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Calculate the Sum of squares of the calling vector.</summary>
       
<remarks>For complex numbers, the routine computes the squared L2 norm.

     <code>
     SumOfSquares = Sum(|a[i]|^2)   , 0 &lt; i &lt; Length-1
     </code>
</remarks>


     <SeeAlso cref="NormL2"/>*)
    function SumOfSquares: double; overload;  
    (*<summary>Calculates the sum of squares from the calling vector elements [Index]..[Index+Len-1].</summary>*)
    function SumOfSquares(Index,Len: integer): double;  overload; 

    (*<summary>Inserts zeroes between consecutive array values.</summary>
      
<remarks>Copy Len values from Src starting at SrcIndex to the calling object starting at position Index and place Factor-1 zeros
      between consecutive values. Size and <see cref="Complex"/> properties of the calling object must be set
      explicitly. Phase parameter defines the initial sample offset and must be less then Factor. An exception is raised,
      if array borders are overrun/underrun.
</remarks>


      <SeeAlso cref="DownSample"/>*)
    function UpSample(const Src: TMtxVec; Factor,SrcIndex, Index, Len: integer; Phase: integer = 0): TMtxVec; overload; 


    (*<summary>Skewness (third central momentum).</summary>
      
<remarks>Calculate the calling object skewness by using mean value AMean and standard deviation AStdDev.
      Skewness is the third central moment, divided by third power of standard deviation:

      <IMG name="TVec07"/>
</remarks>


      <Example>
      <code>
      var a: Vector;
        c,d: double;
      begin
          a.SetIt(False,[1,2,3,4]);
          d := a.Mean;
          c := a.Skewness(d, a.StdDev(d));
      end;
      </code>
      </Example>

      <SeeAlso cref="Kurtosis"/>
      <SeeAlso cref="Mean"/>
      <SeeAlso cref="StdDev"/>*)
    function Skewness(AMean, AStdDev: double): double; overload; 
    (*<summary>Calculate the skewness for elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
      The AMean and AStdDev parameters must be computed from the same elements from which
      the Skewness is to be computed.
</remarks>
*)
    function Skewness(AMean, AStdDev: double; Index, Len: integer): double; overload; 

    

      (*<summary>Biased auto-correlation.</summary>
        
<remarks>Calculates the biased auto-correlation of the vector Vec. The result of Length = Lags is stored in the calling vector (V).
        The Lags parameter must be equal or smaller than the calling vector length. The biased auto-correlation
        is defined by the following equation:

        <IMG name="TVec03"/>
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            b.AutoCorrBiased(a,2);
        end;
        </code>
        </Example>

        <SeeAlso cref="AutoCorrNormal"/>
        <SeeAlso cref="AutoCorrUnBiased"/>*)
      function AutoCorrBiased(const Vec: TVec; Lags: integer): TVec;

      (*<summary>Normal auto-corellation.</summary>
        
<remarks>Calculates the normal auto-correlation of the vector Vec. The result of Length = Lags is stored in the calling vector (V).
        The Lags parameter must be equal or smaller than the calling vector (V) length. The normal auto-correlation is defined
        by the following equation:

        <IMG name="TVec04"/>
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            b.AutoCorrNormal(a,2);
        end;
        </code>
        </Example>

        <SeeAlso cref="AutoCorrBiased"/>
        <SeeAlso cref="AutoCorrUnBiased"/>*)
      function AutoCorrNormal(const Vec: TVec; Lags: integer): TVec;

      (*<summary>Unbiased auto-correlation.</summary>
        
<remarks>Calculate the unbiased auto-correlation of the vector Vec. The result of Length = Lags is stored in the calling
        vector (V). The Lags parameter must be equal or smaller than the calling vector (V) length. The unbiased
        auto-correlation is defined by the following equation:

        <IMG name="TVec05"/>
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            b.AutoCorrUnBiased(a,2);
        end;
        </code>
        </Example>

        <SeeAlso cref="AutoCorrBiased"/>
        <SeeAlso cref="AutoCorrNormal"/>*)
      function AutoCorrUnBiased(const Vec: TVec; Lags: integer): TVec;

      (*<summary>Concatenates an array of TVec objects.</summary>
        
<remarks>Concatenates an array of TVec objects. The method copies the contents of all TVec objects from the Src
        array to the calling object. The <see cref="Length"/> and <see cref="Complex"/> properties of the calling
        vector are set implicitly. An exception is raised, if Complex properties of TVec objects do not match.
</remarks>


        <Example>
        <code>
        var a,b,c,d: Vector;
        begin
            a.SetIt(False,[1,2,3]);
            b.Copy(a);
            c.Concat([a,b]); // c = [1,2,3,1,2,3]
            d.Size(10,True);
            d.SetZero(0,4);
            d.Concat(4,[c]); // d = [0,0,0,0,1,2,3,1,2,3]
        end;
        </code>
        </Example>

        <SeeAlso cref="Split"/>
        <SeeAlso cref="Copy"/>*)
      function Concat(const Src: array of TVec): TVec; overload;
      (*<summary>Copies the contents of all TVec objects from the Src array to the calling vector elements, starting
        with at Index.</summary>
        
<remarks>The <see cref="Length"/> and <see cref="Complex"/> properties of the calling vector
        must be set explicitly. An exception is raised, if Complex properties of TVec objects do not match or if
        the sum of Length's exceeds the Length property of the calling object.
</remarks>
*)
      function Concat(Index: integer; const Src: array of TVec): TVec; overload;

      (*<summary>Single-rate finite, linear convolution of two sequences.</summary>
        
<remarks>Calculate the single-rate finite, linear convolution of two sequences. The results are stored in the calling vector.
        The argument names X and H are chosen to suggest FIR filtering. The result of the convolution is defined as follows:

        <IMG name="TVec14"/>

        This finite-length convolution is related to infinite-length by:

        <IMG name="TVec15"/>

        In the above equations, X'[n] and h'[n] are the zero-padded (infinite-length) versions of X[n] and h[n]; y'[n] is the
        infinite-length output version of y[n]. Then y'[n] is zero everywhere except over:

        <IMG name="TVec16"/>
</remarks>


        <SeeAlso cref="FFT"/>
        <SeeAlso cref="AutoCorrNormal"/>
        <SeeAlso cref="AutoCorrBiased"/>
        <SeeAlso cref="AutoCorrUnBiased"/>*)
      function Convolve(const X,H: TVec): TVec;

      (*<summary>Copies values from Vec1 and Vec2 (concatenate).</summary>
        
<remarks>Copy each of Vec1 and Vec2 elements to the calling vector (concatenate).
        The <see cref="Length"/> and <see cref="Complex"/> properties of the calling vector are set
        implicitly to match Vec1 and Vec2 vector.
</remarks>


        <Example>
        <code>
        var a,b,c: Vector;
        begin
            a.SetIt(True,[1,2,3,4]);
            b.Copy(a);
            c.Copy(a,b);  //concatenate a and b and store in c
            // c = [1,2,3,4,1,2,3,4]
        end;
        </code>
        </Example>

        <SeeAlso cref="Assign"/>*)
      function Copy(const Vec1,Vec2: TMtxVec): TVec; overload;

      (*<summary>The cross-correlation of two vectors.</summary>
        
<remarks>Calculate the cross-correlation of two vectors Vec1 and Vec2. The parameter HiLag indicates the top of the range
        of lags at which the correlation estimates should be computed. The parameter LoLag indicates the bottom of the
        range of lags at which the correlation estimates should be computed. The results are stored in calling vector.
        The resulting elements are defined by the equation:

        <IMG name="TVec17"/>
</remarks>


        <Example>
        <code>
        var a,b,c: Vector;
        begin
          a.SetIt(False,[1,-2,3,4]);
          b.SetIt(False,[2,-2,3,4]);
          c.CrossCorr(a,b,2,2);
        end;
        </code>
        </Example>

        <SeeAlso cref="AutoCorrBiased"/>
        <SeeAlso cref="AutoCorrNormal"/>
        <SeeAlso cref="AutoCorrUnBiased"/>*)
      function CrossCorr(const Vec1, Vec2: TVec; HiLag, LoLag: integer): TVec;

      (*<summary>Cumulative sum.</summary>
      
<remarks>Calculate the cumulative sum for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Vector;
      begin
          a.SetIt(false,[1,2,3,4];
          a.CumSum; // a = [1,3,6,10]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sum"/>*)
      function CumSum: TVec; overload;
      (*<summary>Calculate the cumulative sum for all Vec elements.</summary>
        
<remarks>Store the results in calling object. Size and  <see cref="Complex"/> properties of the calling object are set implicitly.
</remarks>
*)
      function CumSum(const Vec: TVec): TVec; overload;

      (*<summary>The forward discrete cosine transform (DCT).</summary>
        
<remarks>Calculates the forward discrete cosine transform (DCT) of all calling vector elements in-place.
        If vector <see cref="Length"/> is a power of 2, the function uses an efficient algorithm that
        is significantly faster than the direct computation of DCT. For different lengths this function uses the
        direct formulas given below; however, the symmetry of cosine function is taken into account, which allows
        to perform about half of the multiplication operations in the formulas. In the following definition of DCT,
        N=Vec.Length and V is the calling vector:

        <IMG name="TVec18"/>
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
          a.SetIt(False,[1,-2,3,4]);
          b.DCT(a);
        end;
        </code>
        </Example>

        <SeeAlso cref="IDCT"/>
        <SeeAlso cref="IDCT"/>
        <SeeAlso cref="FFT"/>*)
      function DCT: TVec; overload;
      (*<summary>Calculates the forward discrete cosine transform (DCT) of the Vec.</summary>
        
<remarks>Writes the result in the calling vector.
        If Vec.Length is a power of 2, the function uses an efficient algorithm that is significantly faster than
        the direct computation of DCT. For other values of Vec Length, this function uses the direct formulas.
</remarks>
*)
      function DCT(const Vec: TVec): TVec; overload;

      (*<summary>Copies the k-th diagonal from the TMtx object.</summary>
        
<remarks>Copies the k-th diagonal from the TMtx object. If k = 0 then the main diagonal is copied,
        if k &lt; 0 then the subdiagonal is copied and if k &gt; 0 then the k-th super diagonal is copied to the calling vector.
</remarks>


        <Example>In the following example we setup a matrix, populate it with values and then extract it's main diagonal to
        a vector.

        <code>
        var a: Vector;
            d: Matrix;
        begin
            // setup matrix
            d.SetIt(2,2,False,[1,-2,
                              3, 4]);
            // get main diagonal from matrix
            a.Diag(d,0); // a now containes [1,4];
        end;
        </code>
        </Example>

        <SeeAlso cref="Diag"/>*)
      function Diag(const Mtx: TMtx; k: integer): TVec;

      (*<summary>The difference between two succesive vector elements.</summary>
        
<remarks>Calculate the difference for all calling vector elements. The following formula is used to
        calculate the difference:

        <IMG name="tvec19"/>

        The Length of calling vector is automatically decremented by one.
</remarks>
*)
      function Difference(Lag: Integer = 1): TVec; overload;
      (*<summary>Calculate the difference for all Vec elements and store the results in the calling vector.</summary>
        
<remarks>The <see cref="Length"/> of the calling vector is set to one less the length of Vec and <see cref="Complex"/>
        property is set to Vec.Complex.
</remarks>
*)
      function Difference(const Vec: TMtxVec; Lag: Integer = 1): TVec; overload;

      (*<summary>Downsamples vector values.</summary>
        
<remarks>The methods copies only every Factor sample from the Src vector to the calling vector. The <see cref="Length"/> and <see cref="Complex"/> properties
        of the calling vector are set implicitly. The phase parameter determines the initial sample offset.
        Phase must be less than Factor.
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            b.SetIt(False,[0,0,0,0,1,2,3,4,5,6]);
            a.DownSample(b,2); // a = [0,0,1,3,5]
        end;
        </code>
        </Example>

        <SeeAlso cref="UpSample"/>
        <SeeAlso cref="PixelDownSample"/>*)
      function DownSample(const Src: TMtxVec; Factor: integer; Phase: integer = 0): TVec; overload;

      (*<summary>Compares vector elements and returns true if vectors are equal.</summary>
        
<remarks>Compares vector elements and returns true if vectors are equal, that is if all elements match in position
        and value. The Tolerance parameter defines the comparison tolerance. The maximum difference between elements
        may not exceed: +/-Tolerance.
</remarks>


        <Example>
        <code>
        var A,B: Matrix;
            c: boolean;
        begin
          A.SetIt(2,2,false,[1,2,
                            2,4]);  // 2x2 real matrix
          B.SetIt(2,2,false,[1,2,
                            2,4]);  // 2x2 real matrix

          c := A.Equal(B,1e-8); // Check for differences bigger than 0.00000001
          c := A.Equal(B); // Check for exact match
        end;
        </code>
        </Example>

        <SeeAlso cref="Find"/>*)
      function Equal(const Vec: TMtxVec; Tolerance: double = 0): boolean; overload;
      (*<summary>Optionally it is also possible to specify the Compare method.</summary>*)
      function Equal(const Vec: TMtxVec; Tolerance: double; Compare: TCompare): boolean; overload;

      (*<summary>Fast Furier Transformation (FFT) from complex to complex or from real to complex.</summary>
        
<remarks>Fast Furier Transformation (FFT) from complex to complex or from real to complex.
        Calculate the FFT from all calling vector elements in-place. If the calling vector is
        complex then complex to complex forward FFT is performed. If the calling vector is real
        then real to complex FFT is  performed.

        The <see cref="Length"/> of the transforming vector can be any number but highest performance
        will be achieved if it is a power of two.

        Note
          When performing FFT from real to complex the conjugated symmetric part
          is also generated by conjugating and mirroring the first half of the spectrum.
          If Complex is false, the operation will not be performed in-place, if the Length
          of the destination will allocate more than amount of the memory preallocated
          for the TVec object. Instead, the data will be copied first to allocate enough space
          to store the result.

        There are two important parameters to consider that affect how will the FFT
        be computed: <see cref="FFTStorageFormat"/> and <see cref="FFTScrambled"/>.
        The default storage format is fsfCCS.
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            b.FFT(a);
            a.FFT;     // a = [(10, 0),( -2,2), (-2, 0), (-2,-2)]
            if not a.Equal(b) then ERaise('Not equal');
        end;
        </code>
        </Example>

        <SeeAlso cref="FFTFromReal"/>
        <SeeAlso cref="IFFT"/>
        <SeeAlso cref="FFTStorageFormat"/>
        <SeeAlso cref="FFTScrambled"/>*)
      function FFT(ConjugateExtend: boolean = false): TVec; overload;
      (*<summary>Calculate the FFT from all Vec elements.</summary>
          
<remarks>Store the results in the calling vector.
         Vec <see cref="Length"/> must not be a power of two, but highest performance
         will be achieved if it is a power of two. Length and <see cref="Complex"/>  properties of the calling vector
         are set implicitly to match Vec vector. If Vec is complex then complex to complex forward FFT is performed.
         If Vec is real then real to complex FFT is performed and the conjugate
         symmetric part is appended.
</remarks>
*)
      function FFT(const Vec: TVec; ConjugateExtend: boolean = false): TVec; overload;

      (*<summary>The forward Fast Fourier Transformation (FFT) from real to complex.</summary>
        
<remarks>Calculates the forward Fast Fourier Transformation (FFT) from real to complex
        for the calling vector in-place. The transform should be used, when
        the conjugate symmetric part of the frequency spectrum is not desired.
        If the calling vector is complex an exception will be raised.
        The operation implicitly sets the calling vector Complex property to True.
        The highest performance will be achieved if the transform length will be a power of two.
        The transform length is equal to <see cref="Length"/>,
        when the <see cref="FFTStorageFormat"/> is fsfPack
        or fsfPerm. The default storage format is fsfCCS.

        <b>In-place fsfCCS complication</b>

        The transform length in case of fsfCCS will be equal to Length-2,
        because the result is bigger than the source data by 2 real samples, if the source
        data is even. If the source data length is odd, then <see cref= "FFTOddLength"/> must
        be set to True and only Length-1 samples will be used, but Length must
        of course in that case be even, or Length-1 will not be odd.
        The last two (one) samples in the vector will be ignored and
        will be overwritten with the result.
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin //Even
            a.SetIt(false,[1,2,3,4]);
            b.FFTFromReal(a); // b = [(10, 0),( -2,2), (-2, 0)]
            a.SetIt(false,[1,2,3,4, 0, 0]); //result requires 3 complex (or 6 real values)
            a.FFTFromReal; // b = [(10, 0),( -2,2), (-2, 0)]

            //Odd length
            a.SetIt(false,[1,2,3]);

            b.FFTOddLength := True; //use only Length-1 samples
            b.FFTFromReal(a); // b = [(6,0),( -1.5,0.8660)] //result requires 2 complex (= 4 real numbers)

            a.SetIt(false,[1,2,3,0]);

            a.FFTOddLength := True; //use only Length-1 samples
            a.FFTFromReal; // b = [(6,0),( -1.5,0.8660)] //result requires 2 complex (= 4 real numbers)
        end;
        </code>
        </Example>

        <SeeAlso cref="FFT"/>
        <SeeAlso cref="TDenseMtxVec.FFT"/>
        <SeeAlso cref="IFFT"/>
        <SeeAlso cref="TDenseMtxVec.IFFT"/>*)
      function FFTFromReal: TVec; overload;
      (*<summary>Calculate the FFT from all Vec elements and store the result in the calling vector.</summary>
         
<remarks><see cref="Length"/> of the calling vector is set to match the length
         of the result.
</remarks>
*)
      function FFTFromReal(const Vec: TVec): TVec; overload;

      (*<summary>Finds and gathers vector elements.</summary>
        
<remarks>Fills the Indexes vector with indexes, of those elements where the Op
        comparison between a and b is True.  Op string parameter can be '&lt;', '&gt;', '&gt;=','&lt;=','=' or '&lt;&gt;'.
        The method also copies or "gathers" the matched elements to the calling vector.
        The Length and complex property of the calling vector are set automatically.

        The Indexes vector stores the indexes as Integer in to the memory
        location occupied by Values array. The memory is typecasted
        to an array of integers via IValues array property. Other TMtxVec methods
        can not be used to perform operations on an array of integers
        unless explicitely specified.
</remarks>
*)
      function FindAndGather(const a: TMtxVec; const op: string; const b: TCplx; const Indexes: TVecInt = nil): TVec; overload;
      (*<summary>The b parameter is of double type.</summary>*)
      function FindAndGather(const a: TMtxVec; const op: string; const b: double; const Indexes: TVecInt = nil): TVec; overload;
      (*<summary>The b parameter is of <see cref="TMtxVec"/> type.</summary>*)
      function FindAndGather(const a: TMtxVec; const op: string; const b: TMtxVec; const Indexes: TVecInt = nil): TVec; overload;


      (*<summary>Gather vector elements.</summary>
        
<remarks>Gather the elements of vector X and store them to the calling vector
        according to the IndexType, Increment and Offset parameters.

        The Indexes vector is used only if IndexType is either indVector
        or indMask. If IndexType is indVector, the values from the Indexes
        vector denote the Index positions in the X vector from which
        the values should be copied to the calling vector.
        The Indexes vector must have the indexes stored in the IValues
        array. The IValues integer arrays points the same memory as Values
        array.

        The Increment and Offset parameters are used only if TIndexType
        is indIncrement. They define the initial offset and a fixed
        step (increment) between elements to be gathered. If IndexType is indMaks the Indexes vector must have the same
        size as the X vector. The routine will copy only those elements
        from the X vector to the calling vector, for which there is a 1 at the coresponding
        Index in the Indexes vector.

        The elements copied from the X vector will be stored consecutively in the calling vector.
        See the <See Method="Scatter"/> method to see how to undo the gathering.

        Note
          The performance of the CPU heavily depends on the assumption that elements are stored at consecutive memory locations.
          If it is neccessary to apply a set of operations only to elements at specific indexes, performance-wise it can
          proof to be very helpfull, if the elements are gathered first.
</remarks>


        <SeeAlso cref="FindAndGather"/>
        <SeeAlso cref="FindAndSplit"/>
        <SeeAlso cref="FindIndexes"/>
        <SeeAlso cref="Find"/>
        <SeeAlso cref="Gather"/>
        <SeeAlso cref="Scatter"/>*)
      function Gather(const X: TMtxVec; const Indexes: TVecInt =nil; IndexType: TIndexType = indVector; Increment: integer = 1; Offset: integer = 0): TVec; overload;


      (*<summary>Gather vector elements.</summary>
        
<remarks>Gather the elements of vector X at indices defined with Increment*i + Offset
        and store them to the calling vector.
</remarks>
*)
      function GatherByIncr (const X: TMtxVec; Increment: integer = 1; Offset: integer = 0): TVec; overload;
      (*<summary>Gather vector elements.</summary>
        
<remarks>Gather the elements of vector X at indices defined with Indexes
        and store them to the calling vector.
</remarks>
*)
      function GatherByIndex(const X: TMtxVec; const Indexes: TVecInt): TVec; overload;
      (*<summary>Gather vector elements.</summary>
        
<remarks>Gather the elements of vector X at indices defined with Mask
        and store them to the calling vector.
</remarks>
*)
      function GatherByMask (const X: TMtxVec; const Mask: TVecInt): TVec; overload;

      (*<summary>Gather a vector, split to two vectors.</summary>
        
<remarks>If the elements of a vector have been split with a Mask and
        the "positive" elements have been stored in the MaskVec and
        "negative" elements have been stored in the NotMaskVec, this
        routine will restore the original vector.

        The length of the MaskVec vector must be equal to the number
        of ones in the Mask vector. The length of the NotMaskVec vector must be equal to the number
        of zeroes in the Mask vector.
</remarks>


        <SeeAlso cref="FindAndSplit"/>*)
      function GatherSplit(const MaskVec, NotMaskVec: TMtxVec; const Mask: TVecInt): TVec; overload;

      (*<summary>Copies a column from matrix.</summary>
        
<remarks>Copies the Col-th column from Mtx matrix to calling vector. The <see cref="Length"/> and <see cref="Complex"/> properties
        of calling vector are adjusted automatically. An exception is raised if condition checking is enabled and Col is greater than
        Mtx.Cols-1.
</remarks>


        <example>
        <code>
        var a: Vector;
            b: Matrix;
        begin
            b.SetIt(2,2,False,[1,2,
                              3,4]);
            a.GetCol(b,0); // a now contains [1,3]
        end;
        </code>
        </example>
        <SeeAlso cref="GetRow"/>
        <SeeAlso cref="Matrix.SetCol"/>*)
      function GetCol(const Mtx: TMtx; aCol: integer): TVec; overload;
      (*<summary>Copy the Col-th column elements [Row]..[Row+Len-1] to calling vector elements [Index]..[Index+Len-1].</summary>
        
<remarks>The <see cref="Complex"/> property of calling vector must be set explicitly. An exception is raised if condition checking is enabled and
        column array borders are overrun.
</remarks>
*)
      function GetCol(const Mtx: TMtx; aRow, aCol, Index, Len: integer): TVec; overload;
      (*<summary>Copy the Col-th column elements [Row]..[Row+Len-1] to calling vector.</summary>
        
<remarks>The <see cref="Length"/> and <see cref="Complex"/> properties of calling vector are adjusted automatically. An exception is raised
        if condition checking is enabled and column array borders are overrun.
</remarks>
*)
      function GetCol(const Mtx: TMtx; aRow, aCol, Len: integer): TVec; overload;

      (*<summary>Copies a row from matrix.</summary>
        
<remarks>Copies the Row-th row from Mtx matrix to calling vector. The <see cref="Length"/> and <see cref="Complex"/> properties
        of calling vector are adjusted automatically. An exception is raised if condition checking is enabled and Row is greater than
        Mtx.Rows-1.
</remarks>


        <Example>
        <code>
        var a: Vector;
            b: Matrix;
        begin
            b.SetIt(2,2,False,[1,2,
                              3,4]);
            a.GetRow(b,0); // a now contains [1,2]
        end;
        </code>
        </Example>

        <SeeAlso cref="GetCol"/>
        <SeeAlso cref="Matrix.SetRow"/>*)
      function GetRow(const Mtx: TMtx; aRow: integer): TVec; overload;
      (*<summary>Copy the Row-th column elements [Col]..[Col+Len-1] to calling vector elements [Index]..[Index+Len-1].</summary>
        
<remarks>The <see cref="Complex"/> property of calling vector must be set explicitly. An exception is raised if condition checking is enabled and
        column array borders are overrun.
</remarks>
*)
      function GetRow(const Mtx: TMtx; aRow, aCol, Index, Len: integer): TVec; overload;
      (*<summary>Copy the Row-th column elements [Col]..[Col+Len-1] to calling vector.</summary>
        
<remarks>The <see cref="Length"/> and <see cref="Complex"/> properties of calling vector are adjusted automatically.
        An exception is raised if condition checking is enabled and column array borders are overrun.
</remarks>
*)
      function GetRow(const Mtx: TMtx; aRow, aCol, Len: integer): TVec; overload;

      (*<summary>The fast hilbert transform (FFT based).</summary>
        
<remarks>The method forms the imaginary orthogonal part (90 degrees phase shifted version of the original)
        from the real series by using the fast hilbert transform (FFT based) and saves the complex result in the
        calling vector. No windowing is performed. Vec must be a real vector or an exception is raised.
        The <see cref="Length"/> and <see cref="Complex"/> properties of the calling vector are set
        implicitly to match Vec vector.
</remarks>


        <Example>
        <code>
        var a,b,Re,Im: Vector;
            azero: double;
        begin
            a.SetIt(false,[1,2,3,4,5,6,7,8]);
            b.Hilbert(a);
            Re.RealPart(b);
            Im.ImagPart(b);
            azero := DotProd(Re,Im);
            // if Re is orthogonal to Im, azero becomes 0
        end;
        </code>
        </Example>

        <SeeAlso cref="FFT"/>
        <SeeAlso cref="DCT"/>*)
      function Hilbert(const Vec: TVec; method: THilbertMethod = hmMethod1): TVec; overload;

      (*<summary>The inverse discrete cosine transform (DCT).</summary>
        
<remarks>Calculates the inverse discrete cosine transform (DCT) of a Vec and writes the results in the calling vector.
        If Vec <see cref="Length"/> is a power of 2, the function uses an efficient algorithm that is significantly
        faster than the direct computation of DCT. For other values of Vec length, this function uses the direct
        formulas given below; however, the symmetry of cosine function is taken into account, which allows to
        perform about half of the multiplication operations in the formulas. In the following definition of inverse
        DCT, N=Vec.Length and V is the calling vector:

        <IMG name="TVec20"/>
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            a.SetIt(False,[1,-2,3,4]);
            b.IDCT(a);
        end;
        </code>
        </Example>

        <SeeAlso cref="DCT"/>*)
      function IDCT(const Vec: TVec): TVec; overload;
      (*<summary>Calculate the inverse DCT in-pllace.</summary>
        
<remarks>The length of the calling vector is adjusted automatically.
</remarks>
*)
      function IDCT: TVec; overload;

      (*<summary>The inverse backward FFT from complex to complex.</summary>
       
<remarks>Calculates the inverse (backward) Fast Fourier Transformation (FFT) from complex to complex for all
       calling vector elements in-place. If the NoScale parameter is true, then no scaling is performed for
       the calling vector. The results can be erroneous if overflow or underflow occurs.
</remarks>


       <Example>
       <code>
       var a,b: Vector;
       begin
          a.SetIt(True,[1,2,3,4]);
          b.IFFT(a,True);
       end;
       </code>
       </Example>

       <SeeAlso cref="FFT"/>
       <SeeAlso cref="TDenseMtxVec.FFT"/>*)
      function IFFT(NoScale: boolean = False): TVec; overload;
      (*<summary>Calculate the inverse FFT from all Vec elements and store the results in the calling vector.</summary>
        
<remarks>If the NoScale parameter is true then no scaling is performed for the calling vector.
        Vec <see cref="Length"/> must not be the power of two. <see cref="Length"/> and <see cref="Complex"/>
        properties of the calling vector are set implicitly to match Vec vector.
</remarks>
*)
      function IFFT(const Vec: TVec; NoScale: boolean = False): TVec; overload;

      (*<summary>The inverse FFT from complex to real.</summary>
        
<remarks>Calculates the inverse Fast Fourier Transformation (FFT) from
        complex to real from all calling vector elements.
        The result is a real type vector.

        Input vector must be a complex vector or an exception is raised.
        If the NoScale parameter is true then no scaling is performed for
        the calling vector. The results can be erroneous if overflow or
        underflow occurs.

        <b>In-place fsfCCS complication</b>

        When <see cref="FFTStorageFormat"/> is equal to fsfCCS the
        Length of the result will be equal to Length-2, because the source
        data is bigger than the result data by 2 real samples,
        if <see cref="FFTOddLength"/> is false.
        If <see cref= "FFTOddLength"/> is True
        the result will fill up Length-1 samples.
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin //Even
            a.SetIt(True,[1,2,3,4]);
            b.FFTFromReal(a); // b = [(10, 0),( -2,2), (-2, 0)]
            b.IFFTToReal;     // b = [1, 2, 3, 4, -2, 0)]

            //Odd length
            a.SetIt(True,[1,2,3,0]);

            b.FFTOddLength := True; //use only Length-1 samples
            b.FFTFromReal(a); // b = [(6,0),( -1.5,0.8660)] //result requires 2 complex (= 4 real numbers)
            b.IFFTToReal;      //b = [1, 2, 3, 0.8660]

            //Event length
            a.SetIt(True,[1,2,3,4, 0,0]); //allocate two more elements
            a.FFTOddLength := false; //use only Length-2 samples
            a.FFTFromReal; // a = [(10, 0),( -2,2), (-2, 0)] //result requires 3 complex (= 6 real numbers)
            a.IFFToReal;   // a = [1, 2, 3, 4, -2, 0)]
        end;
        </code>
        </Example>

        <SeeAlso cref="FFTFromReal"/>
        <SeeAlso cref="TDenseMtxVec.FFTFromReal"/>
        <SeeAlso cref="IFFT"/>
        <SeeAlso cref="TDenseMtxVec.FFT"/>*)
      function IFFTToReal(NoScale: boolean = False): TVec; overload;
      (*<summary>Calculate the inverse FFT from all Vec elements.</summary>
          
<remarks>Store the results in the calling vector. Vec <see cref="Length"/> must
         not be the power of two. <see cref="Length"/> and <see cref="Complex"/>
         properties of the calling vector are set implicitly the size and type of the result.
</remarks>
*)
      function IFFTToReal(const Vec: TVec; NoScale: boolean = False): TVec; overload;

      (*<summary>Integrate calling vector values.</summary>
        
<remarks>Perform d-times integration of calling vector values, where d is equal to Init length.
</remarks>

        <param name="Init">Definies initial values for integration. Size of Init vector determines how many times calling vector
        values will be integrated.</param>*)
      function Integrate(const Init: TVec): TVec; overload;
      (*<summary>Integrate all Vec elements using initial values in Init and store the results in calling vector.</summary>
        
<remarks><see cref="Length"/> and <see cref="Complex"/>
        properties of the calling vector are set implicitly the size and type of the result.
</remarks>
*)
      function Integrate(const Vec, Init: TVec):TVec; overload;

      (*<summary>The Kronecker product between two vectors.</summary>
        
<remarks>Calculates the Kronecker product between vectors Vec1 and Vec2 and stores the results in calling vector.
</remarks>


        <Example>
        <code>
        var a,b,c: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            b.SetIt(False,[1,2,3,4]);
            c.Kron(a,b);  // c = [1,2,3,4, 2,4,6,8, 3,6,9,12, 4,8,12,16]
        end;
        </code>
        </Example>*)
      function Kron(const Vec1, Vec2: TVec): TVec; overload;

      (*<summary>The norm of a vector.</summary>
        
<remarks>Calculates the norm of a Vec vector and stores the results in calling vector.
        This functions works the same as <see cref="PowerSpectrum"/>.
</remarks>
*)
      function Norm(const Vec: TMtxVec): TMtxVec;


      (*<summary>Downsamples (reduces) the number of vector elements.</summary>
        
<remarks>This method speeds up drawing of huge amounts of data
        (>> 2000 samples). You should pass your data to the
        PixelDownSample method before you pass the values to the Charting
        routine. The X and Y vectors contain the values for X and Y axis,
        that you would normally pass to the charting procedure. The
        downsampled Y is stored in the calling vector and downsampled X is stored
        in the NX vector. If your data is equidistant on X axis,
        you can omit the X vector or, if you are in doubt, allow the routine to
        downsample the X vector also. If your data is not equidistant on the
        X axis, you must indicate that by specifying the Equidistant parameter as
        False and provide X and NX vectors, where X containes the step on the X axis
        and NX will contain the downsampled result for X axis.

        With Width parameter you specify the width of the charting
        region in pixels. (Example: Chart.Width). The routine will reduce
        the number of samples in vectors Y and X in such a way that there
        will be no visual difference between the original and downsampled data.

        That however will no longer be true, if you will zoom-in
        on the data. The performance gain can be as big as 100x depending on
        the charting tool that you use. You can easily draw data series from
        vectors with length of over 1.000.000 samples in real time.
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            a.SetIt(False,[0,0,0,1,2,3,1,2,3]);
            b.PixelDownSample(3,a);
        end;
        </code>
        </Example>

        <SeeAlso cref="DownSample"/>*)
      procedure PixelDownSample(Width: integer; Y: TVec; Index,Len: integer; X: TVec = nil; NX: TVec = nil; Equidistant: TEquidistantSample = eqsXEquidistant); overload;
      (*<summary>Downsample the vectors Y and (optionaly) X starting at position Index and for Len samples.</summary>
        
<remarks>Store result for Y in the calling vector and the result for  X in the NX vector.
        If X axis is equidistant, you can omit X and NX parameters.
        Set Width to the number of target pixels. An exception is reaised,
        if any of the vectors is complex or if array borders are
        overrun/underrun.
</remarks>
*)
      procedure PixelDownSample(Width: integer; Y: TVec; X: TVec = nil; NX: TVec = nil; Equidistant: TEquidistantSample = eqsXEquidistant); overload;

      (*<summary>Fills vector with prime numbers, starting from 2 up to the value of n.</summary>
        
<remarks>Fills calling vector with prime numbers, starting from 2 up to the value of n.
        The memory for at least n elements is allocated. The maximum value of n
        is 1000. The prime numbers are fetched from a precreated table.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.PrimeNumbers(10); // a = [2,3,5,7]
        end;
        </code>
        </Example>*)
      function PrimeNumbers(n: integer): TVec;

      (*<summary>Fills the calling vector with a series following linear rule.</summary>
        
<remarks>Fills the calling vector with a series following the rule:

        <code>Values[k] :=  k </code>

        (Offset is zero and Step is one). If the calling vector is complex,
        only the real part is set.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.Size(5,True);
            a.Ramp(0,PI);
            a.Sin;
        end;
        </code>
        which is identical to:
        <code>
          a.Size(5,True);
          for i:= 0 to a.Length-1 do a[i] := sin(i*PI);
        </code>
        </Example>

        <SeeAlso cref="SetVal"/>*)
      function Ramp: TVec; overload;
      (*<summary>Fills the calling vector with a series.</summary>
        
<remarks>Follow the rule:

        <code>CValues[k] := Offset + k*Step.
        </code>
</remarks>
*)
      function Ramp(Offset, Step: TCplx): TVec; overload;
      (*<summary>Fills the calling vector with a series.</summary>
        
<remarks>Follow the rule:

        <code>Values[k] := Offset + k*Step.
        </code>
        If the calling vector is complex, only the real part is set.
</remarks>
*)
      function Ramp(Offset, Step: double): TVec; overload;
      (*<summary>Fills the calling vector elements [Index]..[Index+Len-1] with a series.</summary>
        
<remarks>Follow the rule:

        <code>Values[k] := Offset + k*Step.
        </code>
        If the calling vector is complex, only the real part is set.
        An exception is raised if calling vector
        array borders are overrun.
</remarks>
*)
      function Ramp(Offset,Step: double; Index,Len: integer): TVec; overload;
      (*<summary>Fills the calling vector elements [Index]..[Index+Len-1] with a series.</summary>
        
<remarks>Follow the rule:

        <code>Values[k] := Offset + k*Step.
        </code>
        If the calling vector is complex, only the real part is set.
        An exception is raised if array borders of the calling vector
        are overrun.
</remarks>
*)
      function Ramp(Offset, Step: TCplx; Index,Len: integer): TVec; overload;
      (*<summary>The Offset is complex, but the step is real.</summary>*)
      function Ramp(Offset: TCplx; Step: double): TVec; overload;
      (*<summary>Fills the calling vector elements [Index]..[Index+Len-1] with a series.</summary>
        
<remarks>Follow the rule:

        <code>Values[k] := Offset + k*Step.
        </code>
        The Offset is complex, but the step is real.
</remarks>
*)
      function Ramp(Offset: TCplx; Step: double; Index,Len: integer): TVec; overload;


      (*<summary>Resizes vector size while preserving values.</summary>
        
<remarks>Resizes calling vector <see cref="Length"/> to Len and fills it with Src vector
        first Len values. If Src length is less than Len and ZeroIt parameter is true, the remaining
        calling vector values are set to zero.
</remarks>


        <Example>
        <code>
        var a, b: Vector;
        begin
            a.SetIt(false,[1,2,3]);
            b.SetIt(false,[9]);
            b.Resize(a,7,True); // b=(9,1,2,3,4,0,0,0)
        end;
        </code>
        </Example>*)
      function Resize(const Src: TMtxVec; Len: integer; ZeroIt: boolean = False): TVec; overload;
      (*<summary>Resizes calling vector <see cref="Length"/> to Len.</summary>
        
<remarks>If <see cref="Length"/> is less than Len and ZeroIt parameter is true, the remaining
        calling vector values are set to zero.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.SetIt(false,[1,2,3]);
            a.Resize(7,True); // a= [1,2,3,0,0,0,0]
        end;
        </code>
        </Example>*)
      function Resize(Len: integer; ZeroIt: boolean = False): TMtxVec; overload;

      (*<summary>Reverse vector elements.</summary>
        
<remarks>The method reverses vector elements by using the following equation:

        <IMG name="TVec24"/>

        This overload reverses all calling vector elements in-place.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            a.Reverse;   // a = [4,3,2,1]
        end;
        </code>
        </Example>

        <SeeAlso cref="Rotate"/>
        <SeeAlso cref="Shift"/>*)
      function Reverse: TVec; overload;
      (*<summary>Reverse all Vec elements.</summary>
        
<remarks>Store the result in the calling vector elements. The
        <see cref="Length"/> and <see cref="Complex"/>
        properties of the calling vector are set implicitly to match Vec vector.
</remarks>
*)
      function Reverse(const Vec: TMtxVec): TVec; overload;

      (*<summary>A cyclic shift on vector elements.</summary>
        
<remarks>Performs cyclic shift on vector elements. The number of elements to shift is specified in the Offset parameter. Offset can be
        any integer number, positive or negative.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            a.Rotate(2);   // a = [3,4,1,2]
        end;
        </code>
        </Example>

        <SeeAlso cref="Reverse"/>
        <SeeAlso cref="Shift"/>*)
      function Rotate(Offset: integer): TVec; overload;
      (*<summary>Applies cyclic shift on Src vector elements and stores the result in Self.</summary>*)
      function Rotate(const Src: TMtxVec; Offset: integer): TVec; overload;

      (*<summary>Sets vector values (double).</summary>
        
<remarks>Sets the <see cref="Length"/> property of the calling vector to (High(A)+1) and the <see cref="Complex"/>
        property to AComplex. The double elements of A array are copied to the calling vector. If AComplex is True then real
        parts of complex numbers are on even (0,2,4..)and imaginary parts on odd indexes.(1,3,5,..)

        Note
          Use this method for setting a double array only.
</remarks>


        <SeeAlso cref="SetIt"/>
        <SeeAlso cref="SetInteger"/>
        <SeeAlso cref="SetCplx"/>
        <SeeAlso cref="SetSingle"/>*)
      function SetDouble(AComplex: boolean; const A: array of double): TVec; overload;

      (*<summary>Sets vector values (integer).</summary>
        
<remarks>Sets the <see cref="Length"/> property of the calling vector to (High(A)+1) and the <see cref="Complex"/>
        property to AComplex. The integer elements of A array are copied to the calling vector. If AComplex is True then real
        parts of complex numbers are on even (0,2,4..)and imaginary parts on odd indexes.(1,3,5,..)

        Note
          Use this method for integer array only.
</remarks>


        <SeeAlso cref="SetIt"/>
        <SeeAlso cref="SetDouble"/>
        <SeeAlso cref="SetCplx"/>
        <SeeAlso cref="SetSingle"/>*)
      function SetInteger(AComplex: boolean;const A: array of Integer): TVec; overload;
      (*<summary>Sets vector values (single).</summary>
        
<remarks>Sets the <see cref="Length"/> property of the calling vector to (High(A)+1) and the <see cref="Complex"/>
        property to AComplex. The single elements of A array are copied to the calling vector. If AComplex is True then real
        parts of complex numbers are on even (0,2,4..)and imaginary parts on odd indexes.(1,3,5,..)

        Note
          Use this method for single array only.
</remarks>


        <SeeAlso cref="SetIt"/>
        <SeeAlso cref="SetDouble"/>
        <SeeAlso cref="SetInteger"/>
        <SeeAlso cref="SetCplx"/>*)
      function SetSingle(AComplex: boolean; const A: array of single): TVec; overload;

      (*<summary>Sets vector values.</summary>
        
<remarks>SetIt makes the use of open array construction, to set the values of the calling vector. It gives you the
        possibility to pass large arrays of elements without having to declare constant arrays.

        Sets the <see cref="Length"/> property of the calling vector to (High(A)+1) and the <see cref="Complex"/>
        property to AComplex. The elements of A array are copied to the calling vector. If AComplex is True then real
        parts of complex numbers are on even (0,2,4..)and imaginary parts on odd indexes.(1,3,5,..)
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.SetIt(False,[1,2,3,4]); // a = [1,2,3,4]
        end;
        </code>
        </Example>

        <SeeAlso cref="SetCplx"/>
        <SeeAlso cref="SetDouble"/>
        <SeeAlso cref="SetSingle"/>
        <SeeAlso cref="SetInteger"/>*)
      function SetIt(AComplex: boolean;const A: array of double): TVec; overload;
      (*<summary>Does not change the <see cref="Length"/> or <see cref="Complex"/> properties of the calling vector.</summary>
        
<remarks>It does check for array overrun. The elements of A array are copied to the calling vector, starting at Index 0.
        If the calling vector is complex then real parts of complex numbers are on even (0,2,4..)and imaginary parts on
        odd indexes.(1,3,5,..)
</remarks>
*)
      function SetIt(const A: array of double): TVec; overload;

      (*<summary>Sets vector values (complex).</summary>
        
<remarks>Sets the <see cref="Length"/> property of the calling vector to (High(A)+1) and the <see cref="Complex"/>
        property to true. The complex elements of A array are copied to the calling vector CValues.

        Note
          Use this method for complex array only.
</remarks>


        <SeeAlso cref="SetIt"/>
        <SeeAlso cref="SetDouble"/>
        <SeeAlso cref="SetInteger"/>
        <SeeAlso cref="SetSingle"/>*)
      function SetCplx(const a: array of TCplx): TVec;

      (*<summary>Defines a sub-vector.</summary>
        
<remarks>Define a subvector of the Src vector starting at BeginIndex and ending at EndIndex (inclusive).
</remarks>

        <SeeAlso cref="SetSubRange"/>
        <SeeAlso cref="SetFullRange"/>*)
      procedure SetSubIndex(const Src: TMtxVec; BeginIndex, EndIndex: integer); overload;

      (*<summary>Defines the calling vector to have the view of the same memory as Src.</summary>
         
<remarks>Src vector's Length property may not change while any other object has it's own view of it.

         <c>a.SetSubRange(b,..);</c>

         This SetSubRange method is to be handled with greater care. Namely:
         * b can be freed before "a" and accessing "a" gives AV.
         * a can be further subranged with c and same problem
           occurs when b is freed before c.
         * If you resize b, all objects which have subranged b
           are no longer pointing to valid memory.
         * b can Subrange other objects. Similar problem as when changing the size of b.
           Again all objects which have subranged b are not longer pointing to valid memory.

         All this can lead to hard to find bugs.
</remarks>


        <SeeAlso cref="SetSubRange"/>
        <SeeAlso cref="SetFullRange"/>*)
      procedure SetSubRange(const Src: TMtxVec); overload;
      (*<summary>Define a subvector of the Src vector starting at Index and ending at Index+Len-1.</summary>*)
      procedure SetSubRange(const Src: TMtxVec; Index: integer; Len: integer = MtxVecEOA); overload; 
      (*<summary>Define a subvector of the Src vector starting at Index and ending at Index+Len-1.</summary>
                 
<remarks>Additionally, it  pushes the previous subrange on to a stack, which can be poped by calling
                 SetFullRangeLevel.
</remarks>
*)
      procedure SetSubRangeLevel(const Src: TMtxVec; Index: integer; Len: integer = MtxVecEOA); overload; 

      (*<summary>Shift vector elements.</summary>
        
<remarks>Shifts calling vector elements. The number of elements to shift is specified in the Offset parameter.
        Offset can be any integer number, positive or negative.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.SetIt(False,[1,-2,3,0]);
            a.Shift(1); // a = 1,1,-2,3
        end;
        </code>
        </Example>

        <SeeAlso cref="Rotate"/>*)
      function Shift(Offset: integer): TVec; overload;
      (*<summary>Shift vector elements left or right in the array.</summary>
        
<remarks>Shifts Src vector elements and stores the result in the calling object.
        The number of elements to shift is specified in the Offset parameter.
        Offset can be any integer number, positive or negative.
</remarks>


        <SeeAlso cref="Rotate"/>*)
      function Shift(const Src: TMtxVec; Offset: integer): TVec; overload;

      (*<summary>Sets the size of the vector to match an array.</summary>
        
<remarks>Sets the Length of the calling vector to match the length of the array.
        The <see cref="Complex"/> is set to True.
</remarks>
*)
      procedure SizeFromArray(const Src: TCplxArray); overload;
      (*<summary>Sets the size of the vector to match an array.</summary>
        
<remarks>Sets the Length of the calling vector to match the length of the array.
        The <see cref="Complex"/> is set to false.
</remarks>
*)
      procedure SizeFromArray(const Src: TDoubleArray); overload;
      (*<summary>Sets the size of the vector to match an array.</summary>
        
<remarks>Sets the Length of the calling vector to match the length of the array.
        The <see cref="Complex"/> is set to false.
</remarks>
*)
      procedure SizeFromArray(const Src: TSingleArray); overload;
      (*<summary>Sets the size of the vector to match an array.</summary>
        
<remarks>Sets the Length of the calling vector to match the length of the array.
        The <see cref="Complex"/> is set to false.
</remarks>
*)
      procedure SizeFromArray(const Src: TIntegerArray); overload;
      (*<summary>Sets the size of the vector to match an array.</summary>
        
<remarks>Sets the Length of the calling vector to match the length of the array.
        The <see cref="Complex"/> is set to false.
</remarks>
*)
      procedure SizeFromArray(const Src: TSmallIntArray); overload;
      (*<summary>Sets the size of the vector to match an array.</summary>
        
<remarks>Sets the size (Length) of the calling vector to match the length of the array.
        The <see cref="Complex"/> is set to false.
</remarks>
*)
      procedure SizeFromArray(const Src: Math387.TByteArray); overload;

      (*<summary>Sets the following properties:</summary>
        
<remarks><code>
        Vec.Length := ALength;
        Vec.Complex := false;
        </code>
</remarks>
*)
      function Size(const ALength: integer; const aFloatPrecision: TMtxFloatPrecision): TVec ; overload; 
      function Size(const ALength: integer; const aFloatPrecisionRef: TMtxVec): TVec ; overload; 

      
      function Size(const ALength: integer): TVec ; overload;
      

      (*<summary>Sorts vector elements in ascending order.</summary>
        
<remarks>Sort all calling vector elements.

        Note
          If the vector is complex, the complex values are first compared by the absolute value and
          then (if absolute value is equal) by the argument.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
          a.SetIt(True,[2,1,3,4]);
          a.SortAscend; // a = [1,2,3,4]
        end;
        </code>
        </Example>

        <SeeAlso cref="SortDescend"/>*)
      function SortAscend: TVec; overload;
      (*<summary>Sort calling vector elements [Index]..[Index+Len-1].</summary>
        
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
      function SortAscend(Index,Len: integer): TVec; overload;
      (*<summary>Sort calling vector elements [Index]..[Index+Len-1].</summary>
        
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
        IndexVec contains the new order of elements. The order is stored in an array of integers
        which are accessible via the IValues property.
</remarks>
*)
      function SortAscend(Index,Len: integer; const IndexVec: TVecInt): TVec; overload;
      (*<summary>Sort all calling vector elements. IndexVec contains the new (zero based)
         order of elements.</summary>
         
<remarks>The order is stored in an array of integers
         which are accessible via the IValues property.
</remarks>
*)
      function SortAscend(const IndexVec: TVecInt): TVec; overload;

      (*<summary>Sorts vector elements in descending order.</summary>
        
<remarks>Sort all calling vector elements in descending order.

        Note
          If the vector is complex, the complex values are first compared by the absolute value and
          then by the argument.
</remarks>


        <Example>
        <code>
        var a: Vector;
        begin
            a.SetIt(True,[2,1,3,4]);
            a.SortDescend; // a = [4,3,2,1]
        </code>
        </Example>

        <SeeAlso cref="SortAscend"/>*)
      function SortDescend: TVec; overload;
      (*<summary>Sort calling vector elements [Index]..[Index+Len-1].</summary>
        
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
      function SortDescend(Index,Len: integer): TVec; overload;
      (*<summary>Sort calling vector elements [Index]..[Index+Len-1].</summary>
        
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
        IndexVec contains the new order of elements.
</remarks>
*)
      function SortDescend(Index,Len: integer; const IndexVec: TVecInt): TVec; overload;
      (*<summary>Sort all calling vector elements. IndexVec contains contains the new order of elements.</summary>*)
      function SortDescend(const IndexVec: TVecInt): TVec; overload;

      (*<summary>Splits the calling vector to an array of TVec objects.</summary>
        
<remarks>Copy the contents of the calling TVec object to the TVec objects in Dst array.
        The <see cref="Length"/> and <see cref="Complex"/> properties of vectors in Dst array must
        be set explicitly. An exception is raised, if <see cref="Complex"/> properties
        of TVec objects do not match or the sum of TVec lengths exceeds the
        <see cref="Length"/> of the calling vector.
</remarks>


        <Example>
        <code>
        var a,b,c,d: Vector;
        begin
            a.SetIt(False,[0,0,0,0,1,2,3,1,2,3]);
            a.Split([b,c,d],[4,3,3]);
            // b = [0,0,0,0], c = [1,2,3], d = [1,2,3]
        end;
        </code>
        </Example>

        <SeeAlso cref="Concat"/>
        <SeeAlso cref="Copy"/>
        <SeeAlso cref="Resize"/>*)
      function Split(const Dst: array of TVec): TVec; overload;
      (*<summary>Copy the contents of the calling TVec object to the TVec objects in Dst array.</summary>
        
<remarks>The Length of objects in Dst array is defined in the DstSize array. The <see cref="Length"/> and
        <see cref="Complex"/>  properties of vectors in Dst array are set implicitly. An exception is raised
        if the sum of DstSize lengths exceeds the <see cref="Length"/> of the calling vector.
</remarks>
*)
      procedure Split(const Dst: array of TVec;const DstSize: array of integer); overload;
      (*<summary>Copy the contents of the calling TVec object to Vec1 and Vec2 objects.</summary>
        
<remarks>The <see cref="Length"/> and <see cref="Complex"/> properties of are set implicitly. An exception is raised, if Offset parameter
        exceeds the length of the calling vector. The <see cref="Length"/> property of Vec1 object is set to
        Offset and the Length of Vec2 is set to the rest.
</remarks>
*)
      procedure Split(const Vec1: TVec; Offset: integer; Vec2: TVec); overload;

      (*<summary>Tensor product between vector and matrix.</summary>
        
<remarks>Calculates the right tensor product between matrix and vector. The result is placed in the calling vector. Depending on the
        <see cref="TMtxType"/> the following operations are available:

        * mtSymmetric:	y = alfa*a*X + beta*y
        * mtSymmPosDef:	y = alfa*a*X + beta*y
        * mtHermitian:       	y = alfa*a*X + beta*y
        * mtHermPosDef:	y = alfa*a*X + beta*y
        * mtTriangular:       	y = op(a)*X
        * mtGeneral:         	y = alfa*op(a)*X + beta*y

        The <see cref="Alfa"/> and <see cref="Beta"/> are TVec complex public variables. Their default values are:

        <c>Alfa = Cplx(1,0)</c>
        <c>Beta = Cplx(0,0).</c>

        Note
          Each time you call TensorProd the values of Alfa and Beta are reset to default. If the matrix is not
          complex, only the real part of Alfa and Beta is used. If matrix complex and symmetric the general type is used.
</remarks>


      <Example>
      <code>
      var a,b,c,t: Matrix;
            d,e,f: Vector;
      begin
          // Test non quadratic general matrix
          a.SetIt(2,3,False,[4,3,3,
                             3,4,2]);
          e.SetIt(false,[1,2]);
          d.TensorProd(e,a);

          f.SetIt(False,[10,11,7]);
          if not f.Equal(d) then raise Exception.Create('Not same');

          // Test on triangular matrices, left
          a.TriangleForm := tfUpper;
          a.TriangleUnit := False;

          a.SetIt(2,2,False,[4,3,
                             0,4]);
          e.SetIt(false,[1,2]);
          d.TensorProd(e,a,mtTriangle);

          f.SetIt(False,[4,11]);
          if not f.Equal(d) then raise Exception.Create('Not same');

          // Test on triangular matrices, right
          a.Reset;
          a.TriangleForm := tfUpper; // data to be referenced is in upper triangle
          a.TriangleUnit := False;  // non unit diagonal
          a.SetIt(2,2,False,[4,3,
                            0,4]);
          e.SetIt(false,[1,2]);
          d.TensorProd(a,e,mtTriangle);

          f.SetIt(False,[10,8]);
          if not f.Equal(d) then raise Exception.Create('Not same');

          // Test on symmetric matrices, right
          a.Reset;
          a.TriangleForm := tfUpper;
          a.SetIt(2,2,False,[4,3,
                            3,4]);
          e.SetIt(false,[1,2]);
          d.TensorProd(e,a,mtSymmetric);

          f.SetIt(False,[10,11]);
          if not f.Equal(d) then raise Exception.Create('Not same');

          // Test on symmetric matrices, Left
          a.Reset;
          a.TriangleForm := tfUpper;
          a.SetIt(2,2,False,[4,3,
                             3,4]);
          e.SetIt(false,[1,2]);
          d.TensorProd(a,e,mtSymmetric);

          f.SetIt(False,[10,11]);
          if not f.Equal(d) then raise Exception.Create('Not same');
      end;
      </code>
      </Example>

      <SeeAlso cref="TensorProd"/>*)
      function TensorProd(const Mtx: TMtx; Vec: TVec; MtxType: TMtxType = mtGeneral; Operation: TMtxOperation = opNone): TVec; overload;
      (*<summary>Calculates the left tensor product between vector and matrix.</summary>*)
      function TensorProd(const Vec: TVec; Mtx: TMtx; MtxType: TMtxType = mtGeneral; Operation: TMtxOperation = opNone): TVec; overload;

      (*<summary>Inserts zeroes between consecutive vector values.</summary>
        
<remarks>Inserts zeroes between consecutive vector values. The method copies the values from Src to the calling vector and
        places Factor-1 zeros between consecutive values. The <see cref="Length"/> and <see cref="Complex"/>  properties of the
        calling vector are set implicitly. Phase parameter defines the initial sample offset and must be less than Factor.
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            b.SetIt(False,[0,0,1,3,2]);
            a.UpSample(b,2); // a = [0,0,0,0,1,0,3,0,2,0]
        end;
        </code>
        </Example>

        <SeeAlso cref="PixelDownSample"/>
        <SeeAlso cref="DownSample"/>
        <SeeAlso cref="UpSample"/>*)
      function UpSample(const Src: TMtxVec; Factor: integer; Phase: integer = 0): TVec; overload;

      (*<summary>Transforms vector into vector of standardized data in-place.</summary>*)
      function ZScore: TVec; overload;
      (*<summary>Transforms Src vector into vector of standardized data</summary>*)
      function ZScore(const Src: TVec): TVec; overload;

      

       (*<summary>Converts the content of the Values array of the calling vector to a list of strings.</summary>
        
<remarks>Converts all elements of the calling vector to strings with formating ReFormat for the real part and ImFormat for the imaginary part
        and stores them in aList, by using the Add method of TStringsobject. If vector is not complex only the ReFormat is used.

        Note
          Complex numbers are formated by default as: a+bi. You can have any formating by specifying the ReFormat and ImFormat
          parameters, but in order for the <See Method="StringsToValues"/> to work, the basic a+bi formating must be preserved -
          (chars '+' (' - ') and 'i' ).

        Performance note:
          This routine will be exceedingly slow, if TRichEdit.Lines or TMemo.Lines are passed as a parameter for dstList. Use TStringList or StringList types and then
          call TMemo.Lines.AddStrings(yourList) for best results.
</remarks>


        <Example>
        <code>
        procedure TForm1.Button1Click(Sender: TObject);
        var a,b: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            a.Cos;
            b.Size(a);
            b.SetVal(1);
            a := a + b; //calls a.Add(b);;

            Richedit1.Clear;
            Memo1.Clear;
            a.ValuesToStrings(Richedit1.Lines);
            b.ValuesToStrings(Richedit1.Lines);
            a.ValuesToStrings(Memo1.Lines);
            b.ValuesToStrings(Memo1.Lines);
            Memo1.Lines.SaveToFile('C:\Test.txt');
            Memo1.Lines.LoadFromFile('C:\Test.txt');
            a.StringsToValues(Memo1.Lines);
        end;
        </code>
        </Example>

        <SeeAlso cref="StringsToValues"/>*)
      function ValuesToStrings(const dstList: TStrings; const Align: TFixedTextAlign = ftaNone; const ReFormat: string = ' 0.###;-0.###'; const ImFormat: string = '+0.###i;-0.###i'; const Headers: boolean = false): integer; overload;
      (*<summary>Convert elements from Index to Index+Len-1 of the calling vector to strings with formating ReFormat for the real part and ImFormat for the imaginary part.</summary>
        
<remarks>Store them in aList starting at ListIndex. If aList is not large enough, the method will use the add method of aList object.
        If vector is not complex, only the ReFormat is used.

        Performance note:
          This routine will be exceedingly slow, if TRichEdit.Lines or TMemo.Lines are passed as a parameter for dstList. Use TStringList or StringList types and then
          call TMemo.Lines.AddStrings(yourList) for best results.
</remarks>
*)
      procedure ValuesToStrings(const dstList: TStrings; ListIndex, Index,  Len: integer; const Align: TFixedTextAlign = ftaNone; const ReFormat: string = ' 0.###;-0.###'; const ImFormat: string = '+0.###i;-0.###i'; const Headers: boolean = false); overload;

      (*<summary>Convert strings in aList to double or TCplx.</summary>
        
<remarks>Convert strings in aList to complex/real values and store
        them in the Values array of the calling vector. If any of the strings represent a complex value, then the <see cref="Complex"/> property is set
        to True and strings are converted by using the <see cref="Math387.StrToCplx"/> function. The
        <see cref="Length"/> of the calling vector is set to aList.Count.
</remarks>


        <Example>
        <code>
        var a,b: Vector;
        begin
            a.SetIt(False,[1,2,3,4]);
            a.cos;
            b.Size(a);
            b.SetVal(1);
            a := a + b; //a.Add(b);
            Richedit1.Clear;
            Memo1.Clear;
            a.ValuesToStrings(Richedit1.Lines);
            b.ValuesToStrings(Richedit1.Lines);
            a.ValuesToStrings(Memo1.Lines);
            b.ValuesToStrings(Memo1.Lines);
            Memo1.Lines.SaveToFile('C:\Test.txt');
            Memo1.Lines.LoadFromFile('C:\Test.txt');
            a.StringsToValues(Memo1.Lines);
        end;
        </code>
        </Example>

        <SeeAlso cref="ValuesToStrings"/>*)
      procedure StringsToValues(aList: TStrings); overload;
      (*<summary>Convert strings in aList to double (TCplx) starting at ListIndex.</summary>
        
<remarks>Store them in the Values array of the
        calling vector from Index to Index+Len-1. If strings represent complex numbers, then the complex property must be
        True or an exception is raised. The Length property of the calling vector is not changed. If array bounds are
        overrun and exception is raised.
</remarks>
*)
      function StringsToValues(aList: TStrings; ListIndex: integer; Index: integer = 0; Len: integer = MtxVecEOA): TVec; overload;

  end;
  

  
  (*<summary>Matrix class for operator overloading in D2006 and later.</summary>
    
<remarks>Declare Matrix instead of TMtx to take advantage of
    operator overloading in D2006 and later. Be carefull to declare
    Matrix only for local variables with short lifetime.
    Call the Create method for Matrix, if the variable is
    a global variable or a variable with a longer life.
    It also makes sense to continue to use TMtx for global vars.
    If the Create method (constuctor) is not called, the Matrix
    record obtains TMtx object from object cache (fast create).
    If the Create mehod is called, the TMtx object is created (slower)
    for use by Matrix record. Object cache has limited size.

    Note
      Calling the Create method (constructor) is not mandatory.
</remarks>
*)
  Matrix = record 
  strict private
     
    FData: TMtx;

    

    
  private
    function get_Data: TMtx ;
    property Data: TMtx read get_Data;
  
    function get_FloatPrecision: TMtxFloatPrecision;
    procedure set_FloatPrecision(const value: TMtxFloatPrecision);
    function get_IsDouble: boolean;
    procedure set_IsDouble(const value: boolean);
    function get_Capacity: Int64;
    procedure set_Capacity(const value: Int64);
    function get_CapacityStep: double;
    procedure set_CapacityStep(const value: double);
    function get_First: double;
    function get_Firstc: TCplx;
    function get_Precision: TPrecision;
    function get_Rounding: TRounding;
    function get_BlockEnd: boolean;
    function get_ComplexValues: string;
    function get_RealValues: string;
    procedure set_Precision(const value: TPrecision);
    procedure set_Rounding(const value: TRounding);
    procedure set_Alfa(const value: TCplx);
    procedure set_Beta(const value: TCplx);
    function get_Alfa: TCplx;
    function get_Beta: TCplx;
    procedure set_ZeroTolerance(const value: double);
    function get_IsSubRange: boolean;
    function get_SubRangeLevel: integer;
    function get_ZeroTolerance: double;
    function get_Caption: string;
    function get_Complex: boolean;
    function get_ConditionCheck: boolean;
    function get_Length: integer;
    function get_Tag: integer;
    procedure set_Caption(const value: string);
    procedure set_Complex(const value: boolean);
    procedure set_ConditionCheck(const value: boolean);
    procedure set_Tag(const value: integer);
    procedure set_Cols(const value: integer);
    procedure set_Rows(const value: integer);
    function get_Cols: integer;
    function get_Rows: integer;
    function get_AutoMtxType: boolean;
    function get_Balance: TBalanceType;
    function get_ConditionNumber: TConditionNumber;
    function get_FFTOddLength: boolean;
    function get_FFTScrambledOrder: boolean;
    function get_FFTStorageFormat: TFFTStorageFormat;
    function get_LeadingCols: integer;
    function get_RefineSolution: boolean;
    function get_SubDiag: integer;
    function get_SuperDiag: integer;
    function get_TriangleForm: TTriangleForm;
    function get_TriangleUnit: boolean;
    procedure set_AutoMtxType(const value: boolean);
    procedure set_Balance(const value: TBalanceType);
    procedure set_ConditionNumber(const value: TConditionNumber);
    procedure set_FFTOddLength(const value: boolean);
    procedure set_FFTScrambledOrder(const value: boolean);
    procedure set_FFTStorageFormat(const value: TFFTStorageFormat);
    procedure set_LeadingCols(const value: integer);
    procedure set_RefineSolution(const value: boolean);
    procedure set_SubDiag(const value: integer);
    procedure set_SuperDiag(const value: integer);
    procedure set_TriangleForm(const value: TTriangleForm);
    procedure set_TriangleUnit(const value: boolean);
    function get_Last: double;
    function get_Lastc: TCplx;
    function get_BackError: double;
    function get_ConditionNr: double;
    function get_ForwError: double;
    function get_Info: integer;
    function get_MtxError: string;
    function get_Quadratic: boolean;
    
    function get_CValues(const RowIdx, ColIdx: integer): TCplx; 
    function get_Values(const RowIdx, ColIdx: integer): double; 
    procedure set_CValues(const RowIdx, ColIdx: integer; const Value: TCplx); 
    procedure set_Values(const RowIdx, ColIdx: integer; const Value: double); 

    function get_CValues1D(const Idx: integer): TCplx; 
    function get_Values1D(const Idx: integer): double; 
    procedure set_CValues1D(const Idx: integer; const Value: TCplx); 
    procedure set_Values1D(const Idx: integer; const Value: double); 


    function get_SCValues(const RowIdx, ColIdx: integer): TSCplx; 
    function get_SCValues1D(const Idx: integer): TSCplx; 
    function get_SValues(const RowIdx, ColIdx: integer): single; 
    function get_SValues1D(const Idx: integer): single; 
    procedure set_SCValues(const RowIdx, ColIdx: integer; const Value: TSCplx); 
    procedure set_SCValues1D(const Idx: integer; const Value: TSCplx); 
    procedure set_SValues(const RowIdx, ColIdx: integer; const Value: single); 
    procedure set_SValues1D(const Idx: integer; const Value: single); 

    function GetSelect(const Indx, Len: integer): Vector;  
    procedure SetSelect(const Indx, Len: integer; const Value: Vector); 

    function GetSelectIndex(const startIndex, Step, stopIndex: integer): Vector;
    procedure SetSelectIndex(const startIndex, Step, stopIndex: integer; const Value: Vector);

    function GetSelect2D(const RowIdx, ColIdx, RowLen, ColLen: integer): Matrix;
    function GetSelectIndex2D(const StartRowIdx, StartColIdx, StopRowIdx, StopColIdx: integer): Matrix;

    procedure SetSelect2D(const RowIdx, ColIdx, RowLen, ColLen: integer;  const Value: Matrix);
    procedure SetSelectIndex2D(const StartRowIdx, StartColIdx, StopRowIdx, StopColIdx: integer; const Value: Matrix);
    
  public
    


    
    procedure CreateFromCache(Value: boolean);  
  public
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>
               
<remarks>Size and Complex properties must also match.
</remarks>
*)
    class operator Equal(const Left, Right: Matrix): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>*)
    class operator Equal(const Left: Matrix; Right: double): Boolean;
    (*<summary>Returns true, if Left is equal to all elements in Right.</summary>*)
    class operator Equal(Left: double;const Right: Matrix): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>*)
    class operator Equal(const Left: Matrix;const Right: TCplx): Boolean;
    (*<summary>Returns true, if Left is equal to all elements in Right.</summary>*)
    class operator Equal(const Left: TCplx; const Right: Matrix): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>
               
<remarks>Size and Complex properties must also match.
</remarks>
*)
    class operator Equal(Left: TMtx; const Right: Matrix): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>
               
<remarks>Size and Complex properties must also match.
</remarks>
*)
    class operator Equal(const Left: Matrix; Right: TMtx): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>
               
<remarks>Size and Complex properties must also match.
</remarks>
*)
    class operator Equal(Left: TVec; const Right: Matrix): Boolean;
    (*<summary>Returns true, if all elements of Left are equal to Right.</summary>
               
<remarks>Size and Complex properties must also match.
</remarks>
*)
    class operator Equal(const Left: Matrix; Right: TVec): Boolean;

    (*<summary>Returns true, if any elements in Left are not equal to Right.</summary>
               
<remarks>Size or Complex properties also do not match.
</remarks>
*)
    class operator NotEqual(const Left, Right: Matrix): Boolean;
    (*<summary>Returns true, if any elements in Left are not equal to Right.</summary>
               
<remarks>Size or Complex properties also do not match.
</remarks>
*)
    class operator NotEqual(const Left: Matrix; Right: double): Boolean;
    (*<summary>Returns true, if any elements in Right are not equal to Left.</summary>*)
    class operator NotEqual(Left: double;const Right: Matrix): Boolean;
    (*<summary>Returns true, if any elements in Left are not equal to Right.</summary>*)
    class operator NotEqual(Left: Matrix;const Right: TCplx): Boolean;
    (*<summary>Returns true, if any elements in Right are not equal to Left.</summary>*)
    class operator NotEqual(const Left: TCplx;const Right: Matrix): Boolean;
    (*<summary>Returns true, if any elements in Left are not equal to Right.</summary>
               
<remarks>Size or Complex properties also do not match.
</remarks>
*)
    class operator NotEqual(Left: TMtx; const Right: Matrix): Boolean;
    (*<summary>Returns true, if any elements in Left are not equal to Right.</summary>
               
<remarks>Size or Complex properties also do not match.
</remarks>
*)
    class operator NotEqual(Left: TVec; const Right: Matrix): Boolean;
    (*<summary>Returns true, if any elements in Left are not equal to Right.</summary>
               
<remarks>Size or Complex properties also do not match.
</remarks>
*)
    class operator NotEqual(const Left: Matrix; Right: TMtx): Boolean;
    (*<summary>Returns true, if any elements in Left are not equal to Right.</summary>
               
<remarks>Size or Complex properties also do not match.
</remarks>
*)
    class operator NotEqual(const Left: Matrix; Right: TVec): Boolean;

    (*<summary>Returns true, if ALeft is less than ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are less than ARight.
</remarks>
*)
    class operator LessThan(const ALeft: Matrix; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is less than ARight. </summary>
       
<remarks>Returns true, if  ALeft is less from all elements in ARight.
</remarks>
*)
    class operator LessThan(const ALeft: TCplx; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is less than ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are less than ARight.
</remarks>
*)
    class operator LessThan(const ALeft: Matrix; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is less than ARight. </summary>
       
<remarks>Returns true, if  ALeft is less from all elements in ARight.
</remarks>
*)
    class operator LessThan(const ALeft: double; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is less than ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are less than ARight.
</remarks>
*)
    class operator LessThan(const ALeft: Matrix; const ARight: Matrix): Boolean;

    (*<summary>Returns true, if ALeft is less than ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are less than ARight.
</remarks>
*)
    class operator LessThan(const ALeft: Vector; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is less than ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are less than ARight.
</remarks>
*)
    class operator LessThan(const ALeft: Matrix; const ARight: Vector): Boolean;

    (*<summary>Returns true, if ALeft is less than or equal to ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are less than or equal to ARight.
</remarks>
*)
    class operator LessThanOrEqual(const ALeft: Matrix; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is less than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is less than or equal to all elements in ARight.
</remarks>
*)
    class operator LessThanOrEqual(const ALeft: TCplx; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is less than or equal to ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are less than or equal to ARight.
</remarks>
*)
    class operator LessThanOrEqual(const ALeft: Matrix; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is less than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is less than or equal to all elements in ARight.
</remarks>
*)
    class operator LessThanOrEqual(const ALeft: double; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is less than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is less than or equal to all elements in ARight.
</remarks>
*)
    class operator LessThanOrEqual(const ALeft: Matrix; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is less than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is less than or equal to all elements in ARight.
</remarks>
*)
    class operator LessThanOrEqual(const ALeft: Vector; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is less than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is less than or equal to all elements in ARight.
</remarks>
*)
    class operator LessThanOrEqual(const ALeft: Matrix; const ARight: Vector): Boolean;

    (*<summary>Returns true, if ALeft is greater than or equal to ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are greater than or equal to ARight.
</remarks>
*)
    class operator GreaterThanOrEqual(const ALeft: Matrix; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is greater than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than or equal to all elements in ARight.
</remarks>
*)
    class operator GreaterThanOrEqual(const ALeft: TCplx; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is greater than or equal to ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are greater than or equal to ARight.
</remarks>
*)
    class operator GreaterThanOrEqual(const ALeft: Matrix; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is greater than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than or equal to all elements in ARight.
</remarks>
*)
    class operator GreaterThanOrEqual(const ALeft: double; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is greater than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than or equal to all elements in ARight.
</remarks>
*)
    class operator GreaterThanOrEqual(const ALeft: Matrix; const ARight: Matrix): Boolean;

    (*<summary>Returns true, if ALeft is greater than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than or equal to all elements in ARight.
</remarks>
*)
    class operator GreaterThanOrEqual(const ALeft: Vector; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is greater than or equal to ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than or equal to all elements in ARight.
</remarks>
*)
    class operator GreaterThanOrEqual(const ALeft: Matrix; const ARight: Vector): Boolean;

    (*<summary>Returns true, if ALeft is greater than ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are greater than ARight.
</remarks>
*)
    class operator GreaterThan(const ALeft: Matrix; const ARight: TCplx): Boolean;
    (*<summary>Returns true, if ALeft is greater than ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than to all elements in ARight.
</remarks>
*)
    class operator GreaterThan(const ALeft: TCplx; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is greater than ARight. </summary>
       
<remarks>Returns true, if all elements in ALeft are greater than ARight.
</remarks>
*)
    class operator GreaterThan(const ALeft: Matrix; const ARight: double): Boolean;
    (*<summary>Returns true, if ALeft is greater than ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than to all elements in ARight.
</remarks>
*)
    class operator GreaterThan(const ALeft: double; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is greater than ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than to all elements in ARight.
</remarks>
*)
    class operator GreaterThan(const ALeft: Matrix; const ARight: Matrix): Boolean;

    (*<summary>Returns true, if ALeft is greater than ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than to all elements in ARight.
</remarks>
*)
    class operator GreaterThan(const ALeft: Vector; const ARight: Matrix): Boolean;
    (*<summary>Returns true, if ALeft is greater than ARight. </summary>
       
<remarks>Returns true, if ALeft is greater than to all elements in ARight.
</remarks>
*)
    class operator GreaterThan(const ALeft: Matrix; const ARight: Vector): Boolean;

    (*<summary>Adds Left to Right and returns result. </summary>*)
    class operator Add(const Left: TCplx; const Right: Matrix): Matrix;
    (*<summary>Adds Left to Right and returns result. </summary>*)
    class operator Add(const Left: Matrix; const Right: TCplx): Matrix;

    (*<summary>Adds Left to Right and returns result. </summary>*)
    class operator Add(Left: double;const Right: Matrix): Matrix;
    (*<summary>Adds Left to Right and returns result. </summary>*)
    class operator Add(const Left: Matrix; Right: double): Matrix;

    (*<summary>Adds Left to Right and returns result. </summary>*)
    class operator Add(Left: TMtxVec;const Right: Matrix): Matrix;
    (*<summary>Adds Left to Right and returns result. </summary>*)
    class operator Add(const Left: Matrix; Right: TMtxVec): Matrix;
    (*<summary>Adds Left to Right and returns result. </summary>*)
    class operator Add(const Left: Matrix;const Right: Matrix): Matrix;

    (*<summary>Subtracts Right from Left and returns result. </summary>*)
    class operator Subtract(const Left: TCplx;   const Right: Matrix): Matrix;
    (*<summary>Subtracts Right from Left and returns result. </summary>*)
    class operator Subtract(const Left: Matrix; const Right: TCplx): Matrix;

    (*<summary>Subtracts Right from Left and returns result. </summary>*)
    class operator Subtract(Left: double; const Right: Matrix): Matrix;
    (*<summary>Subtracts Right from Left and returns result. </summary>*)
    class operator Subtract(const Left: Matrix; Right: double): Matrix;

    (*<summary>Subtracts Right from Left and returns result. </summary>*)
    class operator Subtract(const Left: Matrix; Right: TMtxVec): Matrix;
    (*<summary>Subtracts Right from Left and returns result. </summary>*)
    class operator Subtract(Left: TMtxVec; const Right: Matrix): Matrix;
    (*<summary>Subtracts Right from Left and returns result. </summary>*)
    class operator Subtract(const Left: Matrix;const Right: Matrix): Matrix;
    (*<summary>Multiplies Left with Right and returns result. </summary>*)
    class operator Multiply(const Left: Matrix; const Right: TCplx): Matrix;
    (*<summary>Multiplies Left with Right and returns result. </summary>*)
    class operator Multiply(const Left: TCplx; const Right: Matrix): Matrix;

    (*<summary>Multiplies Left with Right and returns result. </summary>*)
    class operator Multiply(const Left: Matrix; Right: double): Matrix;
    (*<summary>Multiplies Left with Right and returns result. </summary>*)
    class operator Multiply(Left: double; const Right: Matrix): Matrix;
    (*<summary>Multiplies Left with Right and returns result. </summary>*)
    class operator Multiply(const Left: Matrix; const Right: TMtxVec): Matrix;
    (*<summary>Multiplies Left with Right and returns result. </summary>*)
    class operator Multiply(const Left: TMtxVec; const Right: Matrix): Matrix;

    (*<summary>Multiplies Left with Right and returns result. </summary>*)       
    class operator Multiply(const Left: Matrix; const Right: Vector): Matrix;    
    (*<summary>Multiplies Left with Right and returns result. </summary>*)       
    class operator Multiply(const Left: Vector; const Right: Matrix): Matrix;

    (*<summary>Multiplies Left with Right and returns result. </summary>*)
    class operator Multiply(const Left: Matrix; const Right: Matrix): Matrix;

    (*<summary>Dividies Left with Right and returns result. </summary>*)
    class operator Divide(const Left: Matrix; const Right: TCplx): Matrix;
    (*<summary>Dividies Left with Right and returns result. </summary>*)
    class operator Divide(const Left: TCplx; const Right: Matrix): Matrix;

    (*<summary>Dividies Left with Right and returns result. </summary>*)
    class operator Divide(const Left: Matrix; Right: double): Matrix;
    (*<summary>Dividies Left with Right and returns result. </summary>*)
    class operator Divide(Left: double; const Right: Matrix): Matrix;

    (*<summary>Dividies Left with Right and returns result. </summary>*)
    class operator Divide(const Left: Matrix; Right: TMtxVec): Matrix;
    (*<summary>Dividies Left with Right and returns result. </summary>*)
    class operator Divide(Left: TMtxVec; const Right: Matrix): Matrix;
    (*<summary>Dividies Left with Right and returns result. </summary>*)
    class operator Divide(const Left: Matrix; const  Right: Matrix): Matrix;

    (*<summary>Negates AValue and returns result. </summary>*)
    class operator Negative(const AValue: Matrix): Matrix;

    (*<summary>Copies data in AValue to T2DCxplArray and returns result. </summary>*)
    class operator Explicit(const AValue: Matrix): T2DCplxArray;
    (*<summary>Copies data in AValue to T2DDoubleArray and returns result. </summary>*)
    class operator Explicit(const AValue: Matrix): T2DDoubleArray;

    (*<summary>Copies data in AValue to T2DCxplArray and returns result. </summary>*)
    class operator Explicit(const AValue: T2DCplxArray): Matrix;
    (*<summary>Copies data in AValue to T2DDoubleArray and returns result. </summary>*)
    class operator Explicit(const AValue: T2DDoubleArray): Matrix;

    (*<summary>Copies Matrix data to VectorInt.</summary>
              
<remarks>Copies all values from AValue to the result.
</remarks>
*)
    class operator Explicit(const AValue: Matrix): VectorInt;

    (*<summary>Dereferences internal TMtx objects and returns a pointer.</summary>*)
    class operator Implicit(const AValue: Matrix): TMtx; overload;  
    (*<summary>Dereferences internal TMtx objects and returns a pointer.</summary>*)
    class operator Implicit(const AValue: Matrix): TMtxVec; overload; 
    (*<summary>Dereferences internal TMtx objects and returns a pointer.</summary>*)
    class operator Implicit(const AValue: Matrix): TDenseMtxVec; overload; 
    (*<summary>Dereferences internal TMtx objects and returns a pointer.</summary>*)
    class operator Implicit(const AValue: Matrix): TMtxVecBase; overload; 
    (*<summary>Dereferences internal TMtx objects and returns a pointer.</summary>*)
    
    class operator Implicit(const AValue: Matrix): TObject;  overload; 
    

    (*<summary>Copies data in AValue to TSingleArray and returns result. </summary>*)
    class operator Explicit(const AValue: Matrix): TSingleArray;
    (*<summary>Copies data in AValue to TDoubleArray and returns result. </summary>*)
    class operator Explicit(const AValue: Matrix): TDoubleArray;

    
    (*<summary>Copies data in AValue to TCplxArray and returns result. </summary>
      
<remarks>Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): TCplxArray;

    (*<summary>Implicit type conversion from Matrix to PCplx.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Matrix.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): PPCplx;

    (*<summary>Copies data in AValue to TDoubleArray and returns result. </summary>
      
<remarks>Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): TDoubleArray;

    (*<summary>Implicit type conversion from Matrix to an array of double.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Matrix.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): PPDouble;

    (*<summary>Copies data in AValue to TCplxArray and returns result. </summary>
      
<remarks>Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): TSCplxArray;

    (*<summary>Implicit type conversion from Matrix to PSCplx.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Matrix.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): PPSCplx;

    (*<summary>Copies data in AValue to TDoubleArray and returns result. </summary>
      
<remarks>Not thread safe for subranged objects, because it temporarily modifies negative Index of the array for RefCount purposes.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): TSingleArray;

    (*<summary>Implicit type conversion from Matrix to PSingle.</summary>
      
<remarks>Returns a pointer to the internal array of values. If the Precision does not match an exception will be raised.
      This conversion avoids all range checking, which would be broken, if Matrix.IsSubRange = True.
</remarks>
*)
    class operator Implicit(const AValue: Matrix): PPSingle;

    

    

    (*<summary>Adopts TMtx object.</summary>
      
<remarks>Src object will be adopted by Matrix. When the Matrix gets out of scope, the object
      will be freed.
</remarks>
*)
    procedure Adopt(const Src: TMtx); overload;

    
    (*<summary>Adopts a pointer to one dimensional array.</summary>
      
<remarks>Addopts a pointer to AArray array. The method sets the calling matrix <see cref="TMtxVec.Complex" text="FlaotPrecision"/> property to aFloatPrecision,
      <see cref="Rows"/> to ARows, <see cref="Cols"/> to ACols and Values1D and CValues1D to Pointer(AArray).

      Notes:
        * Required to call the <see cref="Disown"/> method, before freeing the object
        * Do not resize the matrix
        * Do not call routines relying on Lapack when cross-platform "Core edition" is used (not linking dlls), because
          pascal version of Lapack will assume that adopted memory is a dynamic array and will modify array Index -2.
        * TMtx.Values1D array assignment or passing array by var (internal to library) will cause memory corruption in this case.
        * To be used with great care only.
</remarks>


      <SeeAlso cref="Disown"/>*)
    procedure Adopt(AArray: PAPointer; ARows, ACols: integer; aIsComplex: boolean; aIsDouble: boolean); overload;
    procedure Adopt(AArray: PAPointer; ARows, ACols: integer; aFloatPrecision: TMtxFloatPrecision); overload;
    

    (*<summary>Disowns a pointer to an array from matrix Values1D.</summary>
      
<remarks>The method does the opposite of the <see cref="Adopt"/> method. It will set the AArrays to Pointer(Values),
      ARows and ACols to matrix's <see cref="Rows"/> and <see cref="Cols"/> and IsComplex to matrix
      <see cref="TMtxVec.Complex">Complex</see> property. Use the Disown method to "disconnect" AArray from the TMtx.Values1D.
      Disown sets Values1D and CValues1D array pointers to nil and Rows, Cols properties to ACols, but without freeing
      the allocated memory. The allocated memory can be disowned only, if it was adopted with a call to the
      <see cref="Adopt"/> method.
</remarks>


      <SeeAlso cref="Adopt"/>*)
    
    procedure Disown(out AArray: PAPointer; out ARows, ACols: integer; out aIsComplex: boolean; out aIsDouble: boolean); overload;
    procedure Disown(out AArray: PAPointer; out ARows, ACols: integer; out aFloatPrecision: TMtxFloatPrecision); overload;
    

    (*<summary>Disowns a pointer to an array from calling matrix Values1D.</summary>
      
<remarks>It dismisses the Values, Values1D, CValues1D array and
      sets the <see cref="Rows"/> and <see cref="Cols"/> to zero.
</remarks>
*)
    procedure Disown;  overload;


    (*<summary>Uses Src object as internal storage.</summary>
                
<remarks>The resulting Matrix will own Src object of TMtx type and will release it once Matrix gets out of scope.
</remarks>
*)
    constructor Create(const Src: TMtx); overload;
    (*<summary>Internally creates TMtx object without using object cache.</summary>
                
<remarks>Creates TMtx object without using object cache. Suitable for declaring global variables.
                To obtain Matrix type with storage from object cache, do not call the constructor, but simply
                declare the var.
</remarks>
*)
    constructor Create(const aRows, aCols: integer; const aIsComplex: boolean; const aIsDouble: boolean); overload;
   public
     (*<summary>Enables/disable inline condition checking.</summary>
      
<remarks>Enables/disables inline condition checking. When true, TVec methods perform additional (range)
      checking before operations are executed. The drawback is slight loss of speed. If ConditionCheck is
      set to false then no additional checking is performed. This speeds up the execution but disables some
      safeguards. For short vectors the loss of speed can be significant. The more parameters
      the method requires the more error checking is performed. Some methods (parameterless) don't use the ConditionCheck property at all.
      ConditionCheck property is initially True. This property is an additional safeguard against array overrun or underrun errors.
      It allows you to work with explicit range checking while writing and debugging the application and once your code is running you
      can turn it off. By functionality it is similar to assertions. (See Assert procedure). You can also use compiler
      directives to check, if assertions are on and then set ConditionCheck to True.
</remarks>


      <SeeAlso cref="CondEnable"/>
      <SeeAlso cref="CondDisable"/>*)
    property ConditionCheck: boolean read get_ConditionCheck write set_ConditionCheck;

     (*<summary>Object caption.</summary>
      
<remarks>Use this property to set/get the object string caption.
      This can be usefull for associating description with data when making
      a user interface.
</remarks>
*)
    property Caption: string read get_Caption write set_Caption;

    (*<summary>Stores an integer value as a part of Matrix object.</summary>
      
<remarks>Stores an integer value as a part of Matrix object. Tag has no predefined meaning.
      The Tag property is provided for the convenience of developers. It can be used for storing an additional
      integer value or it can be typecast to any 32-bit value such as a component reference or even Object pointer.
</remarks>
*)
    property Tag: integer read get_Tag write set_Tag;

    (*<summary>Defines if object values are complex.</summary>
      
<remarks>If true, <see cref="Matrix"/> will treat it's elements as complex numbers. Two successive number in the values array be treated as real and imaginary
      part of the complex number. When property is false, object will treat it's elements as real numbers. You should always set the value of
      the Complex property before setting object size (<see cref="Length"/> for vector or <see cref="Rows"/>,<see cref="Cols"/> for matrix).
      Setting Complex from true to false does not cause memory reallocation. It simply doubles the value of the Length property. Setting Complex from false to true
      halves the vector length or number of matrix columns, but retains all data.  Complex property is initially false.
</remarks>


      <Example>
      <code>
      var a,b,c,d: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);
          b.SetIt(1,4,False,[8,9,6,7]);
          b.Complex := True;
          c.Mul(a,b);   // = [(1+2i)*(8*9i), (3+4i)*(6+7i)]
      end;
      </code>
      </Example>

      <SeeAlso cref="Length"/>
      <SeeAlso cref="Rows"/>
      <SeeAlso cref="Cols"/>*)
    property Complex: boolean read get_Complex write set_Complex;

   (*<summary>Defines the number of matrix rows.</summary>
      
<remarks>Use this property to set or get the number of the calling matrix rows.
      Setting the Rows does not affect the actual amount of
      memory allocated unless Rows*Cols is bigger than cache size.

      Note
        Always set the <see cref="Complex"/> property before setting Rows.
        Complex is initially false and Rows is initially 0. You can also set
        the Rows property by calling the <See Method="Size"/> method.
</remarks>


      <SeeAlso cref="Cols"/>
      <SeeAlso cref="Size"/>*)
    property Rows: integer read get_Rows write set_Rows;
    (*<summary>Defines the number of matrix columns.</summary>
      
<remarks>Use this property to set or get the number of the calling matrix columns. Setting the Cols does not affect the actual amount of
      memory allocated unless Rows*Cols is bigger than cache size.

      Note
        Always set the <see cref="Complex"/> property before setting Cols. Complex is initially false and Cols is
        initially 0. You can also set the Cols property by calling the <See Method="Size"/> method.
</remarks>


      <SeeAlso cref="Rows"/>
      <SeeAlso cref="Size"/>*)
    property Cols: integer read get_Cols write set_Cols;

    (*<summary>Defines the precision (single, float) and type (real, complex) of the floating point operations. </summary>*)

    property FloatPrecision: TMtxFloatPrecision read get_FloatPrecision write set_FloatPrecision;

   (*<summary>FFT storage format.</summary>
      
<remarks>The FFT storage format specifies how will the result of an operation
      be stored in the destination. This affects both 1D and 2D FFT's.
</remarks>
*)
    property FFTStorageFormat: TFFTStorageFormat read get_FFTStorageFormat write set_FFTStorageFormat;

   (*<summary>Leave FFT scrambeled.</summary>
      
<remarks>The last stage (or first) of an FFT, is a sorting operation.
      This sorting will be left out, if this property will be set to True.
      This can improve performance for certain applications, if you used
      properly.
</remarks>
*)
    property FFTScrambled: boolean read get_FFTScrambledOrder write set_FFTScrambledOrder;

   (*<summary>Defines if FFT transform length is odd.</summary>
      
<remarks>The property should be set to True, if the length of a forward real to complex FFT
      is odd and if the result of an inverser complex to real FFT should be odd.
</remarks>
*)
    property FFTOddLength: boolean read get_FFTOddLength write set_FFTOddLength;

  (*<summary>Defines if matrix type will be checked automatically.</summary>
      
<remarks>If True, some routines requesting <see cref="TMtxType"/> information will check for the matrix type first by calling the
      <see cref="DetectMtxType"/> method, in order to select the most efficient algorithm. The following types will be detected:
      <list>
      <item> mtSymmetric = symmetric matrix </item>
      <item> mtHermitian	= Hermitian matrix </item>
      <item> mtTriangle	= triangular matrix, with unit or non unit main diagonal </item>
      <item> mtGeneral	= general matrix (none of the above) </item>
      </list>

     In worst case the matrix type detection will require O(n^2) compare operations. In case of a general matrix, it only takes a few cycles
      for the algorithm to detect that the matrix is not Symmetric, triangular or Hermitian. And in case of a symmetric or hermitian or
      triangular matrix, the cost of O(n^2) compare operations is still much lower than the loss of performance, when using the general purpose
      algorithm. For some computations, like eigenvalues, the type of the matrix has to specified explicitly, especially when it comes to symmetric
      matrices, because the algorithm for the general matrix will fail on a symmetric matrix.
      If you specify the type of matrix explicitly to the procedures and AutoMtxType is set to True, then AutoMtxType will override the user
      specified type.
</remarks>
*)
    property AutoMtxType: boolean read get_AutoMtxType write set_AutoMtxType;

    (*<summary>Defines matrix balancing method.</summary>
      
<remarks>Defines which <see cref="TBalanceType"/> will be used to balance the calling matrix. Balancing the calling matrix can be
      very useful when calculating the eigenvalues and eigenvector. Balancing operation can perform one or both of the following similarity
      transformations:

      <b>1.</b>Permute the calling matrix (A) to block of upper triangular form:
      <IMG name="mtx008"/>
      where P is a permutation matrix, and A'11 and A' 33 are upper triangular. The diagonal elements of A'11 and A' 33 are eigenvalues of the
      calling matrix (A).

      <b>2.</b>Apply a diagonal similarity transformation to A', to make the rows and columns of A'22  as close in norm as possible:
      <IMG name="mtx009"/>
      This scaling can reduce the norm of the matrix (that is, ||A''22|| &lt; ||A'22||), and hence reduce the effect of rounding errors on the
      accuracy of computed eigenvalues and eigenvectors.
</remarks>


      <Example>
      <code>
      var A: Matrix;
        d: Vector;
      begin

        // ...
        A.Balance := btFull; // applies both methods
        A.Eig(d);
        // ...
      end;
      </code>
      </Example>

      <SeeAlso cref="Eig"/>
      <SeeAlso cref="EigGen"/>*)
    property Balance: TBalanceType read get_Balance write set_Balance;

    (*<summary>Defines the norm used to compute the condition number.</summary>
      
<remarks>Defines the norm used to compute the <see cref="ConditionNr"/>.
      The default value is cnNone meaning that no condition number will be estimated.
</remarks>


      <SeeAlso cref="ConditionNr"/>*)
    property ConditionNumber: TConditionNumber read get_ConditionNumber write set_ConditionNumber;

    (*<summary>Enables/disables the refining of the solution of the system of linear equations.</summary>
      
<remarks>The method enables/disables the refining of the solution of the system of linear equations,
      computed by <see cref="LUSolve"/> method. When RefineSolution is enabled, an iterative refinement of the solution to
      a system of linear equations is executed. For each computed solution the component-wise <see cref="BackError"/>
      and the the component-wise <see cref="ForwError"/> in the computed solution are calculated as well.
</remarks>


      <Example>
      <code>
      var X,B: Vector;
        A: Matrix;
      begin
          B.SetIt(False,[0,2]);
          A.SetIt(2,2,false,[1,2,
                            3,4]);  // 2x2, not complex matrix
          A.RefineSolution := True;
          A.ConditionNumber := cnNormInf;
          A.LUSolve(B,X);
      end;
      </code>
      </Example>

      <SeeAlso cref="BackError"/>
      <SeeAlso cref="ForwError"/>
      <SeeAlso cref="LUSolve"/>*)
    property RefineSolution: boolean read get_RefineSolution write set_RefineSolution;

    (*<summary>Defines the number of leading columns.</summary>
      
<remarks>This value defines the spacing in number of samples between rows.
      It is fixed to be the same to the value of <see cref="Cols"/> (for now).
</remarks>
*)
    property LeadingCols: integer read get_LeadingCols write set_LeadingCols;

    (*<summary>The number of superdiagonals in banded matrices.</summary>
      
<remarks>Sets/reads the number of superdiagonals in banded matrices.
</remarks>


      <SeeAlso cref="SubDiag"/>
      <SeeAlso cref="TMtxType"/>*)
    property SuperDiag: integer read get_SuperDiag write set_SuperDiag;

    (*<summary>The number of subdiagonals in banded matrices.</summary>
      
<remarks>Sets/reads the number of subdiagonals in banded matrices.
</remarks>


      <SeeAlso cref="SuperDiag"/>
      <SeeAlso cref="TMtxType"/>*)
    property SubDiag: integer read get_SubDiag write set_SubDiag;

    (*<summary>Determine which part (upper or lower) of the symmetric, hermitian or triangular matrix is set.</summary>
      
<remarks>Determine which part (upper or lower) of the symmetric, hermitian or triangular matrix is set.
</remarks>


      <SeeAlso cref="TriangleUnit"/>*)
    property TriangleForm: TTriangleForm read get_TriangleForm write set_TriangleForm;

    (*<summary>Determine, if the matrix is unit triangular.</summary>

      <SeeAlso cref="TriangleForm"/>*)
    property TriangleUnit: boolean read get_TriangleUnit write set_TriangleUnit;

    (*<summary>Stores the condition number reciprocial value after the call to LUSolve.</summary>
      
<remarks>The property is set by the <See Method="LUSolve"/> method. It contains the calling matrix condition number reciprocial value after
      the call to <see cref="LUSolve"/> method and if <see cref="ConditionNumber"/> property was not cnNone. If the ConditionNr
      (inverse of condition number) is a very small number (thus the condition number is very large), then the calling matrix is
      ill-conditioned and the error in the solution will also be large. The condition number is used for analyzing the errors in the
      solution of a system of linear equations.

      In practice, most computations are performed with rounding errors. Besides, you often need to solve a system Ax = b where the data
      (the elements of A and b) are not known exactly. Therefore, it's important to understand how the data errors and rounding errors
      can affect the solution X. If X is the exact solution of Ax = b, and X + dx is the exact solution of a perturbed problem
      <c>(A + dA)X = (b + db)</c>, then

      <IMG name="mtx003"/>

      In other words, relative errors in A or b may be amplified in the solution vector X by a factor <c>k(A) = ||A|| ||A -1 ||</c> called
      the condition number of A. The norm used to calculate the condition number is set by the <see cref="ConditionNumber"/> property.
      Rounding errors have the same effect as relative perturbations c(n)e in the original data. Here e is the machine precision,
      and c(n) is a modest function of the matrix order n. The corresponding solution error is ||dx||/||x|| &lt;= c(n)k(A)e. (The value of
      c(n) is seldom greater than 10n), Thus, if your matrix A is ill-conditioned (that is, its condition number k(A) is very large),
      then the error in the solution X is also large; you may even encounter a complete loss of precision. This loss can be greatly reduced
      by enabling the <see cref="RefineSolution"/> property.
</remarks>


      <Example>
      <code>
      var X,B: Vector;
        A: Matrix;
      begin
          B.SetIt(False,[0,2]);
          A.SetIt(2,2,false,[1,2,
                             3,4]);   // 2x2, not complex matrix
          A.RefineSolution := True;
          A.ConditionNumber := cnNormInf;
          A.LUSolve(B,X);
      end;
      </code>
      </Example>

      <SeeAlso cref="LUSolve"/>
      <SeeAlso cref="ConditionNumber"/>
      <SeeAlso cref="RefineSolution"/>*)
    property ConditionNr: double read get_ConditionNr;
    (*<summary>The info parameter as returned by the last called LAPACK function.</summary>*)
    property Info: integer read get_Info;
    (*<summary>The type of the error condition signaled by LAPACK.</summary>
      
<remarks>The string is set by the various methods, to indicate the type of the error condition signaled by
      LAPACK if <see cref="Info"/> property is not zero.
</remarks>


      <SeeAlso cref="Info"/>*)
    property MtxError: string read get_MtxError;
    (*<summary>True, if matrix is quadratic (rows=cols).</summary>*)
    property Quadratic: boolean read get_Quadratic;
    (*<summary>The component-wise backward error.</summary>
      
<remarks>Set by the <see cref="LUSolve"/> method, if the <see cref="RefineSolution"/> property was True.
      The BackError property returns the component-wise backward error b. The backward error is the smallest
      relative perturbation in elements of A (where A is the calling matrix) and b such that X is the exact
      solution of the perturbed system:

      <IMG name="mtx004"/>

      The BackError property is calculated only if the <see cref="RefineSolution"/> property is set to true.
</remarks>


      <SeeAlso cref="ForwError"/>
      <SeeAlso cref="RefineSolution"/>
      <SeeAlso cref="LUSolve"/>*)
    property BackError: double read get_BackError;
    (*<summary>The component-wise forward error.</summary>
      
<remarks>Set by the <see cref="LUSolve"/> method, if the <see cref="RefineSolution"/> property was True.
      The ForwError property returns the component-wise forward error in the computed solution:

      <IMG name="mtx005"/>
</remarks>


      <SeeAlso cref="BackError"/>
      <SeeAlso cref="RefineSolution"/>
      <SeeAlso cref="LUSolve"/>*)
    property ForwError: double read get_ForwError;

    (*<summary>Defines the length of matrix in number of samples.</summary>
      
<remarks>The length of matrix equals: rows*cols.
</remarks>
*)
    property Length: integer read get_Length;

    (*<summary>Sizing the object will not allocate less than Capacity samples.</summary>
               
<remarks>To free memory allocated before, first set Capacity to 0.
               In case of complex numbers the size is half here specified.
</remarks>
*)
    property Capacity: Int64 read get_Capacity write set_Capacity;

    (*<summary>Specifies increment step for the Capacity property.</summary>
               
<remarks>If this property is 0, the Capacity will never be modified on its own.
               When the value 1, the capacity will continue increasing to match largest value
               requested. When the value is more than 1, the capacity will be increasing with
               the factor specified.
</remarks>
*)
    property CapacityStep: double read get_CapacityStep write set_CapacityStep;
  public 

     (*<summary>Matrix constructor.</summary>*)
     constructor Create(const aRows, aCols: integer; const aFloatPrecision: TMtxFloatPrecision); overload;
     constructor Create(const aRows, aCols: integer; const aFloatPrecisionRef: TMtxVec); overload;

     
     constructor Create(const aRows, aCols: integer); overload;
     constructor Create(const aRows, aCols: integer; const aIsComplex: boolean); overload;
     

     property IsDouble: boolean read get_IsDouble write set_IsDouble;

    (*<summary>Constructor of the record.</summary>
      
<remarks>Returns a Matrix with internal TMtx object created from  object cache (CreateIt),
      if FromObjectCache is True. Pass false to the constructor,
      if the variable is a global variable. Object cache has limited size and to be
      used only for local variables.
</remarks>
*)
    constructor Create(FromObjectCache: boolean); overload;

    (*<summary>Obtains a pointer to the real value of the Matrix at Index.</summary>
      
<remarks>The function returns @Values[i]. Under .NET this is a pointer
      to pinned memory.
</remarks>


     <SeeAlso cref="PCValues1D"/>*)
    function PValues1D(const Index: integer): PPDouble;
    (*<summary>Obtains a pointer to the real value of the Matrix at Index.</summary>
      
<remarks>The function returns @Values[i]. Under .NET this is a pointer
      to pinned memory.
</remarks>


     <SeeAlso cref="PCValues1D"/>*)
    function PSValues1D(const Index: integer): PPSingle;

    (*<summary>Obtains a pointer to the complex value of the Matrix at Index.</summary>
      
<remarks>The function returns @CValues[i]. Under .NET this is a pointer
      to unmanaged memory.
</remarks>


     <SeeAlso cref="PValues1D"/>*)
    function PCValues1D(const Index: integer): PPCplx;

    (*<summary>Obtains a pointer to the complex value of the Matrix at Index.</summary>
      
<remarks>The function returns @CValues[i]. Under .NET this is a pointer
      to unmanaged memory.
</remarks>


     <SeeAlso cref="PValues1D"/>*)
    function PSCValues1D(const Index: integer): PPSCplx;

    (*<summary>Additional parameter for certain Lapack methods.</summary>
      
<remarks>Additional parameter for certain Lapack methods. When this value
      is used, it is mentioned in the method description.
      This parameter has been made a field of the object, to reduce
      the number of parameters required by a method, because it is not
      used very often.
</remarks>
*)
    property Beta: TCplx read get_Beta write set_Beta;
    (*<summary>Additional parameter for certain Lapack methods.</summary>
      
<remarks>Additional parameter for certain Lapack methods. When this value
      is used, it is mentioned in the method description.
      This parameter has been made a field of the object, to reduce
      the number of parameters required by a method, because it is not
      used very often.
</remarks>
*)
    property Alfa: TCplx read get_Alfa write set_Alfa;

    (*<summary>Debugging aid.</summary>
      
<remarks>Returns the contents of the object formated as a string to be used
      by the debugger Watches.
</remarks>
*)
    property RealValues: string read get_RealValues;
    (*<summary>Debugging aid.</summary>
      
<remarks>Returns the contents of the object formated as a string to be used
      by the debugger Watches.
</remarks>
*)
    property ComplexValues: string read get_ComplexValues;

    (*<summary>Defines the rounding used by streaming routines.</summary>

      <SeeAlso cref="SaveToStream"/>
      <SeeAlso cref="SaveToFile"/>*)
    property Rounding: TRounding read get_Rounding write set_Rounding;
    (*<summary>Defines the precision used by streaming routines.</summary>

      <SeeAlso cref="SaveToStream"/>
      <SeeAlso cref="SaveToFile"/>*)
    property Precision: TPrecision read get_Precision write set_Precision;
    (*<summary>Returns true, if the currrent subrange of the Matrix was also the last subrange in the Matrix.</summary>
      
<remarks>Returns true, if the currrent subrange of the Matrix was also the last subrange in the Matrix.
      This property be used together with <see cref="BlockNext"/> and <See Method="BlockInit"/>.
</remarks>


      <SeeAlso cref="BlockInit"/>
      <SeeAlso cref="BlockNext"/>*)
    property BlockEnd: boolean read Get_BlockEnd;
    (*<summary>Set to true after the SetSubIndex or SetSubRange call.</summary>
      
<remarks>This property is set to true after the <see cref="SetSubIndex"/> or <see cref="SetSubRange"/> call.
      If IsSubRange is true then the TVec method/function will be performed on subrange of values. Use
      <see cref="SetFullRange"/> to set IsSubRange back to False and thus reset sub range to full Matrix
      length.
</remarks>


      <SeeAlso cref="SetFullRange"/>*)
    property IsSubRange: boolean read get_IsSubRange;
    (*<summary>Returns the current depth of SubRange stack.</summary>*)
    property SubRangeLevel: integer read get_SubRangeLevel;
    (*<summary>The tolerance used by <see cref="IsEqual"/>.</summary>
      
<remarks>The tolerance used by <see cref="IsEqual"/> when the comparison type
      is relative.
</remarks>
*)
    property ZeroTolerance: double read get_ZeroTolerance write set_ZeroTolerance;

    

    {$WARNINGS OFF}
    (*<summary>Access elements of the matrix.</summary>
      
<remarks>The RowIdx indicates the row Index and the ColIdx parameter indiciates the column Index.
</remarks>
*)
    property  Values[const RowIdx, ColIdx: integer]: double read get_Values write set_Values; default;

    (*<summary>Access elements of the matrix.</summary>
      
<remarks>The RowIdx indicates the row Index and the ColIdx parameter indiciates the column Index.
</remarks>
*)
    property  CValues[const RowIdx, ColIdx: integer]: TCplx read get_CValues write set_CValues;

    (*<summary>Access elements of the Matrix or matrix.</summary>
      
<remarks>The Idx parameter can be translated to row and column indexes like this:

      <code>
      RowIndex := Idx div Mtx.Cols;
      ColumnIndex := Idx mod Mtx.Cols;
      </code>

      To compute the Index at a given row and column:
      <code>
      Idx := RowIndex*Mtx.Cols + ColumnIndex;
      </code>
</remarks>
*)
    property Values1D[const Idx: integer]: double read get_Values1D write set_Values1D;
    (*<summary>Access elements of the Matrix or matrix.</summary>
      
<remarks>The Idx parameter can be translated to row and column indexes like this:

      <code>
      RowIndex := Idx div Mtx.Cols;
      ColumnIndex := Idx mod Mtx.Cols;
      </code>

      To compute the Index at a given row and column:

      <code>
      Idx := RowIndex*Mtx.Cols + ColumnIndex;
      </code>
</remarks>
*)
    property  CValues1D[const Idx: integer]: TCplx read get_CValues1D write set_CValues1D;

    (*<summary>Access elements of the matrix.</summary>
      
<remarks>The RowIdx indicates the row Index and the ColIdx parameter indiciates the column Index.
</remarks>
*)
    property  SValues[const RowIdx, ColIdx: integer]: single read get_SValues write set_SValues;

    (*<summary>Access elements of the matrix.</summary>
      
<remarks>The RowIdx indicates the row Index and the ColIdx parameter indiciates the column Index.
</remarks>
*)
    property  SCValues[const RowIdx, ColIdx: integer]: TSCplx read get_SCValues write set_SCValues;

    (*<summary>Access elements of the Matrix or matrix.</summary>
      
<remarks>The Idx parameter can be translated to row and column indexes like this:

      <code>
      RowIndex := Idx div Mtx.Cols;
      ColumnIndex := Idx mod Mtx.Cols;
      </code>

      To compute the Index at a given row and column:
      <code>
      Idx := RowIndex*Mtx.Cols + ColumnIndex;
      </code>
</remarks>
*)
    property SValues1D[const Idx: integer]: single read get_SValues1D write set_SValues1D;
    (*<summary>Access elements of the Matrix or matrix.</summary>
      
<remarks>The Idx parameter can be translated to row and column indexes like this:

      <code>
      RowIndex := Idx div Mtx.Cols;
      ColumnIndex := Idx mod Mtx.Cols;
      </code>

      To compute the Index at a given row and column:

      <code>
      Idx := RowIndex*Mtx.Cols + ColumnIndex;
      </code>
</remarks>
*)
    property  SCValues1D[const Idx: integer]: TSCplx read get_SCValues1D write set_SCValues1D;

    (*<summary>Allows copying/assignment of subranges.</summary>
      
<remarks>Reading this property will return a sub-ranged Vector. Similar to calling b.SetSubRange(a, Indx, Len);
      Writing this property will copy source to the specified subrange. The size of the value being assigned
      needs to match the range specified.
</remarks>
*)

    property Select[const Indx, Len: integer]: Vector read GetSelect write SetSelect; 

    (*<summary>Allows copying/assignment of subranges.</summary>
      
<remarks>Reading this property will return a copied selection of subranged vector by calling Dst.GatherByIncr(Src, startIndex, Step);
      Writing this property will copy source to the specified range by using Data.ScatterByIncr.
      The size of the value being assigned needs to match the index range specified.
      This property does not obtain a "view" unless Step equals to 1.
</remarks>
*)
    property SelectIndex[const startIndex, Step, stopIndex: integer]: Vector read GetSelectIndex write SetSelectIndex; 

    (*<summary>Allows copying/assignment of subranges.</summary>
      
<remarks>Reading this property will copy Matrix from the specified location. Writing this property will copy the Source to the specified location.
      This property does not obtain a "view".
</remarks>
*)
    property Select2D[const RowIdx, ColIdx, RowLen, ColLen: integer]: Matrix read GetSelect2D write SetSelect2D;

    (*<summary>Allows copying/assignment of subranges.</summary>
      
<remarks>Reading this property will copy Matrix from the specified location.
      Writing this property will copy the Source to the specified location.
      This property does not obtain a "view".
</remarks>
*)
    property SelectIndex2D[const StartRowIdx, StartColIdx, StopRowIdx, StopColIdx: integer]: Matrix read GetSelectIndex2D write SetSelectIndex2D;

    {$WARNINGS ON}

    

    (*<summary>Returns content as a string.</summary>
               
<remarks>Values will be separated by line breaks.
</remarks>
*)
    function ToString: string; 
    (*<summary>Parses string content as vector.</summary>
               
<remarks>Values need to be separated by the tab charachter.
               Rows of values need to be separated by line breaks.
               For other parsing options call StringToValues.
               The Parse method works in pair with the ToString method both meant to be a reverse of the other,
               but do not preserve any other property of the matrix except only values.
               Use SaveToStream/LoadFromStream methods for binary storage option, which uses about 2x less memory and is a lot faster to save and load.
</remarks>
*)
    class function Parse(const Src: string): Matrix; static;

    
    procedure AssignWithoutCopy(const Src: Matrix);
    procedure Assign(const Src: Matrix);
    

    (*<summary>Initializes block processing.</summary>
      
<remarks>Initializes block processing. Because the size of the CPU cache is limited, significant performance gains can be obtained by
      splitting long vectors in to a series of short ones, which can all fit in the CPU cache entirely. The BlockInit method is
      to be used together with <see cref="BlockNext"/> and <See Method="BlockEnd"/> methods to initialize a block processing
      while loop. BlockInit will call <see cref="SetSubRange"/> to obtain subrange of the data in TVec. The <see cref="Length"/>
      of the subranged Matrix is determined by the global  <see cref="Math387.MtxVecBlockSize"/> variable
      declared in <see cref="Math387"/> unit. Default value of MtxVecBlockSize is preset to 800 Matrix elements for double precision
      and 1600 elements for single precision. BlockInit supports nested calls and from witihin a blocked while loop you can call
      procedures and functions which are also blocked. If you use block processing, typical performance gains will range from
      2 to a maximum of 6. Block processing can not be used, or it is difficult to apply, in cases where Matrix elements are
      not independent of each other. The block processing while loop must be written like this:

      <code>
      a.BlockInit;
      while not A.BlockEnd do
      begin
        // .... user defined function
      a.BlockNext.
      end;
      </code>
</remarks>


      <Example>Normal vectorized procedure:

      <code>
      procedure ParetoPDF(const X: Matrix; a, b: double;var Res: Matrix); overload;
      begin
        Res.Size(X);
        Res.Power(X,-(a+1));
        Res.Mul(Power(b,a)*a);;
      end;
      </code>
      Vectorized and blocked version of the Pareto probability distribution procedure:

      <code>
      procedure ParetoPDF(const X: Matrix; a, b: double; var Res: Matrix); overload;
      begin
        Res.Size(X);
        Res.BlockInit;
        X.BlockInit;
        while not X.BlockEnd do
        begin
          Res.Power(X,-(a+1));
          Res.Mul(Power(b,a)*a);
          Res.BlockNext;
          X.BlockNext;
        end;
      end;
      </code>

      The block version of the ParetoPDF will execute faster then the non-blocked version in cases
      where X contains 5000-10000 elements or more (double precision). Below that value the two
      versions will perform about the same, except for very short Matrix sizes (below 50 elements),
      where the non-blocked version will have a slight advantage, because of the absence of block
      processing methods overhead. The time is saved  between the calls  to Res.Power(X,-(a+1))
      and  Res.Mul(Power(b,a)*a), where the same memory (stored in Res Matrix) is accesed in
      two consecutive calls. That memory is loaded in the CPU cache on the first call, if the
      Length of the Res Matrix is short enough to fit in. As an excercise you can also try to
      compare the performance of the vectorized and blocked version of the function with the
      single value version (ParetoPDF(X: double; a, b: double; Res: double) and measure
      the execution time of both versions for long vectors (100 000 elements) and short
      vectors (10 elements).

      The differences with block processing will be more noticable on old CPU's without
      support for SSE2/SSE3.
      </Example>

      <SeeAlso cref="BlockNext"/>
      <SeeAlso cref="BlockEnd"/>*)
    procedure BlockInit; overload;
    (*<summary></summary>*)
    procedure BlockInit(ABlockSize: integer); overload;

    (*<summary>Initializes block processing.</summary>*)
    procedure BlockInit(const Src: TMtxVecBase); overload;

    (*<summary>Initializes block processing.</summary>
               
<remarks>Block processing can be applied on possibly already subranged Src object.
               Src may not be freed or go out of scope until block processing loop has finished. There would
               be no error raised other than AV.
</remarks>
*)
    procedure BlockInit(const Src: TMtxVecBase; ABlockSize: integer); overload;

    (*<summary>Obtains the next subrange of the data.</summary>
      
<remarks>Obtains the next subrange of the data in TVec. The routine must be used together with
      <see cref="BlockEnd"/> and <see cref="BlockInit"/> methods.
</remarks>


      <SeeAlso cref="BlockInit"/>
      <SeeAlso cref="BlockEnd"/>*)
    procedure BlockNext;

    (*<summary>Deinitializes block processing before the final block is processed.</summary>
               
<remarks>Call this routine before breaking out of a while-loop prematurely.

        <code>

        Vec.BlockInit
        While not Vec.BlockEnd do
        Begin
            If Vec.Min &lt; 0 then //check some condition, if you need to exit
            begin
              Vec.BlockFinish;  //finish the loop
              Break;  //and break out
            end;
            Vec.BlockNext;
        end

        </code>
</remarks>
*)
    procedure BlockFinish;

    (*<summary>Compute maximum of each row.</summary>
               
<remarks>Compute maximum of each row and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
    procedure MaxRows(const Dst: TVec); overload;
    (*<summary>Compute minimum of each row.</summary>
               
<remarks>Compute mniimum of each row and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
    procedure MinRows(const Dst: TVec); overload;
    (*<summary>Compute maximum of each column.</summary>
               
<remarks>Compute maximum of each column and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
    procedure MaxCols(const Dst: TVec); overload;
    (*<summary>Compute minimum of each column.</summary>
               
<remarks>Compute mniimum of each column and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
    procedure MinCols(const Dst: TVec); overload;

    (*<summary>Compute maximum and minimum of each row.</summary>
               
<remarks>Compute maximum and minimum of each row and store the result in to Dst vectors. The Dst's are sized automatically.
</remarks>
*)
    procedure MaxMinRows(const DstMaxRows, DstMinRows: TVec); overload;
    (*<summary>Compute maximum and minimum of each column.</summary>
               
<remarks>Compute maximum and minimum of each column and store the result in to Dst vectors. The Dst's are sized automatically.
</remarks>
*)
    procedure MaxMinCols(const DstMaxCols, DstMinCols: TVec);

    (*<summary>Replaces all NAN values with Value.</summary>*)
    function ReplaceNAN(const Value: double): TMtxVec; overload;

    (*<summary>Replaces all NAN values with Value within calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ReplaceNAN(const Value: double; Index, Len: integer): TMtxVec; overload;

    (*<summary>Prevents calls to <see cref="SetSubRange"/>.</summary>
      
<remarks>Prevents calls to <see cref="SetSubRange"/> method. This can be usefull
      guard when an object is already working on a subrange and the user
      would like to further subrange an already subranged object.
      When subranging matrices in-place, they are temporariliy converted
      to a vector by settings Rows to 1 and Cols to Length.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          b: Vector;
      begin
          a.SetIt(3,3,false, [1,2,3,4,5,6,7,8,9]);
          a.SetSubRange(0,2);  //a = [1,2]
          a.DisableSubrange;
          a.SetSubRange(2,2); //exception raised here

          b.SetSubRange(a,2,2); //but this will work
          a.SetFullRange; //b is not changed, it still points to [4,5]
      end;
      </code>
      </Example>


      <SeeAlso cref="DisableSubrange"/>
      <SeeAlso cref="EnableSubrange"/>*)
    procedure DisableSubrange;

    (*<summary>Enables calls to <see cref="SetSubRange"/>.</summary>
      
<remarks>Enables calls to <see cref="SetSubRange"/> by removing
      the block set by <see cref="DisableSubrange"/>.
</remarks>
*)
    procedure EnableSubrange;

    (*<summary>Prevents calls to <see cref="Select"/>.</summary>
      
<remarks>Prevents calls to <see cref="Select"/> method. This can be usefull
      guard when an object is already working on a subrange and the user
      would like to further subrange an already subranged object.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          b: Vector;
      begin
          a.SetIt(3,3,false, [1,2,3,4,5,6,7,8,9]);
          a.Select(0,2);  //a = [1,2]
          a.DisableSelect;
          a.Select(2,2); //exception raised here

          b.Select(a,2,2); //but this will work
          a.SelectAll; //b is not changed, it still points to [4,5]
      end;
      </code>
      </Example>

      <SeeAlso cref="DisableSubrange"/>
      <SeeAlso cref="EnableSubrange"/>*)
    procedure DisableSelect;

    (*<summary>Enables calls to <see cref="Select"/>.</summary>
      
<remarks>Enables calls to <see cref="Select"/> by removing
      the block set by <see cref="DisableSelect"/>.
</remarks>
*)
    procedure EnableSelect;

    (*<summary>Resets any defined selection.</summary>

      <SeeAlso cref="Select"/>
      <SeeAlso cref="SetSubIndex"/>*)
    procedure SelectAll; overload;

    (*<summary>Resets any defined subrange.</summary>

      <SeeAlso cref="SetSubRange"/>
      <SeeAlso cref="SetSubIndex"/>*)
    procedure SetFullRange;

    (*<summary>Resets any defined subrange and pops the stack.</summary>*)
    procedure SetFullRangeLevel;

    (*<summary>Defines a sub Matrix/matrix.</summary>
      
<remarks>The method will define a subarray starting at
      Index and ending at Index+Len-1. No copying will occur, only
      pointers will be shifted.
      All values of the original <see cref="Vector"/> will be preserved.
      An exception will be raised if an attempt is made to change the size of calling object.

      A sub-Matrix/matrix is Matrix/matrix which does not neccessarily have its own
      memory allocated. Instead it adopts the memory of the
      source object and all operations done on the either of the objects
      affect the same elements. The use of subvectors/submatrices increases
      CPU cache reuse, lower's memory requirements, increases
      application performance and improves code readability.

      To again obtain a view of the full Matrix/matrix, see <see cref="SetFullRange"/>
</remarks>
*)
    procedure SetSubRange(Index: integer; Len: integer); overload;
    (*<summary>Defines a sub Matrix/matrix.</summary>*)
    procedure SetSubRange(const Src: TDenseMtxVec; Index, Len: integer); overload;


   (*<summary>Defines a sub vector/matrix.</summary>
      
<remarks>The method will define a subarray starting at Index and ending at Index + (aRows*aCols)-1. No copying will occur, only
      pointers will be shifted or indices adjusted. The subranged matrix will have the size aRows and aCols.
      Length will be equal to aRows*aCols.

      All values of the original <see cref="TMtxVecBase"/> will be preserved.
      An exception will be raised if an attempt is made to change the size of calling object.

      A sub-vector/matrix is vector/matrix, which does not have its own
      memory allocated. Instead it adopts the memory of the source object and all operations done on
      either of the objects affect the same elements. The use of subvectors/submatrices increases
      CPU cache reuse, lower's memory requirements, increases application performance and improves code readability.

      To again obtain a view of the full vector/matrix, see <see cref="TMtxVecBase.SetFullRange"/>

      The routine only makes sense to be used where aCols matches Src.Cols. MtxVec has only
      limited support for matrices where the matrix rows are not stored strictly consecutively.
      This overload is to be used with great caution.

      The routine should not be mixed with other SetSubRange routines or subrange stack.
</remarks>
*)

    procedure SetSubRange(const Src: TMtxVec; Index: integer; aRows, aCols: integer); overload;

    (*<summary>Defines a sub Matrix/matrix and pushes the stack.</summary>*)
    procedure SetSubRangeLevel(Index: integer; Len: integer); overload;
    (*<summary>Defines a sub Matrix/matrix and pushes the stack.</summary>*)
    procedure SetSubRangeLevel(const Src: TDenseMtxVec; Index, Len: integer); overload;





































    (*<summary>Sets the subarray size to full size. This method is the same as the <see cref="SetFullRange"/> method.</summary>*)
    procedure SetSubRange; overload;

    (*<summary>Defines a subarray.</summary>
      
<remarks>The method will define a sub array starting at
      BeginIndex and ending at EndIndex (inclusive).
      All values of the original Matrix/matrix will be preserved.
      An exception will be raised if an attempt is made to
      change the size of calling Matrix/matrix.

      A subarray is array which does not have its own
      memory allocated. Instead it adopts the memory of the
      source object and all operations done on the either of the objects
      affect the same elements. The use of subarrays increases
      CPU cache reuse, lower's memory requirements, increases
      application performance and improves code readability.

      Note
        To again obtain a view of the full Matrix see <see cref="SetFullRange"/>
</remarks>
*)
    procedure SetSubIndex(BeginIndex, EndIndex: integer);


        (*<summary>Finds a match for X in sorted object values using binary search.</summary>
               
<remarks>The data in the vector must be sorted in ascending order for this function to work correctly.
</remarks>

      <returns>the Index of last matched element. If no matching elements are found, the result is -1.</returns>*)

    function BinarySearch(const X: double): Integer; overload;
    function BinarySearch(const X: double; const Index: integer; Len: integer): Integer; overload;

    function BinarySearch(const X: TCplx): Integer; overload;
    function BinarySearch(const X: TCplx; const Index: integer; Len: integer): Integer; overload;

    (*<summary>Scale all matrix columns with values from Src.</summary>
              
<remarks>Src.Length must be equal to Self.Cols.
</remarks>
*)
    function ScaleCols(const Src: TVec): TMtx; overload;

    (*<summary>Scale all matrix rows with values from Src.</summary>
              
<remarks>Src.Length must be equal to Self.Rows.
</remarks>
*)
    function ScaleRows(const Src: TVec): TMtx; overload;

    (*<summary>Scale all Mtx matrix columns with values from Src.</summary>
              
<remarks>Src.Length must be equal to Mtx.Cols. The result is stored to the calling matrix.
</remarks>
*)
    function ScaleCols(const Mtx: TMtx; const Src: TVec): TMtx; overload;

    (*<summary>Scale all Mtx matrix rows with values from Src.</summary>
              
<remarks>Src.Length must be equal to Mtx.Rows. The result is stored to the calling matrix.
</remarks>
*)
    function ScaleRows(const Mtx: TMtx; const Src: TVec): TMtx; overload;

    (*<summary>Multiply matrix with diagonal matrix from the left.</summary>
               
<remarks>DiagMtx contains the values of the main diagional of the diagonal matrix.
               Other values of the DiagMtx matrix are assumed to be zero.
               DiagMtx.Length must be equal to Self.Cols. This operation is the same as calling TMtx.ScaleRows.
</remarks>
*)
    function MulDiagLeft(const DiagMtx: TVec): TMtx; overload;

    (*<summary>Multiply matrix with diagonal matrix from the right.</summary>
               
<remarks>DiagMtx contains the values of the main diagional of the diagonal matrix.
               Other values of the DiagMtx matrix are assumed to be zero.
               DiagMtx.Length must be equal to Self.Rows. This operation is the same as calling TMtx.ScaleCols.
</remarks>
*)
    function MulDiagRight(const DiagMtx: TVec): TMtx; overload;

    (*<summary>Multiply matrix with diagonal matrix from the left.</summary>
               
<remarks>DiagMtx contains the values of the main diagional of the diagonal matrix.
               Other values of the DiagMtx matrix are assumed to be zero.
               DiagMtx.Length must be equal to Self.Cols. This operation is the same as calling TMtx.ScaleRows.
</remarks>
*)
    function MulDiagLeft(const DiagMtx: TVec; const Mtx: TMtx): TMtx; overload;

    (*<summary>Multiply matrix with diagonal matrix from the right.</summary>
               
<remarks>DiagMtx contains the values of the main diagional of the diagonal matrix.
               Other values of the DiagMtx matrix are assumed to be zero.
               DiagMtx.Length must be equal to Self.Rows. This operation is the same as calling TMtx.ScaleCols.
</remarks>
*)
    function MulDiagRight(const Mtx: TMtx; const DiagMtx: TVec): TMtx; overload;

    (*<summary>Finds exact or closest Index match for X in sorted object values using binary search.</summary>
               
<remarks>The data in the vector must be sorted in ascending order for this function to work correctly.
               The closest match is the Index of first bigger or smaller value in the array.

      To ensure bigger value write:

      <code>
      Data := [0,2,3];
      Data.BinarySearch(Value, XIndex);
      if Data[XIndex] &gt; Value then Dec(XIndex);
      </code>

      To ensure smaller value write:

      <code>
      Data := [0,2,3];
      Data.BinarySearch(1, XIndex);
      if Data[XIndex] &lt; Value then Inc(XIndex);
      </code>
</remarks>

	  
	  <returns>True and exact Index in XIndex, if found and False and the Index of the next bigger or smaller value in XIndex, if not found. </returns>*)

    function BinarySearch(const X: double; var XIndex: integer): boolean; overload;
    function BinarySearch(const X: double; var XIndex: integer; const Index: integer; Len: integer): boolean; overload;

    function BinarySearch(const X: TCplx; var XIndex: integer): boolean; overload;
    function BinarySearch(const X: TCplx; var XIndex: integer; const Index: integer; Len: integer): boolean; overload;

    (*<summary>Sine.</summary>
      
<remarks>Calculate the sine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[1,-2,3,4]);
          a.Sin; // Computes complex sine
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcSin"/>
      <SeeAlso cref="SinCos"/>*)
    function Sin: TMtxVec; overload;
    (*<summary>Calculate the sine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sin(Index: integer; Len: integer): TMtxVec; overload;
    (*<summary>Calculate the sine of all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sin(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the sine of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sin(const X: TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload; 

    (*<summary>Cosine.</summary>
      
<remarks>Calculate the cosine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[1,-2,3,4]);
          a.Cos; // Computes complex sine
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcCos"/>
      <SeeAlso cref="SinCos"/>*)
    function Cos: TMtxVec; overload;
    (*<summary>Calculate the cosine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cos(Index: integer; Len: integer): TMtxVec; overload;
    (*<summary>Calculate the cosine of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cos(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the cosine of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object and the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cos(const X: TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload;

    (*<summary>Tangens.</summary>
      
<remarks>Calculate the tangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[1,-2,3,4]);
          a.Tan; // Computes complex tangens
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcTan"/>
      <SeeAlso cref="ArcTan2"/>*)
    function Tan: TMtxVec; overload;
    (*<summary>Calculate the tangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Tan (Index: integer; Len: integer): TMtxVec; overload;
    (*<summary>Calculate the tangens of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Tan(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the tangens of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Tan(const X : TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload;

    (*<summary>Cotangens.</summary>
      
<remarks>Calculate the cotangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[1,-2,3,4]);
          a.Cot; // Computes complex cotangens
      end;
      </code>
      </Example>

      <SeeAlso cref="Tan"/>
      <SeeAlso cref="ArcCot"/>*)
    function Cot: TMtxVec; overload;
    (*<summary>Calculate the cotangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cot(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the cotangens of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cot(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the cotangens of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cot(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Secant.</summary>
      
<remarks>Calculate the secant of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[1,-2,3,4]);
          a.Sec; // Computes complex secant
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcSec"/>
      <SeeAlso cref="Csc"/>*)
    function Sec: TMtxVec; overload;
    (*<summary>Calculate the secant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sec(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the secant of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sec(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the secant of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sec(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Cosecant.</summary>
      
<remarks>Calculate the cosecant of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[1,-2,3,4]); // a = [1-2i, 3+4i]
          a.Csc; // Computes complex cosecant
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcCsc"/>
      <SeeAlso cref="Sec"/>*)
    function Csc: TMtxVec; overload;
    (*<summary>Calculate the cosecant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Csc(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the cosecant of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Csc(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the cosecant of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Csc(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>The inverse sine.</summary>
      
<remarks>Calculate the inverse sine of all calling object elements in-place. Values must be between -1 and 1.
      The return values will be in the range [0,PI], in radians.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
        a.SetIt(1,2, True,[1,-0.5,0.11,0.9]);
        a.ArcSin;  //or
        b := ArcSin(a);  //or
        a := ArcSin(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Sin"/>*)
    function ArcSin: TMtxVec; overload;
    (*<summary>Calculate the inverse sine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSin(Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculate the inverse sine of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcSin(const X: TMtxVec): TMtxVec; overload;
    (*<summary>Calculate the inverse sine of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSin(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>The inverse cosine.</summary>
      
<remarks>Calculate the inverse cosine of all calling object elements in-place. Values must be between -1 and 1.
      The return values will be in the range [0,PI], in radians.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
        a.SetIt(1,2 True,[1,-0.5,0.11,0.9]);
        a.ArcCos;  // or
        b := ArcCos(a); // or
        a := ArcCos(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Cos"/>*)
    function ArcCos: TMtxVec; overload; 
    (*<summary>Calculate the inverse cosine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCos(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosine of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCos(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosine of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCos(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse tangens of Y/X.</summary>
      
<remarks>Calculates the inverse tangens of Y/X, and returns an angle in the correct quadrant. The results are stored in
      calling object elements. Size and <see cref="Complex"/> properties of calling object are adjusted automatically
      to match those of X and Y objects. An exception is raised if X and Y size and <see cref="Complex"/> properties do not match.

      The result will fall in the range from -PI to PI radians.

      Note
        <see cref="ArcTan"/> is calculated as ArcTan2(1, X).
</remarks>


      <SeeAlso cref="ArcTan"/>*)
    function ArcTan2(Y, X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of Y/X by using Y elements [YIndex]..[YIndex+Len-1], X elements [XIndex]..[XIndex+Len-1]
      and store the results in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTan2(Y, X: TMtxVec; YIndex, XIndex, Index: integer; Len: integer): TMtxVec; overload; 

    (*<summary>Inverse tangens.</summary>
      
<remarks>Calculate the inverse tangens for all calling object elements in-place. The return values are expressed in radians.
</remarks>


      <Example>
      <code>
      var A,B: Matrix;
      begin
        A.SetIt(2,2,True,[1,0, 2,0
                          2,0  4,1]);  // 2x2, complex matrix
        B.ArcTan(A); // or
        B := ArcTan(A);  // or
        A := ArcTan(A);
      end;
      </code>
      </Example>

      <SeeAlso cref="Tan"/>
      <SeeAlso cref="ArcCot"/>
      <SeeAlso cref="ArcTan2"/>*)
    function ArcTan: TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTan(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcTan(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse tangens of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTan(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse cotangens.</summary>
      
<remarks>Calculate the inverse cotangens for all calling object elements in-place. The return values are expressed in radians.
</remarks>


      <Example>
      <code>
      var A,B: Matrix;
      begin
        A.SetIt(2,2,True,[1,0, 2,0
                        2,0  4,1]);  // 2x2, complex matrix
        B.ArcCot(A); //or
        B := ArcCot(A);
      end;
      </code>
      </Example>

      <SeeAlso cref="Cot"/>
      <SeeAlso cref="ArcTan"/>*)
    function ArcCot: TMtxVec; overload; 
    (*<summary>Calculate the inverse cotangens of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCot(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse cotangens of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCot(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse cotangens of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCot(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse secant.</summary>
      
<remarks>Calculate the inverse secant for all calling object elements in-place.
</remarks>


      <SeeAlso cref="Sec"/>
      <SeeAlso cref="ArcCsc"/>*)
    function ArcSec: TMtxVec; overload; 
    (*<summary>Calculate the inverse secant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSec(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse secant of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcSec(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse secant of X object elements [XIndex]...[XIndex+Len-1]. The results are stored
      in calling object elements [Index]...[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSec(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse cosecant.</summary>
      
<remarks>Calculate the inverse cosecant for all calling object elements in-place.
</remarks>


      <SeeAlso cref="Csc"/>
      <SeeAlso cref="ArcSec"/>*)
    function ArcCsc: TMtxVec; overload; 
    (*<summary>Calculate the inverse cosecant of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsc(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosecant of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCsc(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse cosecant of X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in the calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsc(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic sine.</summary>
      
<remarks>Calculate the hyperbolic sine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(2,2,False,[1,1.5,2,0.3]);
          a.Sinh; // or
          a := Sinh(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcSinh"/>
      <SeeAlso cref="SinhCosh"/>*)
    function Sinh: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic sine of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sinh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic sine of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sinh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic sine for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in the calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sinh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic cosine.</summary>
      
<remarks>Calculate the hyperbolic cosine of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,1.5,2,0.3]);
          a.Cosh;  //or
          a := Cosh(a); //internally becomes a.Cosh (in-place operation)
          b.Cosh(a);
          b := Cosh(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcCosh"/>
      <SeeAlso cref="SinhCosh"/>*)
    function Cosh: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosine for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cosh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosine for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cosh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosine for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cosh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic tangens.</summary>
      
<remarks>Calculate the hyperbolic tangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,1.5,2,0.3]);
          a.Tanh; //or
          a := Tanh(a); //same as a.Tanh  (in place operation)
          b := Tanh(a); //not in place
          b.Tanh(a);    //not in place
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcTanh"/>
      <SeeAlso cref="Coth"/>*)
    function Tanh: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic tangens for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Tanh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic tangens for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Tanh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic tangens for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in the calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Tanh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic cotangens.</summary>
      
<remarks>Calculate the hyperbolic cotangens of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,1.5,2,0.3]);
          a.Coth;
          a := Coth(a);
          b.Coth(a);   //same as
          b := Coth(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="ArcTanh"/>
      <SeeAlso cref="Coth"/>*)
    function Coth: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cotangens for calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Coth(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cotangens for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Coth(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cotangens for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Coth(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic secant.</summary>
      
<remarks>Calculate the hyperbolic secant of all caling object elements in-place.
</remarks>


      <SeeAlso cref="ArcSech"/>
      <SeeAlso cref="Csch"/>*)
    function Sech: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic secant for calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sech(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic secant for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sech(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic secant for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sech(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Hyperbolic cosecant.</summary>
      
<remarks>Calculate the hyperbolic cosecant of all caling object elements in-place.
</remarks>


      <SeeAlso cref="ArcCsch"/>
      <SeeAlso cref="Sech"/>*)
    function Csch: TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosecant for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Csch(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosecant for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Csch(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the hyperbolic cosecant for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Csch(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 


    (*<summary>Absolute values.</summary>
      
<remarks>Calculate the absolute value of all calling object elemets in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
        a.SetIt(1,2,True,[1,-2,3,4]);
        a.Abs;
        a := Abs(a); //same as a.Abs
        b.Abs(a);   //same as b := Abs(a);
        b := Abs(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Mag"/>*)
    function Abs: TMtxVec; overload; 
    (*<summary>Calculate the absolute value for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Abs(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the absolute value for all X object.</summary>
      
<remarks>Store the results in the calling object. Size and <see cref="Complex"/> property
      of calling object are adjusted automatically.
</remarks>
*)
    function Abs(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the absolute value of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1].
      An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Abs(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic sine.</summary>
      
<remarks>Calculate the inverse hyperbolic sine for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Sinh"/>*)
    function ArcSinh: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic sine for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSinh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic sine for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcSinh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic sine for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSinh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic cosine.</summary>
      
<remarks>Calculate the inverse hyperbolic cosine for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Cosh"/>*)
    function ArcCosh: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosine for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCosh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosine for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCosh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosine for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCosh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic tangens.</summary>
      
<remarks>Calculate the inverse hyperbolic tangens for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Tanh"/>*)
    function ArcTanh: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic tangens for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcTanh(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic tangens for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcTanh(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic tangens for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Arctanh(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic cotangens.</summary>
      
<remarks>Calculate the inverse hyperbolic cotangens for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Coth"/>*)
    function ArcCoth: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cotangens for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCoth(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverser hyperbolic cotangens for all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCoth(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cotangens for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCoth(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic secant.</summary>
      
<remarks>Calculate the inverse hyperbolic secant for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Sech"/>*)
    function ArcSech: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic secant for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSech(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic secant for all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcSech(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic secant for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcSech(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Inverse hyperbolic cosecant.</summary>
      
<remarks>Calculate the inverse hyperbolic cosecant for all caling object elements in-place.
</remarks>

      <SeeAlso cref="Csch"/>*)
    function ArcCsch: TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosecant for calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsch(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosecant for all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function ArcCsch(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse hyperbolic cosecant for X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function ArcCsch(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The cube root.</summary>
      
<remarks>Calculate the cube root of all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var v,w: Matrix;
      begin
          v.SetIt(1,2,false,[1,8]);
          v.Cbrt; // v = [1,2], same as:
          v := Cbrt(v);
          w := Cbrt(v); //same as:
          w.Cbrt(v);
      end;
      </code>
      </Example>

      <SeeAlso cref="InvCbrt"/>*)
    function Cbrt: TMtxVec; overload; 
    (*<summary>Calculate the cube root of calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Cbrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the cube root of all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Cbrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the cube root of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Cbrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Rounds towards positive infinity.</summary>
      
<remarks>Rounds all calling object elements towards positive infinity in-place.

      <code>
      Ceil(-2.8) = -2
      Ceil(2.8) = 3
      Ceil(-1.0) = -1
      </code>
</remarks>
*)
    function Ceil: TMtxVec; overload;
    (*<summary>Rounds calling object elements [Index]..[Index+Len-1] towards positive infinity in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Ceil(Index,Len: integer): TMtxVec;  overload;
    (*<summary>Rounds all Src object elements towards positive infinity and stores the result in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted
      automatically.
</remarks>
*)
    function Ceil(const Src: TMtxVec): TMtxVec;  overload;
    (*<summary>Rounds Src object elements [SrcIndex]..[SrcIndex+Len-1] towards positive infinity
      and stores the result in the calling object elements [Index]..[Index+Len-1]-</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Ceil(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec;  overload;

    (*<summary>Natural logarithm.</summary>
      
<remarks>Calculate the natural log for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          a.Ln;    //same as:
          a := Ln(a);
          b.Ln(a); //same as:
          b := Ln(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp"/>*)
    function Ln: TMtxVec; overload; 
    (*<summary>Calculate the natural algorithm for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function Ln(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the natural logarithm for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Ln(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the natural logarithm for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Ln(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Log base 10.</summary>
      
<remarks>Calculate the log base 10 for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[10,100,1000,10000]);  // a = [10,100,1000,10000]
          a.Log10;     // a = [1,2,3,4], same as:
          a := Log10(a);
          b.Log10(a);  //same as
          b := Log10(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp10"/>*)
    function Log10: TMtxVec; overload; 
    (*<summary>Calculate the log base 10 for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function Log10(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the log base 10 for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Log10(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the log base 10 for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Log10(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Log base 2.</summary>
      
<remarks>Calculate the log base 2 for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,4,8]);
          a.Log2;  //same as:
          a := Log2(a);
          b := Log2(a); //same as:
          b.Log2(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp2"/>*)
    function Log2: TMtxVec; overload; 
    (*<summary>Calculate the log base 2 for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function Log2(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the log base 2 for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Log2(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the log base 2 for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Log2(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Exponent (e^).</summary>
      
<remarks>Calculate the exponent (e^) for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,4,8]);
          a.Exp;  //same as:
          a := Exp(a);
          b := Exp(a); //same as:
          b.Exp(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Ln"/>*)
    function Exp: TMtxVec; overload; 
    (*<summary>Calculate the exponent (e^) for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function Exp(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the exponent (e^) for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Exp(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the exponent (e^) for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Exp(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Exponent base 2 (2^).</summary>
      
<remarks>Calculate the exponent base 2 (2^) for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);  // a = [1,2,3,4]
          a.Exp2;   // a = [2,4,8,16]
          a := Exp2(a);
          b.Exp2(a); //same as
          b := Exp2(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Log2"/>*)
    function Exp2: TMtxVec; overload; 
    (*<summary>Calculate the exponent base 2 (2^) for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function Exp2(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 2 (2^) for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Exp2(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 2 (2^) for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Exp2(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Exponent base 10 (10^).</summary>
      
<remarks>Calculate the exponent base 10 (10^) for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);  // a = [1,2,3,4]
          a.Exp10;        // a = [10,100,1000,10000]
          a := Exp10(a);
          b.Exp10(a);  //same as
          b := Exp10(a);
      end;
      </code>
      </Example>

      <SeeAlso cref="Log10"/>*)
    function Exp10: TMtxVec; overload; 
    (*<summary>Calculate the exponent base 10 (10^) for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function Exp10(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 10 (10^) for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Exp10(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the exponent base 10 (10^) for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function Exp10(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Gets the imaginary part of a complex object.</summary>
      
<remarks>Gets the imaginary part of a complex object Vec and stores the real results in the calling object.
      Size and <see cref="Complex"/> properties of the calling object are set implicitly to match
      Vec object. Vec <see cref="Complex"/> must be true otherwise the exception will be raised.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);  // a= [1+2i, 3+4i]
          b.ImagPart(a);  // b = [2, 4]
      end;
      </code>
      </Example>

      <SeeAlso cref="RealPart"/>
      <SeeAlso cref="RealToCplx"/>*)
    function ImagPart(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Gets the imaginary part of complex object Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the result in calling object. An exception is raised if the calling object is complex, if Vec is not complex or
      if array borders are overrun/underrun.
</remarks>
*)
    function ImagPart(const Vec: TMtxVec; VecIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Power (integer exponent).</summary>
      
<remarks>Calculate the power ^(Exponent) for all caling object elements using the integer parameter Exponent.
      For non integer exponents, the <see cref="Power"/> and <see cref="PowerVec"/> methods can be used.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          a.IntPower(3);     //same as:
          a := IntPower(a,3);
          b.IntPower(a,3); //same as:
          b := IntPower(a,3);
      end;
      </code>
      </Example>

      <SeeAlso cref="Power"/>
      <SeeAlso cref="PowerVec"/>*)
    function IntPower(Exponent: Integer): TMtxVec; overload; 
    (*<summary>Calculate the power Base^(Exponent) for all Base object elements using the integer Exponent value
      and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties
      of calling object are adjusted automatically.
</remarks>
*)
    function IntPower(Base: TMtxVec; Exponent: Integer): TMtxVec; overload; 

    (*<summary>Calculate the inverse of calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);  // a = [1, 2, 3, 4]
          b.Inv(a,0.01); // b = [1.0, 0.5, 0.3333, 0.25]
          b := Inv(a,0.01);
      end;
      </code>
      </Example>*)
    function Inv(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of all calling object elements in-place.</summary>
      
<remarks>The computation occurs after first limiting the
      magnitude of each element by the lower bound of Threshold. The limiting operation is performed to avoid
      division by zero. Since Threshold represents a magnitude, it is always real and must always be positive.
      For complex versions, the magnitude of the input is limited, but the phase remains unchanged.
      Zero-valued input is assumed to have zero phase.
</remarks>
*)
    function Inv(Threshold: double): TMtxVec; overload; 
    (*<summary>Calculate the inverse of calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>Limit the magnitude of each element by the lower bound of Threshold. An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Inv(Threshold: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of all X object elements without the limiting operating.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      Does not compute matrix inverse. The limiting of the magnitude of each element by the lower bound of Threshold is left out.
</remarks>
*)
    function Inv(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse of X object elements [XIndex]..[XIndex+Len-1] without limiting  operating.</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1]. An exception is raised if X and calling object <see cref="Complex"/> property
      does not match or array borders are overrun/underrun.
</remarks>
*)
    function Inv(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of all X object elements anmd store the results to calling object elements.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling obhect are adjusted automatically. The computation occurs after first limiting the
      magnitude of each element by the lower bound of Threshold. The limiting operation is performed to avoid
      division by zero. Since Threshold represents a magnitude, it is always real and must always be positive.

      Note
        For complex versions, the magnitude of the input is limited, but the phase remains unchanged.
        Zero-valued input is assumed to have zero phase.
</remarks>
*)
    function Inv(const X: TMtxVec; Threshold: double): TMtxVec; overload; 
    (*<summary>Calculate the inverse of X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Limit the magnitude of each element by the lower bound of Threshold. Store the results in calling object elements
      [Index]..[Index+Len-1]. An exception is raised if X and calling object <see cref="Complex"/> property do not
      match or array borders are overrun/underrun.
</remarks>
*)
    function Inv(const X: TMtxVec; Threshold: double; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Converts elements from cartesian to polar coordinate form.</summary>
      
<remarks>Converts all calling object elements from cartesian to polar coordinate form, storing the magnitude (radius)
      component of corresponding elements in the AmpltVec and the phase (angle) component of corresponding elements in
      the PhaseVec. If you want to use this method then the calling matrix <see cref="Complex"/> property must be
      true. If this is not the case, an exception is raised. Size and <see cref="Complex"/> properties of AmpltVec and
      PhaseVec are set automatically.
</remarks>


      <Example>
      <code>
      var A,Amplt,Phase: Matrix;
      begin
            A.SetIt(2,2,True,[1,0, 2,0
                              2,0  4,1]);

            A.CartToPolar(Amplt,Phase);
      end;
      </code>
      </Example>

      <SeeAlso cref="PolarToCart"/>*)
    procedure CartToPolar(AmpltVec, PhaseVec: TMtxVec); overload; 
    (*<summary>Convert calling object elements [Index] to [Index+Len-1] from cartesian to polar form.</summary>
      
<remarks>Store the results in AmpltVec (radius values) and PhaseVec(phase values). Size and <see cref="Complex"/>
      properties of the calling Matrix must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>
      is True and array borders are overrun or underrun.
</remarks>
*)
    procedure CartToPolar(AmpltVec, PhaseVec: TMtxVec; AmpltIndex, PhaseIndex, Index, Len: integer); overload; 

    (*<summary>Copy object values.</summary>
      
<remarks>Copy each of Vec elements to the calling object. Size and <see cref="Complex"/>
      properties of the calling object are set implicitly to match Vec object.
</remarks>


      <Example>
      <code>
      var a,b,c: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);  // a = [1,2,3,4]
          b.Copy(a);                // b = [1,2,3,4]
          c.Copy(a,b);  //concatenate a and b and store in c = [1,2,3,4,1,2,3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Assign"/>*)
    function Copy(const Vec: TMtxVec): TMtxVec; overload; 

    (*<summary>Copy object values.</summary>
      
<remarks>Copy each of Src elements to the calling object. Size and <see cref="Complex"/>
      properties of the calling object are set implicitly to match Src object.
</remarks>


      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a,b,c;
          MtxVec.CreateIt(out a, out b, out c);
          try
          {
            a.SetIt(true,new double[] {1,2,3,4});  // a = [1,2,3,4] i.e 1+2i ; 3+4i
            b.Copy(a, mvSingle);                // convert to single precision
          }
          finally
          {
            MtxVec.FreeIt(ref a,ref b,ref c);
          }
        }
      }
      </code></example>

      <SeeAlso cref="Assign"/>*)
    function Copy(const Src: TMtxVec; const dstFloatPrecision: TMtxFloatPrecision): TMtxVec; overload; 

    (*<summary>Copy Vec elements [VecIndex]..[VecIndex+Len-1]  in the calling object
       elements [Index]..[Index+Len-1].</summary>
       
<remarks>Size and <see cref="Complex"/> properties must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>  is True
       and array borders are overrun or underrun.
</remarks>
*)
    function Copy(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Sets Matrix size to zero.</summary>
      
<remarks>Calling Clear sets <see cref="Length"/> property to 0 and <see cref="Complex"/>
      property to False.
</remarks>
*)
    procedure Clear;

    (*<summary>Saves the current value of ConditionCheck property and sets it to false.</summary>
      
<remarks>Saves the current value of <see cref="ConditionCheck"/> property and sets it to false.
      You can restore back to the original setting by calling <see cref="CondEnable"/> method.
</remarks>


      <SeeAlso cref="CondEnable"/>
      <SeeAlso cref="ConditionCheck"/>*)
    procedure CondDisable;
    (*<summary>Sets the ConditionCheck property to whatever it was before the CondDisable was used.</summary>
      
<remarks>Sets the <see cref="ConditionCheck"/> property to whatever it was before the <see cref="CondDisable"/> was used.
</remarks>


      <SeeAlso cref="CondDisable"/>
      <SeeAlso cref="ConditionCheck"/>*)
    procedure CondEnable;

    (*<summary>Conjugate.</summary>
      
<remarks>Conjugate all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var c: Matrix;
      begin
          c.SetIt(1,2,True,[1,2,3,4]);  // c = [1+2i, 3+4i]
          c.Conj;                   // c = [1-2i, 3-4i]
      end;
      </code>
      </Example>*)
    function Conj: TMtxVec; overload; 
    (*<summary>Conjugate calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Conj(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Conjugate each of Vec elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are set implicitly to match Vec Matrix.
</remarks>
*)
    function Conj(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Conjugate Vec elements Vec[VecIndex]..Vec[VecIndex+Len-1].</summary>
      
<remarks>Store them in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>
      is true and array borders are overrun.
</remarks>
*)
    function Conj(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Copies values from an array.</summary>
      
<remarks>Copies values from a complex array. The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>


      <SeeAlso cref="Copy"/>
      <SeeAlso cref="CopyTo"/>
      <SeeAlso cref="Round"/>
      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="CopyToArray"/>*)
    function CopyFromArray(const Src: TCplxArray): TMtxVec; overload; 
    (*<summary>Copies values from the Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
    object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TCplxArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from a real Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TDoubleArray): TMtxVec; overload; 
   (*<summary>Copies values from the double precision floating point Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
      object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed. If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TDoubleArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from a real single precision floating point Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TSingleArray): TMtxVec; overload; 
   (*<summary>Copies values from the single precision floating point Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
    object values [Index]..[Index+len-1].</summary>
    
<remarks>The size of the calling object is not changed.
    If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TSingleArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from an integer type Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TIntegerArray): TMtxVec; overload; 
    (*<summary>Copies values from a 4 byte signed integer type Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
    object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TIntegerArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Copies values from an 2 byte signed integer type Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: TSmallIntArray): TMtxVec; overload; 
    (*<summary>Copies values from a 2 byte signed integer type Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
    object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: TSmallIntArray; SrcIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from a 1 byte unsigned integer type Src array.</summary>
      
<remarks>The size and <see cref="Complex"/> properties of the
      calling object are set implicitely.
</remarks>
*)
    function CopyFromArray(const Src: Math387.TByteArray): TMtxVec; overload;
    (*<summary>Copies values from a 1 byte unsigned integer type Src array [SrcIndex]..[SrcIndex+Len-1] to the calling
    object values [Index]..[Index+len-1].</summary>
      
<remarks>The size of the calling object is not changed.
      If the array border are overrun an exception will be raised.
</remarks>
*)
    function CopyFromArray(const Src: Math387.TByteArray; SrcIndex,Index,Len: integer): TMtxVec; overload;

    (*<summary>Copy values to an array.</summary>
      
<remarks>Copy complex values to Dst array. The size of the array is set automatically.
      If the calling object is not complex an exception will be raised.
</remarks>


      <SeeAlso cref="Copy"/>
      <SeeAlso cref="CopyTo"/>
      <SeeAlso cref="Round"/>
      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="CopyFromArray"/>*)
    function CopyToArray(var Dst: TCplxArray): TMtxVec; overload; 
    (*<summary>Copy complex values from the calling object [Index]..[Index+len-1] to the Dst
       array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
</remarks>
*)
    function CopyToArray(var Dst: TCplxArray; DstIndex, Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copy values to Dst array.</summary>
      
<remarks>The size of the array is set automatically. If the calling
      object is complex, the size of the Dst array will be equal to 2*<see cref="Length"/>.
      If the calling object is not complex an exception will be raised.
</remarks>
*)
    function CopyToArray(var Dst: TDoubleArray): TMtxVec; overload; 
    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed. If the calling object is complex, the Index and Len parameters define the number of
       complex elements.
</remarks>
*)
    function CopyToArray(var Dst: TDoubleArray; DstIndex, Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies the calling object data to an array of single precision floating point data.</summary>
      
<remarks>Any values exceeding the range are clipped.
</remarks>
*)
    function CopyToArray(var Dst: TSingleArray): TMtxVec; overload; 
    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       single precision floating point array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements.
</remarks>
*)
    function CopyToArray(var Dst: TSingleArray; DstIndex, Index,Len: integer): TMtxVec; overload; 

    (*<summary>Copies values from the calling object to the Dst array and converts floating point data to integer numbers.</summary>
       
<remarks>The rounding method used is specified with the Rounding parameter.
</remarks>
*)
    function CopyToArray(var Dst: TIntegerArray; Rounding: TRounding): TMtxVec; overload; 

    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       integer array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements. The method converts floating point values to integer.
       Values exceeding the range of the integer type are clipped.
</remarks>
*)
    function CopyToArray(var Dst: TIntegerArray; Rounding: TRounding; DstIndex, Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from the calling object to the Dst array and converts floating point data
       to 2 byte signed integer numbers.</summary>
       
<remarks>The rounding method used is specified with the Rounding parameter.
</remarks>
*)
    function CopyToArray(var Dst: TSmallIntArray; Rounding: TRounding): TMtxVec; overload; 
    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       integer array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements. The method converts floating point values to integers.
       Values exceeding the range of a 2 byte signed integer type are clipped.
</remarks>
*)
    function CopyToArray(var Dst: TSmallIntArray; Rounding: TRounding; DstIndex, Index,Len: integer): TMtxVec; overload; 
    (*<summary>Copies values from the calling object to the Dst array and converts floating point data
       to 1 byte unsigned integer numbers.</summary>
       
<remarks>The rounding method used is specified with the Rounding parameter.
</remarks>
*)
    function CopyToArray(var Dst: Math387.TByteArray; Rounding: TRounding): TMtxVec; overload; 

    (*<summary>Copy real or complex values from the calling object [Index]..[Index+len-1] to the Dst
       integer array at positions [DstIndex]...[DstIndex+Len-1].</summary>
       
<remarks>The size of the Dst array is not changed.
       If the calling object is complex, the Index and Len parameters define the number of
       complex elements. The method converts floating point values to integers.
       Values exceeding the range of 1 byte unsigned integer type are clipped.
</remarks>
*)
    function CopyToArray(var Dst: Math387.TByteArray; Rounding: TRounding; DstIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Split complex calling object in real and imaginary part.</summary>
      
<remarks>Split calling object into real and imaginary components. Store all real components in ReVec and
      all imaginary components in ImVec. Size and <see cref="Complex"/> properties of ReVec and ImVec
      are set implicitly to match with the calling Matrix. An execption is raised if calling object is not complex.
</remarks>


      <Example>
      <code>
      var a,b,c: Matrix;
      begin
          a.SetIt(1,2,True,[1,-2,3,4]);
          a.CplxToReal(b,c);
      end;
      </code>
      </Example>

      <SeeAlso cref="RealToCplx"/>*)
    procedure CplxToReal(ReVec, ImVec: TMtxVec); overload; 
    (*<summary>Split calling object elements [Index]..[Index+Len-1] into real and imaginary components.</summary>
      
<remarks>Store real components in ReVec elements [ReIndex]..[ReIndex+Len-1] and imaginary components in ImVec elements
      [ImIndex]..[ImIndex+Len-1]. Size and <see cref="Complex"/> properties must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/>  is true and array borders are overrun or underrun.
</remarks>
*)
    procedure CplxToReal(ReVec, ImVec: TMtxVec; ReIndex, ImIndex, Index, Len: integer); overload; 

    (*<summary>Extends a real object to a complex object.</summary>
      
<remarks>Extend the calling object to complex Matrix. After the calling of ExtendToComplex the imaginary part becomes the same as real part if Zeros
      is false. If Zeros is true the imaginary part is set to zero. The use of the in-place version of the method is discouraged because
      it requires 3*N copy operations, while the not-in-place version requires only 2*N copy operations.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          b.ExtendToComplex(a,True);
      end;
      </code>
      </Example>

      <SeeAlso cref="RealToCplx"/>
      <SeeAlso cref="ImagPart"/>
      <SeeAlso cref="RealPart"/>*)
    function ExtendToComplex(Zeros: boolean = True): TMtxVec; overload; 
    (*<summary>Extend Vec object to complex calling object.</summary>
      
<remarks>If Zeros is true then the calling Matrix imaginary part is set to zero, otherwise
      the calling object imaginary part is the same as calling object real part.
</remarks>
*)
    function ExtendToComplex(const Src: TMtxVec; Zeros: Boolean): TMtxVec; overload; 
    (*<summary>Converts the source to complex.</summary>
      
<remarks>Converts the source to complex by setting the imaginary part to either zero (zeros = True)
      or same as real (zeros = false). Does not set size of the calling Matrix.
      If there is not sufficient space available to store the result an exception
      will be raised.
</remarks>
*)
    function ExtendToComplex(const Src: TMtxVec; Zeros: Boolean; SrcIndex,DstIndex, Len: integer): TMtxVec; overload; 

    (*<summary>Sets angle in [-2Pi,2Pi].</summary>
     <returns>ThetaRad within [-2Pi,2Pi] interval.</returns>
     
<remarks>Calling this function prior to passing the value to trigonometric functions can significantly improve numerical accuracy.
     For arguments larger than 10000, the computation of sine/cosine is speeded up by about 10x
     for SSE2/SSE3. The performance gains for classic FPU math are also significant.
     The cost of this function call is approx 30% of the cost of the sine function.

     It is important to mention that the sine/cosine appear within many other functions especially
     complex versions of trigonometric functions. FixAngle method is never used
     implicitely within TMtxVec methods. To achieve maximum performance make
     sure that the arguments passed to complex trigonometric functions are "small"
     or scaled down.

     Note
      The Matrix must be real.
</remarks>
*)
    function FixAngle: TMtxVec; overload;
    (*<summary>FixAngle for calling object complex elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is True or if array borders are overrun/underrun.
</remarks>
*)
    function FixAngle(Index,Len: integer): TMtxVec;  overload;
    (*<summary>Sets angle in [-2Pi,2Pi] for all Src elements.</summary>
      
<remarks>Store the results in the calling object.
      Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the Src object.
</remarks>
*)
    function FixAngle(const Src: TMtxVec): TMtxVec;  overload;
    (*<summary>Sets angle in [-2Pi,2Pi] for Src elements [SrcIndex]..[SrcIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties
      of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function FixAngle(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec;  overload;

    (*<summary>Rounds towards negative infinity.</summary>
      
<remarks>Rounds all calling object elements towards negative infinity in-place.

      <code>
      Floor(-2.8) = -3
      Floor(2.8) = 2
      Floor(-1.0) = -1
      </code>
</remarks>
*)
    function Floor: TMtxVec; overload;
    (*<summary>Rounds calling object elements [Index]..[Index+Len-1] towards negative infinity in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Floor(Index,Len: integer): TMtxVec;  overload;
    (*<summary>Rounds all Src object elements towards negative infinity and stores the result in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted
      automatically.
</remarks>
*)
    function Floor(const Src: TMtxVec): TMtxVec;  overload;
    (*<summary>Rounds Src object elements [SrcIndex]..[SrcIndex+Len-1] towards negative infinity.</summary>
      
<remarks>Sores the result in the calling object elements [Index]..[Index+Len-1]
      Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Floor(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec;  overload;

    (*<summary>A complex exponential e^(j*W).</summary>
      
<remarks>Calculate the calling object complex exponential in-place. An exception is raised if
      calling object is complex. If object is complex, you should use the <see cref="Exp"/> method instead.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          a.Expj;   // a = [e^i, e^2i, e^3i, e^4i]
      end;
      </code>
      </Example>

      <SeeAlso cref="Exp"/>*)
    function Expj: TMtxVec; overload; 
    (*<summary>Calculate the e^(j*W), a complex exponential.</summary>
      
<remarks>Omega must be a real object. If omega is complex, then use the <see cref="Exp"/> method.
</remarks>
*)
    function Expj(Omega: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the complex exponential for Omega elements [OmegaIndex]..[OmegaIndex+Len-1].</summary>
      
<remarks>Store the results in calling object elemets [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling Matrix must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>
      is True and array borders are overrun or underrun.
</remarks>
*)
    function Expj(Omega: TMtxVec; OmegaIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Finds a match for X in object values.</summary>
      
<remarks>Compare real value X with all calling object elements and return the Index of last matched element.
      If no matching elements are found, the result is -1.

      Note
        This method also supports the NAN and INF search.
</remarks>


      <Example>
      <code>
      var a: Matrix;
        ind: Integer;
      begin
          a.SetIt(False,[2,5,1,6]);
          ind := a.Find(1.0); // returns 2 (the arrays are zero based)
      end;
      </code>
      </Example>*)
    function Find(const X: double): integer; overload; 
    (*<summary>Compare complex value X with all calling object elements.</summary>
      <returns>the Index of last matched element. If no matching elements are
       found, the result is -1.</returns>
       
<remarks>An exception is raised if calling object <see cref="Complex"/> property is false.
</remarks>
*)
    function Find(const X: TCplx): integer; overload; 

    (*<summary>Fractional part of values.</summary>
      
<remarks>Calculates the fractional part for all object values in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
        ind: Integer;
      begin
          a.SetIt(2,2,False,[1,5.5,-1.6,6]); // a = [1, 5.5, -1.6, 6]
          a.Frac;  // a = [0, 0.5, -0.6, 0]
      end;
      </code>
      </Example>

      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="Round"/>*)
    function Frac: TMtxVec; overload; 
    (*<summary>Calculates the fractional part for all X object values and stores the result in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Frac(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculates the fractional part for calling object elements [Index]..[Index+Len-1] in-place</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Frac(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Calculates the fractional part for X object elements [XIndex]..[XIndex+Len-1] and stores the result in calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Frac(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>First element in object Values array.</summary>
      <returns>first real element in object Values array.</returns>

      <SeeAlso cref="Last"/>
      <SeeAlso cref="Firstc"/>*)
    property First: double read get_First;

    (*<summary>First element in object CValues array.</summary>
      <returns>first complex element in object CValues array. An exception is raised if calling object
      <see cref="Complex"/> property is false.</returns>

      <SeeAlso cref="Lastc"/>
      <SeeAlso cref="First"/>*)
    property Firstc: TCplx read get_Firstc;

    (*<summary>Flips the real and imaginary part of complex numbers.</summary>
      
<remarks>Flips the real and imaginary part of complex numbers for all calling object elements in-place.
</remarks>


      <SeeAlso cref="FlipConj"/>*)
    function Flip: TMtxVec; overload; 
    (*<summary>Flips the real and imaginary part of complex numbers for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Flip(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Flips the real and imaginary part of complex numbers for all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Flip(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Flips the real and imaginary part of complex numbers for X object elements [XIndex]..[XIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]
      An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Flip(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Flips the real and imaginary part of complex numbers and conjugates the complex numbers.</summary>
      
<remarks>Performs the following operation:
      <code>
      a + bi ==> b - ai
      </code>
      Method flips the real and imaginary part and conjugates calling object complex elements in-place.
</remarks>


      <SeeAlso cref="Flip"/>
      <SeeAlso cref="Conj"/>*)
    function FlipConj: TMtxVec; overload; 
    (*<summary>Flip calling object complex elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is false or if array borders are overrun/underrun.
</remarks>
*)
    function FlipConj(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Flip all X object complex elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function FlipConj(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Flip X object complex elements [XIndex]..[XIndex+Len-1] and store the results in calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property      is false or if array borders are overrun/underrun.
</remarks>
*)
    function FlipConj(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse of square root 1/(v)^1/2.</summary>
      
<remarks>Calculate the inverse square root (1/(element)^(1/2)) of all calling object elements in-place.
</remarks>


      <Example>
      <code>
      v.SetIt(false,[1,16]);
      v.InvSqrt; // returns [1,0.25]
      </code>
      </Example>

      <SeeAlso cref="Sqrt"/>*)
    function InvSqrt: TMtxVec; overload; 
    (*<summary>Calculate the inverse of square root for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function InvSqrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of square root for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function InvSqrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse of square root for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function InvSqrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse of cube root 1/(v)^1/3.</summary>
      
<remarks>Calculate the inverse cube root (1/(element)^(1/3)) of all calling object elements in-place.
</remarks>


      <Example>
      <code>
      v.SetIt(false,[1,8]);
      v.InvCbrt; // returns [1,0.5]
      </code>
      </Example>

      <SeeAlso cref="Cbrt"/>*)
    function InvCbrt: TMtxVec; overload; 
    (*<summary>Calculate the inverse of cube root for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function InvCbrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the inverse of cube root for all X elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function InvCbrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the inverse of cube root for X elements [XIndex]..[XIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function InvCbrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The Reminder after division X/Y.</summary>
      
<remarks>Calculates reminder after division according to formula: X[i]-y[i]*Trunc(X[i]/y[i]). The results will be saved to the calling Matrix.
      X and Y must be a real and have the same length. Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>


      <Example>
      <code>
      var a,b,c: Matrix;
      begin
          a.SetIt(1,4,false,[0,1,10,-1,-10]); // a = [0, 1, 10,    -1, -10];
          b.SetIt(1,4,false,[0,1,PI,-1,-PI]); // b = [0, 1, PI,    -1, -PI];
          c.Rem(a,b);                     // c = [0, 0, 0.5752, 0, -0.5752]
      end;
      </code>
      </Example>*)
    function Rem(const X, Y: TMtxVec): TMtxVec; overload;
    (*<summary>Calculates reminder after division X/Y according to formula: z[i] = X[xi]-y[yi]*Trunc(X[xi]/y[yi]), where i in [Index..Index+Len], xi in [XIndex..XIndex+Len], yi in [YIndex..YIndex+Len].</summary>
      
<remarks>The results will be saved to the calling Matrix. X must be a real. An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Rem(const X, Y: TMtxVec; XIndex, YIndex, Index, Len: integer): TMtxVec; overload;
    (*<summary>Calculates reminder after division X/Y according to formula X[i]-y*Trunc(X[i]/y). X must be a real. The results will be saved to the calling Matrix.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling Matrix are set implicitly to match the X object.
</remarks>
*)
    function Rem(const X: TMtxVec; Y: double): TMtxVec; overload;
    (*<summary>Calculates reminder after division X/Y according to formula: z[i] = X[xi]-y*Trunc(X[xi]/y), where i in [Index..Index+Len], xi in [XIndex..XIndex+Len].</summary>
      
<remarks>X must be a real. The results will be saved to the calling Matrix. An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Rem(const X: TMtxVec; Y: double; XIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Magnitude.</summary>
      
<remarks>Calculate the magnitude for all calling object elements in-place.
      This method has the same function as the <see cref="Abs"/> method.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,4,false,[1,-2,3,4]); // a = [1,-2, 3,4]
          a.Mag;      // a = [1, 2, 3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Abs"/>
      <SeeAlso cref="PhaseSpectrum"/>*)
    function Mag: TMtxVec; overload; 
    (*<summary>Calculate the magnitude for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
</remarks>
*)
    function Mag(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the magnitude for all X elements and store the results in the calling object elements.</summary>
      
<remarks>Size and and <see cref="Complex"/> properties of the calling Matrix are set
      implicitly to match Vec Matrix.
</remarks>
*)
    function Mag(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the magnitude for X elements [XIndex]..[XIndex+Len-1] and store the results in the calling
      object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and array
      borders are overrun.
</remarks>
*)
    function Mag(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Multiply object elements with Value.</summary>
      
<remarks>Multiply all calling object elements with Value in-place.
      This method is the same as the <see cref="Mul"/> method overloads
      multiplying with Matrix elements with a scalar.
</remarks>


      <Example>
      <code>
      var v: Matrix;
      begin
          v.SetIt(1,3,false,[2,3,5]);  // v = [2,3,5]
          v.Scale(3); // v = [6,9,15]
      end;
      </code>
      </Example>

      <SeeAlso cref="Add"/>*)
    function Scale(Factor: double): TMtxVec; overload;  
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Scale(Factor: double; Index, Len: integer): TMtxVec; overload;  
    (*<summary>Multiply all calling object elements with a complex Value in-place.</summary>*)
    function Scale(Factor: TCplx): TMtxVec; overload;  
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with complex Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Scale(Factor: TCplx; Index, Len: integer): TMtxVec; overload;  

    (*<summary>Scatter object elements.</summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      according to the IndexType, Increment and Offset parameters.

      The Indexes Matrix is used only if IndexType is either indVector
      or indMask. If IndexType is indVector, the values from the Indexes
      object denote the Index positions in the calling object to which
      the values should be copied from the Src.
      The Indexes Matrix must have the indexes stored in the IValues
      array. The IValues integer arrays points the same memory as Values
      array.

      The Increment and Offset parameters are used only if TIndexType
      is indIncrement. They define the target offset and a fixed
      step (increment) between calling Matrix elements.

      If IndexType is indMaks the Indexes object must have the same
      size as the Src object. The routine will copy only those elements
      from the Src to the calling object, for which there is a 1 at the coresponding
      Index in the Indexes object.The elements in the calling object are stored consecutively.

      See the <see cref="Vector.Gather"/> method to see how to perform gathering.
      The performance of the CPU heavily depends on the assumption that elements are stored at consecutive memory locations.
      If it is neccessary to apply a set of operations only to elements at specific indexes, performance-wise it can prove to be
      very helpfull, if the elements are gathered first.
</remarks>


      <SeeAlso cref="Vector.Gather"/>*)
    function Scatter(const Src: TMtxVec; const Indexes: TVecInt =nil; IndexType: TIndexType = indVector; Increment: integer = 1; Offset: integer = 0): TMtxVec; overload; 

    (*<summary>Scatter object elements.</summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      at indices: Increment*i + Offset
</remarks>
*)
    function ScatterByIncr(const Src: TMtxVec; Increment: integer = 1; Offset: integer = 0): TMtxVec; overload; 

    (*<summary>Scatter object elements.</summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      at indices stored in the Indexes parameter.
</remarks>
*)
    function ScatterByIndexes(const Src: TMtxVec; const Indexes: TVecInt): TMtxVec; overload; 

    (*<summary>Scatter object elements. </summary>
      
<remarks>Scatter the elements of the Src and store them in the calling object
      at indices set to 1 in the Mask parameter.
</remarks>
*)
    function ScatterByMask(const Src: TMtxVec; const Mask: TVecInt; allow_resizing: boolean = False): TMtxVec; overload; 

    (*<summary>Copies those values from MaskVec, at which aMask is different from 0.</summary>*)
    function Mask(const MaskVec: TMtxVec; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Copies those values from MaskVecNot, at which aMask is equal to 0.</summary>*)
    function MaskNot(const MaskVecNot: TMtxVec; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is different from 0.</summary>*)
    function Mask(const Value: double; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is equal to 0.</summary>*)
    function MaskNot(const Value: double; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is different from 0.</summary>*)
    function Mask(const Value: TCplx; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Assigns Value at indexes of the calling object, at which aMask is equal to 0.</summary>*)
    function MaskNot(const Value: TCplx; const aMask: TMtxVecInt): TMtxVec; overload;

    (*<summary>Sets object values.</summary>
      
<remarks>Set object values. Method call does not change object's size or <see cref="Complex"/> property, but
      it does check for array overrun. The elements of A array are copied to the calling object elements, starting at Index.
      If the calling object is complex, then real parts of complex numbers are on even (0,2,4..) and imaginary parts
      on odd indexes.(1,3,5,..).
</remarks>
*)
    function SetIt(Index: integer; const A: array of double): TMtxVec; overload;
    (*<summary>The elements of A array, starting at AIndex, are copied to the calling object elements, starting at Index.</summary>
      
<remarks>If the calling object is complex, then real parts of complex numbers in the A array are on even (0,2,4..) and imaginary parts
      on odd indexes.(1,3,5,..).
</remarks>
*)
    function SetIt(Index, AIndex, Len: integer;  const A: array of double): TMtxVec; overload;

    (*<summary>Sets object values (single).</summary>
      
<remarks>The single elements of A array are copied to the calling object elements [Index]..[Index+Length(A)-1].
      An exception is raised if calling object array borders are overrun/underrun.

      Note
        Use this method for integer array only.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetInteger"/>
      <SeeAlso cref="SetDouble"/>*)
    function SetSingle(Index: integer; const A: array of single): TMtxVec; overload;
    function SetSingle(Index: integer; aIndex, Len: integer; const A: array of single): TMtxVec; overload;

    (*<summary>Sets object values (double).</summary>
      
<remarks>The double elements of A array are copied to the calling object elements [Index]..[Index+Length(A)-1].
      An exception is raised if calling object array borders are overrun/underrun.

      Note
        Use this method for integer array only.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetInteger"/>
      <SeeAlso cref="SetSingle"/>*)
    function SetDouble(Index: integer; const A: array of double): TMtxVec; overload;
    function SetDouble(Index: integer; aIndex, Len: integer; const A: array of double): TMtxVec; overload;

    (*<summary>Sets object values (integer).</summary>
      
<remarks>The integer elements of A array are copied to the calling object elements [Index]..[Index+Length(A)-1]. An
      exception is raised if calling object array borders are overrun/underrun.

      Note
        Use this method for integer array only.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetDouble"/>
      <SeeAlso cref="SetSingle"/>*)
    function SetInteger(Index: integer; const A: array of Integer): TMtxVec; overload;
    function SetInteger(Index: integer; aIndex, Len: integer; const A: array of Integer): TMtxVec; overload;

    (*<summary>Square.</summary>
      
<remarks>Calculate the square of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(True,[1,2,3,4]);
          a.Sqr; // a=[1,4,9,16]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sqrt"/>
      <SeeAlso cref="Power"/>*)
    function Sqr: TMtxVec; overload; 
    (*<summary>Calculate the square of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqr(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the square of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sqr(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the square of X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are not changed.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqr(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Square root.</summary>
      
<remarks>Calculate the square root of all caling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(2,2,False,[1,4,9,16]);
          a.Sqrt; // a= [1, 2,
                 //     3, 4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sqr"/>*)
    function Sqrt: TMtxVec; overload; 
    (*<summary>Calculate the square root of calling object elements [Index]...[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqrt(Index, Len: integer): TMtxVec; overload; 
    (*<summary>Calculate the square root of all X object elements and store the results in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function Sqrt(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the square root of X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are not changed. An exception is raised if array borders are overrun.
</remarks>
*)
    function Sqrt(const X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Last complex element in object CValues array.</summary>
      <returns>last complex element in object CValues array.</returns>

      <SeeAlso cref="Firstc"/>
      <SeeAlso cref="Last"/>*)
    property Lastc: TCplx read get_Lastc;
    (*<summary>Last element in object Values array.</summary>

      <SeeAlso cref="First"/>
      <SeeAlso cref="Lastc"/>*)
    property Last: double read get_Last;

    (*<summary>Log base N.</summary>
      
<remarks>Calculate the log base N for all calling object elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,4,False,[1,2,3,4]); // a = [1,2,3,4]
          a.LogN(10.0);  // log base 10, the slow way a = [Log10(1), Log10(2),...]
      end;
      </code>
      </Example>

      <SeeAlso cref="Power"/>*)
    function LogN(N: double): TMtxVec; overload; 
    (*<summary>Calculate the log base N of calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function LogN(N: double; Index, Len: integer):TMtxVec; overload; 
    (*<summary>Calculate the log base N of all X object elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function LogN(N: double; X: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculate the log base N of X object elements [XIndex]..[XIndex+Len-1]. The results are stored
      in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are not changed. An exception is raised if array borders are overrun.
</remarks>
*)
    function LogN(N: double;const  X: TMtxVec; XIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Multiply object elements with Value.</summary>
      
<remarks>Multiply all calling object elements with Value in-place.
</remarks>


      <Example>
      <code>
      var v: Vector;
      begin
       v.SetIt(1,3,false,[2,3,5]);  // v = [2,3,5]
       v := v*3; // v = [6,9,15]
      end;
      </code>
      </Example>

      <SeeAlso cref="Add"/>*)
    function Mul(const Value: double): TMtxVec; overload; 
    (*<summary>Multiply all calling object elements with complex Value in-place.</summary>*)
    function Mul(const Value: TCplx): TMtxVec; overload; 
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Mul(const Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with complex Value in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Mul(const Value: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Multiply each element of Vec with Value and store the result in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Multiply each element of Vec with complex Value and store the result in the calling object.</summary>
      
<remarks>Size of the calling object is set automatically.
      <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: TCplx): TMtxVec; overload; 
    (*<summary>Multiply Vec elements [VecIndex]..[VecIndex+Len-1] with Value and store the
      result in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size of the calling object is not changed. An exception is raised if array borders are overrun or underrun.
      <see cref="Complex"/> propertiy of the calling object is set implicitly.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Multiply Vec elements [VecIndex]..[VecIndex+Len-1] with complex Value and store
      the result in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size of the calling object is not changed. An exception is raised if array borders are overrun or underrun.
      <see cref="Complex"/> propertiy of the calling object is set to True.
</remarks>
*)
    function Mul(const Vec: TMtxVec; Value: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Multiply elements by imaginary unit.</summary>
      
<remarks>Multiply calling Matrix elements with "I".
</remarks>
*)
    function MulI: TMtxVec; overload; 
    (*<summary>Multipy calling object elements [Index]..[Index+Len-1] with I in-place.</summary>*)
    function MulI(Index: integer; Len: integer): TMtxVec; overload; 
    (*<summary>Multiply X elements with I and store the result in the calling object.</summary>*)
    function MulI(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Multipy X elements [XIndex]..[XIndex+Len-1] with I.</summary>
      
<remarks>Store the result in the calling object at locations [Index]..[Index+Len-1].
</remarks>
*)
    function MulI(const X: TMtxVec; XIndex: integer; Index: integer; Len: integer): TMtxVec; overload; 

    (*<summary>Normalize data.</summary>
      
<remarks>Normalizes values in the calling object by subtracting a constant Offset from Elements and dividing the result by constant Factor:

      <IMG name="TVec21"/>

      The results are stored in calling object. Use this method if you want to do a multiply and add (scale and offset) operations in a single method call.
</remarks>

      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a;
          MtxVec.CreateIt(out a);
          try
          {
            a.SetIt(false,new double[] {1,2,3,4});  // a = [1,2,3,4]
            a.Normalize(2,3);
          }
          finally
          {
            MtxVec.FreeIt(ref a);
          }
        }
      }
      </code></example>

      <SeeAlso cref="TDenseMtxVec.Offset"/>
      <SeeAlso cref="Scale"/>*)
    function Normalize(const SubOffset, DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize by subtracting a complex constant SubOffset from Vec elements and dividing the result by complex constant DivFactor.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised, if object is complex.
</remarks>
*)
    function Normalize(const SubOffset, DivFactor: TCplx): TMtxVec; overload; 
    (*<summary>Normalize objects complex values [Index]..[Index+Len-1] by subtracting a complex constant SubOffset from Vec elements and dividing the result by complex constant DivFactor.</summary>
       
<remarks>An exception is raised, if object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const SubOffset, DivFactor: TCplx; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize object values [Index]..[Index+Len-1] by subtracting a real constant SubOffset from Vec elements and dividing the result by
      complex constant DivFactor.</summary>
      
<remarks>Store the results in calling vector values [Index]..[Index+Len-1]. An exception
      is raised, if Vec or calling object is complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const SubOffset, DivFactor: double; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize object by subtracting a complex constant SubOffset from elements and dividing the result by
      real constant DivFactor.</summary>  
<remarks>An exception is raised, if object is not complex.
</remarks>
*)
    function Normalize(const SubOffset: TCplx; const DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize objects complex values [Index]..[Index+Len-1] by subtracting a complex constant SubOffset from elements and dividing the result by
      real constant DivFactor.</summary>
      
<remarks>Store the results in calling vector complex values [Index]..[Index+Len-1]. An exception
      is raised, if the calling object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const SubOffset: TCplx; const DivFactor: double; Index,Len: integer): TMtxVec; overload; 

    (*<summary>Normalize object.</summary>
      
<remarks>Normalizes Vec object by subtracting a constant Offset from Vec elements and dividing the result by constant Factor:

      <IMG name="TVec21"/>

      The results are stored in calling object.

      Note
        Use this method if you want to do a multiply and add (scale and offset) operations
        in a single method call.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          b.Normalize(a,2,3);
      end;
      </code>
      </Example>

      <SeeAlso cref="Offset"/>
      <SeeAlso cref="Scale"/>*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize Vec object by subtracting a complex constant SubOffset from Vec elements and dividing the result by
      complex constant DivFactor.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Vec is complex.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: TCplx): TMtxVec; overload; 
    (*<summary>Normalize Vec object complex values [VecIndex]..[VecIndex+Len-1] by subtracting a complex constant SubOffset from Vec elements and dividing the result by complex constant DivFactor.</summary>
      
<remarks>Store the results in calling Matrix complex values [Index]..[Index+Len-1]. An exception
      is raised if Vec or calling object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: TCplx; VecIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize Vec object values [VecIndex]..[VecIndex+Len-1] by subtracting a real constant SubOffset from Vec elements and dividing the result by
      complex constant DivFactor.</summary>
      
<remarks>Store the results in calling Matrix values [Index]..[Index+Len-1]. An exception
      is raised if Vec or calling object is complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset, DivFactor: double; VecIndex,Index,Len: integer): TMtxVec; overload; 
    (*<summary>Normalize Vec object by subtracting a complex constant SubOffset from Vec elements and dividing the result by
      real constant DivFactor.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Vec is complex.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset: TCplx; DivFactor: double): TMtxVec; overload; 
    (*<summary>Normalize Vec object complex values [VecIndex]..[VecIndex+Len-1] by subtracting a complex constant SubOffset from Vec elements and dividing the result by
      real constant DivFactor.</summary>
      
<remarks>Store the results in calling Matrix complex values [Index]..[Index+Len-1]. An exception
      is raised if Vec or calling object is not complex or array borders are overrun/underrun.
</remarks>
*)
    function Normalize(const Vec: TMtxVec; SubOffset: TCplx; DivFactor: double; VecIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Converts the polar magnitude/phase pairs to cartesian pairs.</summary>
      
<remarks>Convert all AmpltVec and PhaseVec elements (combined) from polar to cartesian form. If AmpltVec and PhaseVec size is not the
      same, an exeption is raised. The results are stored as complex numbers (X=Re, y=Im) in the calling
      object.  Size and <see cref="Complex"/> properties of the calling object are set implicitly to
      match AmpltVec and PhaseVec objects.
</remarks>


      <Example>
      <code>
      var a,b,c: Matrix;
      begin
          a.SetIt(1,4,false,[1,2,3,4]);  // a = [1,2,3, 4] //magnitude
          b.SetIt(1,4,false,[1,0,1,-1]); // b = [1,0,1,-1] /phase
          c.PolarToCart(a,b); // result stored in c = projections to Re and Im axis
      end;
      </code>
      </Example>

      <SeeAlso cref="CartToPolar"/>*)
    function PolarToCart(AmpltVec, PhaseVec: TMtxVec): TMtxVec; overload; 
    (*<summary>Convert  AmpltVec elements [AIndex]..[AIndex+Len-1] and PhaseVec elements [PIndex]..[PIndex+Len-1] from polar form
      (radius,angle) to cartesian form (X,y).</summary>
      
<remarks>The results are stored as complex numbers (X=Re, y=Im) in the calling
      object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the calling
      object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun/underrun.
</remarks>
*)
    function PolarToCart(AmpltVec, PhaseVec: TMtxVec; AIndex, PIndex,Index, Len: integer): TMtxVec; overload; 

    (*<summary>Raises base object elements to any power.</summary>
      
<remarks>Raises Base calling object elements to any power. The <see cref="IntPower"/> is faster, if Exponent is an integer.
      Real valued power can handle only positive Exponent. <see cref="IntPower"/> can handle negative exponent also.

      Note
        To compute a power to the negative exponent in general case or when the base is negative,
        use the complex version of the function.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          a.Power(1.2);
      end;
      </code>
      </Example>

      <SeeAlso cref="IntPower"/>
      <SeeAlso cref="PowerVec"/>*)
    function Power(Exponent: double): TMtxVec; overload; 
    (*<summary>Raises all calling Matrix elements to complex power Exponent in-place.</summary>
       
<remarks>If the calling Matrix is real and has negative elements, the result will be NAN
       at those entries. To obtain a valid result in this case, extend the calling
       Matrix to complex with <see cref="ExtendToComplex"/> method. In all real/complex
       combinations, the Power method will not automatically assume that a number is complex
       to speed up the computation. Alternatively the user can of course always
       convert the real numbers to complex before passing them to the Power routine.
</remarks>
*)
    function Power(Exponent: TCplx): TMtxVec; overload; 

    (*<summary>The phase angles (spectrum) of object elements.</summary>
      
<remarks>Calculates the phase angles (spectrum) of all Vec object elements. Phase values are returned in radians and are in the range
      [-PI,PI]. Size and <see cref="Complex"/> properties of the calling
      object are set implicitly to match Vec object. The phase angles are calculated from the following equation:

      <IMG name="TVec23"/>
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);  // a = [1 + 2i, 3 - 4i]
          b.PhaseSpectrum(a);  // b = [arctan2(1,2), arctan2(3,-4)];
      end;
      </code>
      </Example>

      <SeeAlso cref="PowerSpectrum"/>
      <SeeAlso cref="ArcTan2"/>*)
    function PhaseSpectrum(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculates the power spectrum from the Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1]. An exception is raised
      if array borders are overrun/underrun.
</remarks>
*)
    function PhaseSpectrum(const Vec: TMtxVec; VecIndex, Index,Len: integer): TMtxVec; overload; 

    (*<summary>The power spectrum from object complex values.</summary>
      
<remarks>Calculates the power spectrum from the Vec object complex values and stores the results (power spectrum)
      in the real calling object. Size and <see cref="Complex"/> properties of the calling object are set
      implicitly to match Vec object. The spectrum elements are squares of the magnitudes of the complex input elements:

      <IMG SRC="Tvec22"/>
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,-4]); // a = [1 + 2i, 3 - 4i]
          b.PowerSpectrum(a);   // b = [1*1 + 2*2, 3*3+(-4)*(-4)]
      end;
      </code>
      </Example>

      <SeeAlso cref="PhaseSpectrum"/>*)
    function PowerSpectrum(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Calculates the power spectrum from the Vec complex elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in calling object real elements [Index]..[Index+Len-1]. An exception is raised
      if calling object <see cref="Complex"/> property is true or if array borders are overrun/underrun.
</remarks>
*)
    function PowerSpectrum(const Vec: TMtxVec; VecIndex, Index,Len: integer): TMtxVec; overload; 

    (*<summary>Raises base elements to exponent power.</summary>
      
<remarks>Raises Base value to Exponent object values powers and store the results to calling object values.
      Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>


      <SeeAlso cref="PowerVec"/>*)
    function Power(Base: double; Exponent: TMtxVec): TMtxVec; overload; 
    (*<summary>Raises Base complex value to Exponent object values powers and store the results to calling object values.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Power(Base: TCplx; Exponent: TMtxVec): TMtxVec; overload; 
    (*<summary>Raises each of Base object elements to corresponding power.</summary>
      
<remarks>Store the result in Exponenet elements:

      <code>
      Power[i] = Base[i]^Exponent[i]
      </code>

      Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Base and Exponent sizes do not match.
</remarks>
*)
    function Power(Base, Exponent: TMtxVec): TMtxVec; overload; 
    (*<summary>Raises each of the Base object elements to complex Exponent power.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Power(Base: TMtxVec; Exponent: TCplx): TMtxVec; overload; 
    (*<summary>Raises each of the Base object elements to real Exponent power.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Power(Base: TMtxVec; Exponent: double): TMtxVec; overload; 

    (*<summary>Raises Base object elements to Exponent object elements power.</summary>
      
<remarks>Raises Base elements to Exponent elements power. Only positive exponents can be handled
      if exponent object <see cref="Complex"/> property is True.
</remarks>


      <Example>
      <code>
      var a,b,c: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);
          b.SetIt(1,2,True,[3,3,2,2]);
          c.PowerVec(a,b); // c = [1,8,9,16]
      end;
      </code>
      </Example>

      <SeeAlso cref="Power"/>*)
    function PowerVec(Base, Exponent: TMtxVec): TMtxVec;

    (*<summary>Elements product.</summary>
      <returns>the product of all calling object elements:

      <IMG name="TVec25"/> </returns>

      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          c: double;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          c := a.Product; // c= 24
      end;
      </code>
      </Example>

      <SeeAlso cref="Productc"/>*)
    function Product: double; overload; 
    (*<summary>Returns the product for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Product(Index,Len: integer): double; overload; 
    (*<summary>Calculate the product of all calling object complex elements.</summary>
      
<remarks>Store the result in complex variable X.
</remarks>
*)
    procedure Product(out X: TCplx); overload; 
    (*<summary>Calculate the product for calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>Store the result in complex variable X. An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    procedure Product(out X: TCplx; Index,Len: integer); overload; 
    (*<summary>Calculate the product of all calling object elements and store the result in real variable X.</summary>*)
    procedure Product(out X: double); overload; 
    (*<summary>Calculate the product for calling object elements [Index]..[Index+Len-1] and store the
       result in real variable X.</summary>
       
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    procedure Product(out X: double; Index,Len: integer); overload; 

    (*<summary>Elements product.</summary>
      <returns>the complex product of all calling object complext elements:

      <IMG name="TVec25"/> </returns>

      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is false.
</remarks>

      <SeeAlso cref="Product"/>*)
    function Productc: TCplx; overload; 
    (*<summary>Returns the complex product for calling object complex elements [Index]..[Index+Len-1].</summary>
       
<remarks>An exception is raised if array borders are overrun or underrun or if <see cref="Complex"/> propety is false.
</remarks>
*)
    function Productc(Index,Len: integer): TCplx; overload; 

    (*<summary>The pseudo random sample generator with Gaussian distribution.</summary>
      
<remarks>Fills the calling object values with pseudo random samples following the Gaussian distribution with
      parameters: Mean = 0, StdDev = 1 ("Standard disctribution"). The value for the seed is obtained
      from the CPU clock.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.Size(50,10,False);
          a.RandGauss;
      end;
      </code>
      </Example>

      <SeeAlso cref="RandUniform"/>*)
    function RandGauss: TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the Gaussian distribution.</summary>
       
<remarks>Use parameters: AMean and AStdDev. The value for the seed is obtained from the CPU clock.
</remarks>
*)
    function RandGauss(AMean, AStdDev: double): TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the Gaussian distribution.</summary>
      
<remarks>Use parameters: AMean, AStdDev and with Seed.
</remarks>
*)
    function RandGauss(Seed: cardinal; AMean, AStdDev: double): TMtxVec; overload; 

    (*<summary>The pseudo random sample generator with continuous uniform distribution.</summary>
      
<remarks>Fills the calling object values with pseudo random samples following the continuous uniform distribution
      using the parameters Low = 0, High = 1. The value for the seed is obtained from the CPU clock.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.Size(10,10,False);
          a.RandUniform(0,5);
      end;
      </code>
      </Example>

      <SeeAlso cref="RandGauss"/>*)
    function RandUniform: TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the continuous uniform distribution.</summary>
      
<remarks>Use parameters Low and High. The value for the seed is obtained from the CPU clock.
</remarks>
*)
    function RandUniform(aLow, aHigh: double): TMtxVec; overload; 
    (*<summary>Fills the calling object values with pseudo random samples following the continuous uniform distribution.</summary>
      
<remarks>Use parameters Low and High and Seed.
</remarks>
*)
    function RandUniform(Seed: cardinal; aLow, aHigh: double): TMtxVec;   overload; 

    (*<summary>Gets real part of complex object values.</summary>
      
<remarks>The method method gets the real part of a complex object Vec and stores the real results in the calling
      object. Size and <see cref="Complex"/> properties of the calling object are set implicitly to match
      Vec object. Vec <see cref="Complex"/> property must be true otherwise an exception is raised.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(True,[1,2,3,4]); // = [1+2i, 3+4i]
          b.RealPart(a); // b = [1,3]
      end;
      </code>
      </Example>

      <SeeAlso cref="ImagPart"/>*)
    function RealPart(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Gets the real part of a Vec object complex elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Stores the results in calling object real elements [Index]..[Index+Len-1].
      An exception is raised if array borders are overrun or underrun or if Vec object <see cref="Complex"/>
      propety is false.
</remarks>
*)
    function RealPart(const Vec: TMtxVec; VecIndex,Index,Len: integer): TMtxVec; overload; 

    

    
    (*<summary>Read values content from stream to object.</summary>
      
<remarks>Reads values content from SrcStream stream to calling objct. No other values describing the data type or length are read
      from the DstStream. Number type is defined by the Precision parameter, which can be obtained from <see cref="ReadHeader"/> method
      call.

      Note
        Use this method separately only, if you want user defined storage format.
</remarks>


      <Example>
      <code>
      var b: Matrix;
          AStream: TFileStream;
          Precision: TPrecision;
      begin
        AStream := TFileStream.Create('C:\test.bin',fmOpenRead);
        try
          Precision := b.ReadHeader(AStream); // Read info for b
          b.ReadValues(AStream,Precision); // Read values of b
        finally
          AStream.Free;
        end;
      end;
      </code>
      </Example>

      <SeeAlso cref="ReadHeader"/>
      <SeeAlso cref="WriteValues"/>
      <SeeAlso cref="LoadFromStream"/>*)
    function ReadValues(const Src: TStream; Precision: TPrecision): Int64; overload;
    

    (*<summary>Constructs a complex object from two real objects.</summary>
      
<remarks>Construct a complex object from the ReVec (real part) and the ImVec (imaginary part) objects.
      The results are stored in the calling object. Size and <see cref="Complex"/> properties of the calling
      object are set implicitly to match ReVec and ImVec objects. An exception is raised if ReVec or ImVec <see cref="Complex"/>
      property is True.
</remarks>


      <Example>
      <code>
      var a,b,c: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);
          b.SetIt(1,2,True,[2,2,3,4]);
          c.RealToCplx(a,b);
      end;
      </code>
      </Example>

      <SeeAlso cref="CplxToReal"/>*)
    function RealToCplx(ReVec, ImVec: TMtxVec): TMtxVec; overload; 
    (*<summary>Construct a complex object from the ReVec elements [ReIndex]..[ReIndex+Len-1] (real part) and the ImVec
      elements [ImIndex]..[ImIndex+Len-1] (imaginary part).</summary>
      
<remarks>The results are stored to calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the calling
      object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and array borders
      are overrun. An exception is also raised if ReVec or ImVec <see cref="Complex"/> property is True.
</remarks>
*)
    function RealToCplx(ReVec, ImVec: TMtxVec; ReIndex, ImIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Resets object properties to default values.</summary>
      
<remarks>Resets object properties to default values. The method is used by the Object cache management
      to reset the properties of the object freed with a call to <See Routine="MtxVec.FreeIt"/>.
</remarks>
*)
    procedure Reset;

    (*<summary>Search and replace a value.</summary>
      
<remarks>Replaces the SearchValue with a ReplaceValue, where the searchValue is compared with Tol to the values of the calling object.
</remarks>
*)
    function Replace(SearchValue, ReplaceValue: double; Tol: double = 0.0001): TMtxVec; overload; 
    (*<summary>Replaces the SearchValue with a ReplaceValue.</summary>
      
<remarks>The searchValue is compared with Tol to the calling object elements
      [Index]..[Index+Len-1]. An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Replace(SearchValue, ReplaceValue: double; Index, Len: integer; Tol: double = 0.0001): TMtxVec; overload; 
    (*<summary>Search and replace a complex value.</summary>*)
    function Replace(SearchValue, ReplaceValue: TCplx; Tol: double = 0.0001): TMtxVec; overload; 
    (*<summary>Replaces the SearchValue with a ReplaceValue, where the searchValue is compared with Tol to the calling object elements
      [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Replace(SearchValue, ReplaceValue: TCplx; Index, Len: integer; Tol: double = 0.0001): TMtxVec; overload; 

    (*<summary>Root mean square (RMS).</summary>
      
<remarks>Calculate the root mean square value for all calling object
      elements in-place. The root mean square (RMS) is defined by the equation:

      <IMG name="TVec02"/>
</remarks>


      <Example>
      <code>
      var a: Matrix;
          c: double;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          c := a.RMS;
      end;
      </code>
      </Example>

      <SeeAlso cref="StdDev"/>*)
    function RMS: double; overload; 
    (*<summary>Calculate the RMS for calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function RMS(Index, Len: integer): double; overload; 

    (*<summary>Elements rounded to the nearest whole number.</summary>
      
<remarks>Rounds all calling object elements to the nearest whole number.
      The result can be stored to an array of integers or as floating
      point number.
</remarks>


      <SeeAlso cref="Trunc"/>
      <SeeAlso cref="Frac"/>*)
    function Round: TMtxVec; overload; 
    (*<summary>Round calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Round(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Round all Src object elements and store the results in calling object elements.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Round(const Src: TMtxVec): TMtxVec; overload; 
    (*<summary>Rounds the calling object elements to 4 byte integers and stores the result in the Dst array.</summary>
       
<remarks>The size of the Dst array is set automatically.
       If the complex property is True then the length of the array will be equal to
       Self.Length*2.
</remarks>
*)
    procedure Round(var Dst: TIntegerArray); overload; 
    (*<summary>Round Src object elements [SrcIndex]..[SrcIndex+Len-1].</summary>
      
<remarks>Store the results to calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> property of the
      calling object must be set explicitly.
      An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Round(const Src: TMtxVec; SrcIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Initialize elements to Value.</summary>
      
<remarks>Set all calling object elements to Value.
      If the calling object is complex then the real part is set to Value and the imaginary is set to zero.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
        a.Size(1,4,False);
        a.SetVal(1); // a = [1,1,1,1]
      end;
      </code>
      </Example>

      <SeeAlso cref="SetZero"/>*)
    function SetVal(Value: double): TMtxVec; overload; 
    (*<summary>Set all calling object elements [Index]..[Index+Len-1] to real Value.</summary>
      
<remarks>If the calling object is complex then the real part is set to Value and the imaginary is set to zero.
      An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function SetVal(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Set all calling object complex elements to complex Value.</summary>*)
    function SetVal(Value: TCplx): TMtxVec; overload; 
    (*<summary>Set calling object complex elements [Index]..[Index+Len-1] to complex Value.</summary>
       
<remarks><see cref="Complex"/> properties of the calling object are set to true even before the call it was false.
       An exception is raised if calling object array borders are overrun/underrun.
</remarks>
*)
    function SetVal(Value: TCplx; Index: integer; Len: integer): TMtxVec; overload; 

    (*<summary>Initializes object elements to zero.</summary>
      <SeeAlso cref="SetVal"/>*)
    function SetZero: TMtxVec; overload; 
    (*<summary>Set all calling object elements to zero.</summary>
      
<remarks>Initializes calling object elements [Index]..[Index+Len-1] to zero.
      An exception is raised if array borders are overrun.
</remarks>
*)
    function SetZero(Index, Len: integer): TMtxVec; overload; 

    (*<summary>Changes elements sign.</summary>
      
<remarks>Changes all calling object elements sign (v -> -v) in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
        a.SetIt(1,4,False,[1,2,-3,4]);
        a.Sign; // a = [-1,-2,3,-4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Mul"/>*)
    function Sign: TMtxVec; overload; 
    (*<summary>Change calling object elements [Index]..[Index+Len-1] sign in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Sign(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Change all X object elements sign and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function Sign(const X: TMtxVec): TMtxVec; overload; 
    (*<summary>Change X object elements [XIndex]..[XIndex+Len-1] sign.</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1].
      An exception is raised if array borders are overrun or underrun.
</remarks>
*)
    function Sign(const X: TMtxVec; XIndex,Index,Len: integer): TMtxVec; overload; 

    function Sgn: TMtxVec; overload; 
    function Sgn(Index,Len: integer): TMtxVec; overload; 
    function Sgn(const Src: TMtxVec): TMtxVec; overload; 
    function Sgn(const Src: TMtxVec; SrcIndex,Index,Len: integer): TMtxVec; overload; 

    (*<summary>Signum.</summary>
      
<remarks>Calculates the signum of all Src object elements and multiplies
      it with the calling object elements accordingly.

      Signum(X) is 1 for X &gt; 0 , equal to zero for X = 0  and  -1 for X &lt; 0.
      The length of Src and of the calling object must match
      or an exception will be raised.

      Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function SgnMul(const Src: TMtxVec): TMtxVec; overload; 

    (*<summary>Size the object.</summary>
      
<remarks>Assignes the size of the Src object to the calling object.
      If the calling object is a TVec object then the Src can be of any type,
      otherwise TMtx can only obtain size from a TMtx object and TSparseMtx
      can only obtain size from a TSparseMtx object.

      If the calling object and Src are of different types, the complex property can be
      different, if both objects have a matching <see cref="Length"/> property.
      In this case only the Complex property of the calling object will changed,
      while all other properties describing the size of the object (rows, cols, length,
      nonZeros) will be preserved. This is different from simply setting the Complex property.
      Changing the Complex property directly would also change the Length, Cols and NonZeros
      properties.
</remarks>
*)
    function Size(const Src: TMtxVec): TMtxVec ; overload; 
    (*<summary>Allows the complex property of the calling object to become of
       AComplex value instead of Src.Complex value.</summary>
       
<remarks>It is also possible to pass the calling object as the Src with a different AComplex value.
       The value of the complex property can be changed
       without knowing the actual type of the object.
</remarks>
*)
    function Size(const Src: TMtxVec; AComplex: boolean): TMtxVec ; overload;
    function Size(const Src: TMtxVecBase; const aFloatPrecision: TMtxFloatPrecision): TMtxVec; overload;

    (*<summary>Sizes the array.</summary>
      
<remarks>Sizes the Dst array so that it can hold all the values stored in the calling
      object. If the <see cref="Complex"/> property is false an exception will
      be raised.
</remarks>
*)
    procedure SizeToArray(var Dst: TCplxArray); overload; 
    (*<summary>Sizes double precision array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
       Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TDoubleArray); overload; 
    (*<summary>Size single precision array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
       Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TSingleArray); overload; 
    (*<summary>Sizes integer array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
       Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TIntegerArray); overload; 
    (*<summary>Sizes integer array.</summary>
    
<remarks>If the <see cref="Complex"/> property is true the Length of the
       Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: TSmallIntArray); overload; 
    (*<summary>Sizes integer array.</summary>
      
<remarks>If the <see cref="Complex"/> property is true the Length of the
       Dst array will be 2*<see cref="Length"/>.
</remarks>
*)
    procedure SizeToArray(var Dst: Math387.TByteArray); overload; 

    (*<summary>Compares two objects and returns True, if they are equal.</summary>
      
<remarks>Compares two objects and returns True, if they are equal. The IsEqual
      uses cmpAbsolute comparison method with comparison tolerance of 10*EPS by default.

      The method compares only <see cref="Complex"/> and <see cref="Length"/> properties and
      coresponding values. To compare matrices or sparse matrices, use the <see cref="Equal"/> method.
</remarks>


      <SeeAlso cref="Matrix.Equal"/>
      <SeeAlso cref="TSparseMtx.Equal"/>
      <SeeAlso cref="Vector.Equal"/>*)
    function IsEqual(const Vec: TMtxVec): boolean; overload;  
    (*<summary>Compares Vec elements [VecIndex]..[VecIndex+Len-1] with calling object
       elements [Index]..[Index+Len-1].</summary>*)
    function IsEqual(const Vec: TMtxVec; VecIndex, Index, Len: integer): boolean; overload;  
    (*<summary>Compares Vec elements with coresponding calling object elements.</summary>
      
<remarks>Use <paramref name="Compare"/> method and specified <paramref name="Precision"/>.
</remarks>
*)
    function IsEqual(const Vec: TMtxVec; Precision: double; Compare: TCompare = cmpAbsolute): boolean; overload; 
    (*<summary>Compares Vec elements [VecIndex]..[VecIndex+Len-1] with calling object
       elements [Index]..[Index+Len-1].</summary>
       
<remarks>Use <paramref name="Compare"/> method and specified <paramref name="Precision"/>.
</remarks>
*)
    function IsEqual(const Vec: TMtxVec; VecIndex, Index, Len: integer; Precision: double; Compare: TCompare = cmpAbsolute): boolean; overload;
    (*<summary>Compares complex Value with all calling object elements.</summary>*)
    function IsEqual(Value: TCplx): boolean; overload;
    (*<summary>Compares real Value with all calling object elements.</summary>*)
    function IsEqual(Value: double): boolean; overload;
    (*<summary>Compares real Value with all calling object elements with Compare
      method and specified Tolerance.</summary>*)
    function IsEqual(Value: double; Tolerance: double; Compare: TCompare): boolean; overload;
   (*<summary>Compares complex Value with all calling object elements with Compare
      method and specified Tolerance.</summary>*)
   function IsEqual(Value: TCplx; Tolerance: double; Compare: TCompare): boolean; overload;

    (*<summary>Standard deviation.</summary>
      
<remarks>Calculate the standard deviation of all calling object elements. The result is a real value.
      An exception is raised if calling Matrix <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          c: double;
          aMean: double;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          aMean := a.Mean;
          c := a.StdDev(aMean); //if both Mean and StdDev are required this is faster
          // c := a.StdDev; //this is an alternative.
      end;
      </code>
      </Example>

      <SeeAlso cref="Mean"/>*)
    function StdDev: double; overload; 
    (*<summary>Returns the standard deviation of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or if array
      borders are overrun/underrun.
</remarks>
*)
    function StdDev(Index,Len: integer): double; overload; 
    (*<summary>Returns the standard deviation of all calling object complex elements.</summary>
       
<remarks>The average of all calling object elements must be passed as a AMean parameter.
       An exception is raised if calling object <see cref="Complex"/> property is false.
</remarks>
*)
    function StdDev(AMean: TCplx): TCplx; overload; 
    (*<summary>Returns the standard deviation of calling object complex elements [Index]..[Index+Len-1].</summary>
       
<remarks>The average of all calling object elements must be passed as a AMean parameter.
       An exception is raised if calling object <see cref="Complex"/> property is false
       or if array borders are overrun/underrun.
</remarks>
*)
    function StdDev(AMean: TCplx; Index, Len: integer): TCplx; overload; 
    (*<summary>Returns the standard deviation of all calling object elements.</summary>
       
<remarks>The average of all calling object elements must be passed as a AMean parameter.
       An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    function StdDev(AMean: double): double; overload; 
    (*<summary>Returns the standard deviation of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The average of the coresponding elements must be passed as a parameter.
      An exception is raised if calling object <see cref="Complex"/> property is true
      or if array borders are overrun/underrun.
</remarks>
*)
    function StdDev(AMean: double; Index, Len: integer): double; overload; 

    (*<summary>Sine and cosine.</summary>
      
<remarks>Calculates the sine and cosine for all calling object elements and stores the sines
      to SinX and cosines to CosX. Size and <see cref="Complex"/> property of SinX and CosX are
      adjusted automatically.

      Note
        Use this method if you require both sine and cosine.
</remarks>


      <Example>
      <code>
      var a,s,c: Matrix;
      begin
          a.SetIt(1,3,false[0,PIDIV2,PI]);
          a.Sincos(s,c); // s=[0,1,0], c =[1,0,-1]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sin"/>
      <SeeAlso cref="Cos"/>*)
    procedure SinCos(SinX, CosX: TMtxVec); overload; 
    (*<summary>Calculates the sine and cosine for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Stores the sines to SinX elemets [SinXIndex]..[SinXIndex+Len-1] and cosines to CosX elements [CosXIndex]..[CosXIndex+Len-1] elements.
      Size and <see cref="Complex"/> property of SinX and CosX objects are not set automatically.
      An exception is raised if <see cref="ConditionCheck"/> and array borders are overrun/underun.
</remarks>
*)
    procedure SinCos(SinX, CosX: TMtxVec; SinXIndex, CosXIndex, Index, Len: integer); overload; 

    (*<summary>Hyperbolic sine and cosine.</summary>
      
<remarks>Calculates the hyperbolic sine and hyperbolic cosine for all calling object elements and stores
      the sines to SinhX and cosines to CoshX. Size and <see cref="Complex"/> property of SinhX and CoshX
      are adjusted automatically.

      Note
        Use this method if you require hyperbolic sine and hyperbolic cosine.
</remarks>


      <Example>
      <code>
      var a,s,c: Matrix;
      begin
          a.SetIt(1,3,false[0,PIDIV2,PI]);
          a.SinhCosh(s,c);
      end;
      </code>
      </Example>

      <SeeAlso cref="Sinh"/>
      <SeeAlso cref="Cosh"/>*)
    procedure SinhCosh(SinhX, CoshX: TMtxVec); overload; 
    (*<summary>Calculates the hyperbolic sine and hyperbolic cosine for calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Stores the sines to SinhX elemets [SinhIndex]..[SinhIndex+Len-1] and cosines to CoshX elements [CoshIndex]..[CoshIndex+Len-1] elements.
      Size and <see cref="Complex"/> property of SinhX and CoshX objects are not set automatically.
      An exception is raised if <see cref="ConditionCheck"/> and array borders are overrun/underun.
</remarks>
*)
    procedure SinhCosh(SinhX, CoshX: TMtxVec; SinhIndex, CoshIndex, Index, Len: integer); overload; 

    (*<summary>Sums Matrix values.</summary>
      <returns>the sum of all calling object elements.</returns>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          b: double;
      begin
        a.SetIt(1,4,False,[1,2,3,4]);
        b := a.Sum; // b = 10
      end;
      </code>
      </Example>

      <SeeAlso cref="Sumc"/>*)
    function Sum: double; overload; 
    (*<summary>Returns the sum of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is True or array borders are overrun/underrun.
</remarks>
*)
    function Sum(Index,Len: integer): double; overload; 
    (*<summary>Calculates the sum of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Stores the result in real ASum variable. An exception is raised if calling object <see cref="Complex"/> property is True or array borders are overrun/underrun.
</remarks>
*)
    procedure Sum(out ASum: double; Index, Len: integer); overload; 
    (*<summary>Calculates the sum of all calling object complex elements.</summary>
      
<remarks>Stores the result in complex ASum variable. An exception is raised if calling object <see cref="Complex"/> property is False.
</remarks>
*)
    procedure Sum(out ASum: TCplx); overload; 
    (*<summary>Calculates the sum of calling object complex elements [Index]..[Index+Len-1] and stores the result in complex ASum variable.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    procedure Sum(out ASum: TCplx; Index, Len: integer); overload; 

    (*<summary>Sum (complex value).</summary>
      
<remarks>Returns the complex sum of all calling object complex elements.
      An exception is raised if calling object <see cref="Complex"/> property is False.
</remarks>

      <SeeAlso cref="Sum"/>*)
    function Sumc: TCplx; overload; 
    (*<summary>Returns the complex sum of calling object complex elements [Index]..[Index+Len-1].</summary>
       
<remarks>An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    function Sumc(Index,Len: integer): TCplx; overload; 

    (*<summary>Threshold bottom operation.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is a lower bound for threshold operation.
      All values smaller than Value will be replaced with Value.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[2,0.1,3,4]);
          a.ThreshBottom(0.2); // a = [2,0.2,3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshBottom(Value: double): TMtxVec; overload; 
    (*<summary>Perform the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshBottom(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThreshBottom(const Src: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation on Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshBottom(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold top operation.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is an <b>upper</b> bound for threshold operation.
      All values bigger than Value will be replaced with Value.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[2,0.1,3,4]);
          a.Threshtop(0.2); // a = [0.2,0.1,0.2,0.2]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshTop(Value: double): TMtxVec; overload; 
    (*<summary>Perfrom the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshTop(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThreshTop(const Src: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshTop(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 


      (*<summary>Threshold top and bottom centered around zero.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is an <b>upper</b> bound for threshold operation.
      All values smaller than Value will be replaced with Value and all values bigger than -Value will be replaced with -Value.
      The comparison checks if abs(Values[i]) &lt; Value.
</remarks>


      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a;
          MtxVec.CreateIt(out a);
          try
          {
            a.SetIt(false, new double[] {2,-0.1,3,4});
            a.ThreshAbsLT(0.2); // a = [2,-0.2,3,4]
          }
          finally
          {
            MtxVec.FreeIt(ref a);
          }
        }
      }
      </code></example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshAbsLT(const Value: double): TMtxVec; overload; 
    (*<summary>Perfrom the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsLT(const Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> properties of the calling object are
      adjusted automatically.
</remarks>
*)
    function ThreshAbsLT(const Src: TMtxVec; const Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the
      calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck" text="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsLT(const Vec: TMtxVec; const Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 


    (*<summary>Threshold top and bottom centered around zero.</summary>
      
<remarks>Perform threshold operation on all calling object values. The Value parameter is an <b>upper</b> bound for threshold operation.
      All values bigger than Value will be replaced with Value and all values smaller than -Value will be replaced with -Value.
      The comparison checks if abs(Values[i]) &gt; Value.
</remarks>


      

      <example>
      <code>
      using Dew.Math;
      using Dew.Math.Units;

      namespace Dew.Examples()
      {
        void Example()
        {
          TVec a;
          MtxVec.CreateIt(out a);
          try
          {
            a.SetIt(false, new double[] {2, -1, 3, 4});
            a.ThreshAbsGT(0.2); // a = [0.2, -0.2, 0.2, 0.2]
          }
          finally
          {
            MtxVec.FreeIt(ref a);
          }
        }
      }
      </code></example>

      <SeeAlso cref="ThreshTop"/>*)
    function ThreshAbsGT(const Value: double): TMtxVec; overload; 
    (*<summary>Perfrom the threshold operation on calling object values [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsGT(const Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform threshold operation on all Src object values.</summary>
      
<remarks>Store the results in calling object. Size and <see cref="Complex"/> properties of the calling object are
      adjusted automatically.
</remarks>
*)
    function ThreshAbsGT(const Src: TMtxVec; const Value: double): TMtxVec; overload; 
    (*<summary>Perform a threshold operation Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the
      calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck" text="ConditionCheck"/> is true and array borders are overrun/underrun.
</remarks>
*)
    function ThreshAbsGT(const Vec: TMtxVec; const Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold less than operation.</summary>
      
<remarks>Perform operation on all calling object values. The LTValue parameter is an <b>lower</b> bound for threshold operation.
      All values less than LTLevel will be replaced with LTValue.
      For complex number comparation is applied with norm of complex value.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[2,0.1,3,4]);
          a.ThresholdLT(2.3,1.5); // a = [1.5,1.5,3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThresholdGT"/>
      <SeeAlso cref="ThresholdGT_LT"/>*)
    function ThresholdLT(LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perfrom "less than" threshold operation on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThresholdLT(LTLevel, LTValue: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation on Vec elements from range [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      An exception will be raised if Vec.Complex and Complex of the calling object are not equal.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel, LTValue: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perfrom "less than" threshold operation for complex numbers.</summary>
      
<remarks>If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(LTLevel: double; LTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perfrom "less than" threshold operation for complex numbers on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
      If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(LTLevel: double; LTValue: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation for complex numbers on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
      If Vec object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel: double; LTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perform "less than" threshold operation for complex numbers on Vec elements from range [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      If Vec object or calling object contain none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdLT(const Vec: TMtxVec; LTLevel: double; LTValue: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold greater than operation.</summary>
      
<remarks>Perform operation on all calling object values. The GTValue parameter is an <b>upper</b> bound for threshold operation.
      All values bigger than LTLevel will be replaced with GTValue.
      For complex number comparation is applied with norm of complex value.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[2,0.1,3,4]);
          a.ThresholdGT(2.3,3.4); // a = [2,0.1,3.4,3.4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThresholdLT"/>
      <SeeAlso cref="ThresholdGT_LT"/>*)
    function ThresholdGT(GTLevel, GTValue: double): TMtxVec; overload; 
    (*<summary>Perfrom "greater than" threshold operation on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function ThresholdGT(GTLevel, GTValue: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary> Perform "greater than" threshold operation on all Vec object values and store the results in calling object. </summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel, GTValue: double): TMtxVec; overload; 
    (*<summary> Perform "greater than" threshold operation on Vec elements from range [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1]. </summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      An exception will be raised if Vec.Complex and Complex of the calling object are not equal.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel, GTValue: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perfrom "greater than" threshold operation for complex numbers.</summary>
      
<remarks>If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(GTLevel: double; GTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perfrom "greater than" threshold operation for complex numbers on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
      If the calling object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(GTLevel: double; GTValue: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "greater than" threshold operation for complex numbers on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
      If Vec object contains none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel: double; GTValue: TCplx): TMtxVec; overload; 
    (*<summary>Perform "greater than" threshold operation for complex numbers on Vec elements from range [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in the calling object elements [Index]..[Index+Len-1]. Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      If Vec object or calling object contain none Complex values, an exception will be raised.
</remarks>
*)
    function ThresholdGT(const Vec: TMtxVec; GTLevel: double; GTValue: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Threshold greater than and less than operation.</summary>
      
<remarks>Perform operation on all calling object values. The LTValue parameter is an <b>lower</b> bound for threshold operation.
      The GTValue parameter is an <b>upper</b> bound for threshold operation.
      All values less than LTLevel will be replaced with LTValue. All values bigger than GTLevel will be replaced with GTValue.
      Operation is available only for none Complex values.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(1,2,True,[2,0.1,3,4]);
          a.ThresholdGT_LT(2.3,3.4,1,0.5); // a = [2,0.5,3.4,3.4]
      end;
      </code>
      </Example>

      <SeeAlso cref="ThresholdLT"/>
      <SeeAlso cref="ThresholdGT"/>*)
    function ThresholdGT_LT (GTLevel, GTValue, LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perfrom "greater than and less than" threshold operation on the calling object values in range [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
      An exception will be raised if the calling object contains complex numbers.
</remarks>
*)
    function ThresholdGT_LT (GTLevel, GTValue, LTLevel, LTValue: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Perform "greater than and less than" threshold operation on all Vec object values and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are adjusted automatically.
      An exception will be raised if Vec object contains complex numbers.
</remarks>
*)
    function ThresholdGT_LT (const Vec: TMtxVec; GTLevel, GTValue, LTLevel, LTValue: double): TMtxVec; overload; 
    (*<summary>Perform "greater than and less than" threshold operation on Vec elements from range [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and  <see cref="Complex"/> properties of the calling object must be
      set explicitly. An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun/underrun.
      An exception will be raised if Vec object or the calling object contain complex numbers.
</remarks>
*)
    function ThresholdGT_LT(const Vec: TMtxVec; GTLevel, GTValue, LTLevel, LTValue: double; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Rounds a real number towards zero and returns the fractional part.</summary>
      
<remarks>Rounds all calling object elements towards zero to an integer and stores
      the result in the TruncDst object as floating point numbers. The fractional
      part is stored in the FracDst.
</remarks>


      <SeeAlso cref="Frac"/>
      <SeeAlso cref="Round"/>*)
    procedure TruncAndFrac(TruncDst: TMtxVec; FracDst: TDenseMtxVec); overload;
    (*<summary>Truncate calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Store the results to TruncDst object elements
      [TruncIdx]..[TruncIdx+Len-1]. The fractional parts are saved in FracDst elements
      [FracIdx]..[FracIdx+Len-1]. Size and <see cref="Complex"/> property of calling object must be set
      explicitly to match those of Src object. An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    procedure TruncAndFrac(TruncDst: TMtxVec; FracDst: TDenseMtxVec; TruncIdx, FracIdx, Index, Len: integer); overload;

    (*<summary>Rounds a real number towards zero.</summary>
      
<remarks>Rounds all calling object elements towards zero to an integer and stores
      the result in the calling object again as floating point numbers.
</remarks>


      <SeeAlso cref="Frac"/>
      <SeeAlso cref="Round"/>*)
    function Trunc: TMtxVec; overload; 
    (*<summary>Truncate calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Trunc(Index,Len: integer): TMtxVec; overload; 
    (*<summary>Truncate all Src object elements and store the results in calling object elements.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Trunc(const Src: TMtxVec): TMtxVec; overload; 
    (*<summary>Truncate all calling object elements and store the result in the Dst integer array.</summary>
      
<remarks>Length of the array is automatically adjusted. If the calling object is Complex, the length
      of the Dst array is equal to 2*<see cref="Length"/>.
</remarks>
*)
    procedure Trunc(var Dst: TIntegerArray); overload; 
    (*<summary>Truncate Src object elements [SrcIndex]..[SrcIndex+Len-1].</summary>
      
<remarks>Store the results to calling object elemenents
      [Index]..[Index+Len-1]. Size and <see cref="Complex"/> property of calling object must be set explicitly to match those of Src
      object. An exception is raised if array borders are overrun/underrun.
</remarks>
*)
    function Trunc(const Src: TMtxVec; SrcIndex, Index,Len: integer): TMtxVec; overload; 

  (*<summary>Write object header and values to a file.</summary>
    
<remarks>Write the header describing the calling object and the values array of the calling object to the file,
    specified by the FileName. If the file already exist, the data is overwritten by default. If Append is
    True, the data is appended to the end of the file. The data is always saved with default
    precision. (single or double).

    * In case of '.csv' extension a comma is used as a column delimiter for matrices.
    * In case of '.txt' extension a tab is used as a column delimiter for matrices.
    * For all other extensions, the format is binary

    Note
      It is recommended you use a *.mtx extension when you're saving/loading matrix to/from file.
    Similarly, you should use a *.Vec extension when you're saving/loading vector to/from file.
</remarks>


    <Example>
    <code>
    var Mtx: Matrix;
    begin
        Mtx.SetIt(2,2,False,[3,1,-1,5]);
        Mtx.SaveToFile('c:\test.mtx'); // Write info and header for Mtx to file
    end;
    </code>
    </Example>

    <SeeAlso cref="LoadFromFile"/>
    <SeeAlso cref="SaveToStream"/>
    <SeeAlso cref="LoadFromStream"/>*)
    procedure SaveToFile(const FileName: string; Append: boolean = False);

    (*<summary>Reads the header information and the values array content from the file.</summary>
     
<remarks>Reads the header information and the values array content from the file specified by FileName parameter.

     * In case of '.csv' extension a comma is used as a column delimiter for matrices.
     * In case of '.txt' extension a tab is used as a column delimiter for matrices.
     * For all other extensions, the expected format is binary.
</remarks>


      <Example>
      <code>
      var b: Matrix;
      begin
          b.LoadFromFile('c:\test.Vec'); // Read header and values for b
      end;
      </code>
      </Example>

      <SeeAlso cref="SaveToFile"/>
      <SeeAlso cref="LoadFromStream"/>*)
    procedure LoadFromFile(const FileName: string);

    

    
    (*<summary>Reads the header information and the values array content from a stream.</summary>
      
<remarks>Reads the header information and the values array content from the SrcStream. The return value indicates
      the number of elements read.
</remarks>


      <Example>
      <code>
      var b: Matrix;
          AStream: TFileStream;
      begin
          b.SetIt(2,2,False,[0,0,1,3,2]);
          AStream := TFileStream.Create('C:\test.Vec',fmCreate);
          try
            b.LoadFromStream(AStream); // Read info and header for b
          finally
            AStream.Free;
          end;
      end;
      </code>
      </Example>

      <SeeAlso cref="SaveToStream"/>
      <SeeAlso cref="LoadFromFile"/>*)
    function LoadFromStream(const Src: TStream): Int64; overload;
    


    

    
    (*<summary>Writes the header information and the Values content to a stream.</summary>
      
<remarks>Writes the header information and the Values content to a DstStream stream.
      Number type is defined by the Precision parameter. Rounding defines the rounding for integer types.
      When saving double precision as single precision, all overflows are saved as INF (-INF). When saving
      to integer types all overflows are clipped. Attempt to save single precision as double precision
      will raise an exception.
</remarks>


      <Example>
      <code>
      var b: Matrix;
          AStream: TFileStream;
      begin
        b.SetIt(2,2,False,[0,0,1,3,2]);
        AStream := TFileStream.Create('C:\test.Vec',fmCreate);
        try
          b.SaveToStream(AStream); // Write info and header for b
        finally
          AStream.Free;
        end
      end;
      </code>
      </Example>

      <SeeAlso cref="LoadFromStream"/>
      <SeeAlso cref="WriteHeader"/>
      <SeeAlso cref="WriteValues"/>
      <SeeAlso cref="SaveToFile"/>*)

    procedure SaveToStream(const Dst: TStream); overload;
    

    

    
    (*<summary>Writes object Values content to a stream.</summary>
      
<remarks>Writes the calling object Values content to the DstStream stream. No other values describing the data type or length are written
      to the DstStream. Number type is defined by the Precision parameter. Rounding defines the rounding for integer types. When
      saving double precision as single precision, all overflows are saved as INF (-INF). When saving to integer types all overflows
      are clipped. Attempt to save single precision as double precision will raise an exception. The paramateres must be the same
      as for the <see cref="WriteHeader"/> method.

      Note
        Use this method separately only, if you want user defined storage format.
</remarks>


      <Example>
      <code>
      var b: Matrix;
        AStream: TFileStream;
      begin
        b.SetIt(2,2,False,[0,0,1,3,2]);
        AStream := TFileStream.Create('C:\test.Vec',fmCreate);
        try
          b.WriteHeader(AStream); // Write info for b
          b.WriteValues(AStream); // Write values of b
        finally
          AStream.Free;
        end;
      end;
      </code>
      </Example>

      <SeeAlso cref="ReadValues"/>
      <SeeAlso cref="WriteHeader"/>
      <SeeAlso cref="SaveToStream"/>*)
    procedure WriteValues(const Dst: TStream;
                          Precision: TPrecision;
                          Rounding: TRounding = rnTrunc); overload;
    procedure WriteValues(const Dst: TStream); overload;
    




    
    
    (*<summary>Writes the header information for the calling Matrix to a stream.</summary>
      
<remarks>Writes the header information for the calling object to a DstStream stream. The header information contains information about object (size, complex, type of values
      in Values array, ...) which all define the state of the object. Number type is defined by the Precision parameter. Rounding defines the rounding for integer types.
      When saving double precision as single precision, all overflows are saved as INF (-INF). When saving to integer types all overflows are clipped.
</remarks>


      <Example>
      <code>
      var b: Matrix;
          AStream: TFileStream;
      begin
        b.SetIt(2,2,False,[0,0,1,3,2]);
        AStream := TFileStream.Create('C:\test.bin',fmCreate);
        try
          b.WriteHeader(AStream); // Write info for b
          b.WriteValues(AStream); // Write values of b
        finally
          AStream.Free;
        end;
      end;
    </code>
    </Example>

    <SeeAlso cref="ReadHeader"/>
    <SeeAlso cref="WriteValues"/>
    <SeeAlso cref="WriteValues"/>*)
    procedure WriteHeader(const Dst: TStream;
                          Precision: TPrecision;
                          Rounding: TRounding = rnTrunc); overload;
    procedure WriteHeader(const Dst: TStream); overload;
    

    

    
    (*<summary>Reads the header information from a stream to object.</summary>
      
<remarks>Reads the header information from a DstStream stream to calling object. The header information contains all necessary information
      defining the object. The function returns the precision in which the data was stored.
      This information is required for the <see cref="ReadValues"/> method.
</remarks>


      <Example>
      <code>
      var b: Matrix;
          AStream: TFileStream;
          Precision: TPrecision;
      begin
        AStream := TFileStream.Create('C:\test.bin',fmOpenRead);
        try
          Precision := b.ReadHeader(AStream); // Read info for b
          b.ReadValues(AStream,Precision); // Read values of b
        finally
          AStream.Free;
        end;
      end;
      </code>
      </Example>

      <SeeAlso cref="ReadValues"/>
      <SeeAlso cref="WriteValues"/>
      <SeeAlso cref="WriteHeader"/>*)
    function ReadHeader(const Src: TStream): TPrecision; overload;
    

    

    (*<summary>Adds Value to object elements.</summary>
      
<remarks>Adds Value to all calling object elements.
</remarks>

      <SeeAlso cref="Sub"/>*)
    function Add(Value: double): TMtxVec; overload; 
    (*<summary>Adds complex Value to all calling object complex elements.</summary>*)
    function Add(Value: TCplx): TMtxVec; overload; 
    (*<summary>Adds Value to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Add(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds complex Value to calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Add(Value: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds Value to the each element of the Vec object and stores the result in the calling object.</summary>
       
<remarks>Size and <see cref="Complex"/> properties of the calling object are set automatically.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: double): TMtxVec; overload; 
    (*<summary>Adds complex Value to each element of the Vec object and store the result to the calling object.</summary>
       
<remarks>Size property of the calling object is set automatically.
       <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: TCplx): TMtxVec; overload; 
    (*<summary>Adds Value to each element of Vec object in range [VecIndex]..[VecIndex+Len-1] and
      stores result to elements [Index]..[Index+Len-1] of the calling object.</summary>
      
<remarks>Size of the calling object is not changed. An exception is raised if array borders are overrun.
      <see cref="Complex"/> property of the calling object is set implicitly.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds complex Value to each elements of the Vec object in range [VecIndex]..[VecIndex+Len-1] and
       stores the result to elements [Index]..[Index+Len-1] of the calling object.</summary>
       
<remarks>Size of the calling object is not changed. An exception is raised if array borders are overrun.
       <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function Add(const Vec: TMtxVec; Value: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Array addition.</summary>
      
<remarks>Add each of Vec elements to corresponding elements in the calling object.
</remarks>

      <SeeAlso cref="Sub"/>*)
    function Add(const Vec: TMtxVec): TMtxVec; overload; 

    (*<summary>Add each of Vec elements to corresponding elements in the calling object.</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ aScale*Vec . </code>

      The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match the Vec object.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: double): TMtxVec; overload; 
    (*<summary>Add each of Vec elements to corresponding elements in the calling object.</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ Cplx(RScale,IScale)*Vec . </code>

      When default values for parameters are being used the "normal" addition is being performed.
      The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match the Vec object.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; RScale: double; IScale: double): TMtxVec; overload; 
    (*<summary>Add each of Vec elements to corresponding elements in the calling object.</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ aScale*Vec . </code>

      The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match the Vec object.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: TCplx): TMtxVec; overload; 
    (*<summary>Add each of Vec2 elements to corresponding elements in Vec1. The results are stored in the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are set implicitly to match
      Vec1 and Vec2 matrices.
</remarks>
*)
    function Add(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Add Vec elements [VecIndex]..[VecIndex+Len-1] to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Add(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds Vec elements [VecIndex]..[VecIndex+Len-1] to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ Cplx(aScale)*Vec . </code>

      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Adds Vec elements [VecIndex]..[VecIndex+Len-1] to calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>In addition, the following formula is begin used:

      <code> result = result+ aScale*Vec . </code>

      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function AddScaled(const Vec: TMtxVec; aScale: TCplx; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Add Vec1 elements [Vec1Index]..[Vec1Index+Len-1] to Vec2 elements [Vec2Index]..[Vec2Index+Len-1] and
      store the results in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Add(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Add a product of two matrices.</summary>
      
<remarks>Multiply Vec1 elements with coresponding Vec2 elements and add the result
      to the calling Matrix. The size of the calling Matrix is set
      implicitly.
</remarks>


      <SeeAlso cref="Mul"/>
      <SeeAlso cref="Add"/>*)
    function AddProduct(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 

    (*<summary>Multiply Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 elements [Vec2Index]..[Vec2Index+Len-1].</summary>
      
<remarks>Ad the results to the calling object elements [Index]..[Index+Len-1].
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function AddProduct(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    

    (*<summary> Compute X + Y*yScale </summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale with complex arguments.</summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale on sub arrays. </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale on sub arrays with complex arguments. </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X + Y*yScale) </summary>
       
<remarks>By making use of yScale, it is also possible to compute the following (at the same or higher speed):

       (X - Y)^2 = X^2 - 2XY  +Y^2
</remarks>
*)
    function AddScaledSqr(const X, Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X + Y*yScale) </summary>*)
    function AddScaledSqr(const X, Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X) + sqr(Y)*yScale </summary>
       
<remarks>By making use of yScale, it is also possible to compute the following (at the same or higher speed):

       X^2 - Y^2
</remarks>
*)
    function SqrAddScaled(const X, Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X) + sqr(Y)*yScale </summary>*)
    function SqrAddScaled(const X, Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X) + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X) + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y + Z </summary>*)
    function Add(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X + Y + Z on sub arrays </summary>*)
    function Add(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y + Z*zScale </summary>*)
    function AddScaled(const X, Y, Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X + Y + Z*zScale </summary>*)
    function AddScaled(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X, Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;


    (*<summary> Compute X + Y + zScalar </summary>*)
    function Add(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X + Y + zScalar </summary>*)
    function Add(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y + zScalar on sub arrays </summary>*)
    function Add(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y + zScalar on sub arrays </summary>*)
    function Add(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X, Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X, Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + zScalar on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X + Y*yScale + zScalar on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    

    (*<summary> Compute X - Y - Z </summary>*)
    function Sub(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X - Y - Z on sub array</summary>*)
    function Sub(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer;const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X, Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X, Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X - Y - Z*zScale </summary>*)
    function SubScaled(const X, Y, Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X - Y - Z*zScale </summary>*)
    function SubScaled(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;


    (*<summary> Compute X - Y - zScalar </summary>*)
    function Sub(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X - Y - zScalar </summary>*)
    function Sub(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y - zScalar on sub array</summary>*)
    function Sub(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y - zScalar on sub array</summary>*)
    function Sub(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X, Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X, Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    

    (*<summary> Compute X * Y / Z </summary>*)
    function MulAndDiv(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X * Y / Z on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    

    (*<summary> Compute (X + Y)*Z </summary>*)
    function AddAndMul(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y)*Z*zScale </summary>*)
    function AddAndMul(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z*zScale </summary>*)
    function AddAndMul(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y*yScale)*Z*zScale </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const yScale: double; const Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*Z*zScale </summary>*)
    function AddAndMul(const X, Y: TMtxVec;const yScale: TCplx; const Z: TMtxVec;const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: double; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*Z*zScale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X + Y)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X + Y*yScale)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const yScale, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*zScalar </summary>*)
    function AddAndMul(const X, Y: TMtxVec; const yScale, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: TCplx; Index, Len: Integer): TMtxVec; overload;


    (*<summary> Compute (X + yScalar)*Z*zScale </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z*zScale </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const xScale, Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const xScale, Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z </summary>*)
    function AddAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*Z on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X + yScalar)*zScalar </summary>*)
    function AddAndMul(const X: TMtxVec; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*zScalar </summary>*)
    function AddAndMul(const X: TMtxVec; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*zScalar on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X + yScalar)*zScalar on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;


    

    (*<summary> Compute (X - Y)*Z </summary>*)
    function SubAndMul(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X + Y)*Z on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y)*Z*zScale </summary>*)
    function SubAndMul(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X - Y)*Z*zScale </summary>*)
    function SubAndMul(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer;const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer;const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y*yScale)*Z*zScale </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale: double; const Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*Z*zScale </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: double; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*Z*zScale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X - Y)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X - Y*yScale)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*zScalar </summary>*)
    function SubAndMul(const X, Y: TMtxVec; const yScale, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const yScale, Z: TCplx; Index, Len: Integer): TMtxVec; overload;


    (*<summary> Compute (X - yScalar)*Z*zScale </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z*zScale </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const xScale, Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const xScale, Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale, Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z </summary>*)
    function SubAndMul(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*Z on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X - yScalar)*zScalar </summary>*)
    function SubAndMul(const X: TMtxVec; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*zScalar </summary>*)
    function SubAndMul(const X: TMtxVec; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*zScalar on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X - yScalar)*zScalar on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;


    

    (*<summary> Compute X*Y + Z </summary>*)
    function MulAndAdd(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y + Z on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y*xyScale + Z </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y + Z*zScale </summary>*)
    function MulAndAdd(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale </summary>*)
    function MulAndAdd(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y + zScalar </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*Y + zScalar </summary>*)
    function MulAndAdd(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y + zScalar on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y + zScalar on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

    (*<summary> Compute X*Y - Z </summary>*)
    function MulAndSub(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y + Z on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y*xyScale - Z </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale - Z </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y*xyScale + Z on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y - Z*zScale </summary>*)
    function MulAndSub(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X*Y - Z*zScale </summary>*)
    function MulAndSub(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y + Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*Y - zScalar </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*Y - zScalar </summary>*)
    function MulAndSub(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X*Y - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X*Y - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

    (*<summary> Compute X/Y + Z </summary>*)
    function DivAndAdd(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y + Z on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y*xyScale + Z </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale + Z </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale + Z on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale + Z on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y + Z*zScale </summary>*)
    function DivAndAdd(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X/Y + Z*zScale </summary>*)
    function DivAndAdd(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y + zScalar </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X/Y + zScalar </summary>*)
    function DivAndAdd(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y + zScalar on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y + zScalar on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

        (*<summary> Compute X/Y - Z </summary>*)
    function DivAndSub(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y*xyScale - Z </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const xyScale: double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale - Z </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: double; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y*xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y - Z*zScale </summary>*)
    function DivAndSub(const X, Y, Z: TMtxVec; const zScale: double): TMtxVec; overload;
    (*<summary> Compute X/Y - Z*zScale </summary>*)
    function DivAndSub(const X, Y, Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y - Z*zScale on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y - Z*zScale on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X/Y - zScalar </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X/Y - zScalar </summary>*)
    function DivAndSub(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X/Y - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute X/Y - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    

    (*<summary> Compute X*xScale + Y*yScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X*xScale + Y*yScale) </summary>*)
    function AddScaledSqr(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X*xScale + Y*yScale) </summary>*)
    function AddScaledSqr(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X*xScale + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X*xScale + Y*yScale) on sub arrays </summary>*)
    function AddScaledSqr(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale </summary>*)
    function SqrAddScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): TMtxVec; overload;
    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale </summary>*)
    function SqrAddScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): TMtxVec; overload;
    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale on sub arrays </summary>*)
    function SqrAddScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*xScale + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + Z*zScale </summary>*)
    function AddScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + Z*zScale on sub arrays </summary>*)
    function AddScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*xScale + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + zScalar </summary>*)
    function AddScaledC(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + z on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale + Y*yScale + z on sub arrays </summary>*)
    function AddScaledC(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*xScale - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - Z*zScale </summary>*)
    function SubScaled(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar </summary>*)
    function SubScaledC(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;

    (*<summary> Compute X*xScale - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - Z*zScale on sub array</summary>*)
    function SubScaled(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: TMtxVec; yIndex: integer; const yScale: Double; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*xScale - Y*yScale - zScalar on sub array</summary>*)
    function SubScaledC(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TMtxVec; yIndex: integer; const yScale: TCplx; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X*Y*Z </summary>
       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Z parameter:

       X^2*Y
</remarks>
*)
    function MulElem(const X, Y,Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Z parameter:

       X^2*zScalar
</remarks>
*)
    function MulElem(const X,Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Z parameter:

       X^2*zScalar
</remarks>
*)
    function MulElem(const X,Y: TMtxVec; const Z: TCplx): TMtxVec; overload;


    (*<summary> Compute X*Y*Z on sub array</summary>*)
    function MulElem(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar on sub array</summary>*)
    function MulElem(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*Y*zScalar on sub array</summary>*)
    function MulElem(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X / (Y*Z) </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing Y also for the Z parameter:

       X / (Y^2)
</remarks>
*)
    function Divide(const X, Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X/( Y*Z ) on sub array</summary>*)
    function Divide(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X / (Y*zScale) </summary>*)
    function DivideC(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X / (Y*zScale) </summary>*)
    function DivideC(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute X / (Y*zScalar) on sub array</summary>*)
    function DivideC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X / (Y*zScalar) on sub array</summary>*)
    function DivideC(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X * Y * xyScale / Z </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2 * xyScale/ Z
</remarks>
*)
    function MulAndDiv(const X, Y: TMtxVec; const xyScale: Double; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X * Y * xyScale / Z </summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2 * xyScale/ Z
</remarks>
*)
    function MulAndDiv(const X, Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute X * Y * xyScale / Z on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const xyScale: Double; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X * Y * xyScale / Z on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute X * Y / zScalar </summary>*)
    function MulAndDiv(const X, Y: TMtxVec; const Z: Double): TMtxVec; overload;
    (*<summary> Compute X * Y / zScalar </summary>*)
    function MulAndDiv(const X, Y: TMtxVec; const Z: TCplx): TMtxVec; overload;

    (*<summary> Compute X * Y / zScalar on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X * Y / zScalar on sub array</summary>*)
    function MulAndDiv(const X: TMtxVec; xIndex: integer; const Y: TMtxVec; yIndex: integer; const Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute xScalar / (Y*Z) </summary>*)
    function Divide(const X: Double; const Y, Z: TMtxVec): TMtxVec; overload;
    (*<summary> Compute xScalar / (Y*Z) </summary>*)
    function Divide(const X: TCplx; const Y, Z: TMtxVec): TMtxVec; overload;

    (*<summary> Compute xScalar / (Y*Z) on sub array</summary>*)
    function Divide(const X: Double; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute xScalar / (Y*Z) on sub array</summary>*)
    function Divide(const X: TCplx; const Y: TMtxVec; yIndex: integer; const Z: TMtxVec; zIndex: integer; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + Y*yScale)*Z*zScale</summary>

        
<remarks>The following is also possible at the same or higher speed:

        X^2 * xScale + XY * yScale

        by passing X also for the Z parameter.
</remarks>
*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*Z*zScale</summary>

        
<remarks>The following is also possible at the same or higher speed:

        X^2 * xScale + XY * yScale

        by passing X also for the Z parameter.
</remarks>
*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*Z*Scale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*Z*Scale on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + Y*yScale)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + Y*yScale)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X* xScale + yScalar)*Z*zScale</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X* xScale + yScalar)*Z*zScale</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X* xScale + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X* xScale + yScalar)*Z*zScale on sub-array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale + yScalar)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: Double; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*zScalar</summary>*)
    function AddAndMul(const X: TMtxVec; const xScale: TCplx; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale + yScalar)*zScalar on sub array</summary>*)
    function AddAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*Z*Scale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*Z*Scale on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - Y*yScale)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: Double; const Y: TMtxVec; yIndex: Integer; const yScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - Y*yScale)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: Integer; const xScale: TCplx; const Y: TMtxVec; yIndex: Integer; const yScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - yScalar)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z*zScale</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*Z*zScale on sub-array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*xScale - yScalar)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: Double; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*zScalar</summary>*)
    function SubAndMul(const X: TMtxVec; const xScale: TCplx; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: Double; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*xScale - yScalar)*zScalar on sub array</summary>*)
    function SubAndMul(const X: TMtxVec; xIndex: integer; const xScale: TCplx; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + Z*zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + Z*zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + Z*zScale on sub array</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer;const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + zScalar on sub array</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale + zScalar on sub array</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing X also for the Y parameter:

       X^2*xyScale + zScale
</remarks>
*)
    function MulAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;


    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: integer; const Y, Z: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; const Y, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*yScalar) + zScalar</summary>*)
    function MulAndAdd(const X: TMtxVec; xIndex: integer; const Y, Z: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X*Y)*xyScale - zScalar</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale, Z: Double): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - zScalar</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale, Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X*Y)*xyScale - zScalar on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute X*yScalar - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute X*yScalar - Z*zScale</summary>*)
    function MulAndSub(const X: TMtxVec; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute X*yScalar - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: integer; const Y: Double; const Z: TMtxVec; zIndex: integer; const zScale: Double; Index, Len: integer): TMtxVec; overload;
    (*<summary> Compute X*yScalar - Z*zScale on sub array</summary>*)
    function MulAndSub(const X: TMtxVec; xIndex: integer; const Y: TCplx; const Z: TMtxVec; zIndex: integer; const zScale: TCplx; Index, Len: integer): TMtxVec; overload;

    (*<summary> Compute (X / Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing Z also for the Y parameter:

       (X / Z) * xyScale + Z * zScale
</remarks>
*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y)*xyScale + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y)*xyScale + Z*zScale</summary>

       
<remarks>The following expression would also run at the same or higher speed, when passing Z also for the Y parameter:

       (X / Z) * xyScale + Z * zScale
</remarks>
*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y)*xyScale + Z*zScale on sub array</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale + zScalar</summary>*)
    function DivAndAdd(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X / Y) * xyScale - Z*zScale </summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: TMtxVec; zIndex: Integer; const zScale: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - Z*zScale </summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - Z on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TMtxVec; zIndex: Integer; const zScale: TCplx; Index, Len: Integer): TMtxVec; overload;

    (*<summary> Compute (X / Y) * xyScale - zScalar</summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: Double; const Z: Double; Index, Len: Integer): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - zScalar</summary>*)
    function DivAndSub(const X: TMtxVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): TMtxVec; overload;
    (*<summary> Compute (X / Y) * xyScale - zScalar on sub array</summary>*)
    function DivAndSub(const X: TMtxVec; xIndex: Integer; const Y: TMtxVec; yIndex: Integer; const xyScale: TCplx; const Z: TCplx; Index, Len: Integer): TMtxVec; overload;

    




    

    (*<summary>Conjugate and multiply.</summary>
      
<remarks>Conjugate each of Matrix elements and multiply them with corresponding elements in the calling object.
      The results are stored in the calling object. Size and <see cref="Complex"/>
      properties of the calling object are set implicitly to match Vec.
</remarks>


      <Example>
      <code>
      var a,b,c: Matrix;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);
          b.SetIt(1,2,True,[4,3,2,1]);
          c.ConjMul(a,b);
      end;
      </code>
      </Example>

      <SeeAlso cref="Conj"/>
      <SeeAlso cref="Mul"/>*)
    function ConjMul(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Conjugate Vec elements Vec[VecIndex]..Vec[VecIndex+Len-1] and multiply them with corresponding
      calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements
      [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties are <b>not</b> set.
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun or underrun.
</remarks>
*)
    function ConjMul(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Conjugate each of Vec2 elements and multiply them with corresponding elements in Vec1.</summary>
      
<remarks>The results are stored in the calling object. Size and <see cref="Complex"/> properties of
      the calling object are set implicitly to match Vec1 and Vec2 objects.
</remarks>
*)
    function ConjMul(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Conjugate Vec2 elements [Vec2Index]..[Vec2Index+Len-1] and multiply them with corresponding Vec1 elements [Vec1Index]..[Vec1Index+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties of the calling Matrix must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function ConjMul(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Cumulative sum.</summary>
    
<remarks>Calculate the cumulative sum for calling object elements [Index]..[Index+Len-1] in-place.
      An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(2,2,false,[1,2,3,4];
          a.CumSum(0,4); // a = [1,3,6,10]
      end;
      </code>
      </Example>

      <SeeAlso cref="Sum"/>*)
    function CumSum(Index, Len: Integer): TMtxVec; overload; 
    (*<summary>Calculate the cumulative sum for Vec elements [VecIndex]..[VecIndex+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the
      calling object must be set explicitly. Exception is raised if <see cref="ConditionCheck"/>  property is True
      and array borders are overrun.
</remarks>
*)
    function CumSum(const Vec: TMtxVec; VecIndex,Index,Len: Integer): TMtxVec; overload; 

    (*<summary>Calculate the cumulative product for all Vec elements.</summary>
              
<remarks>The size must be set by the user. The function will store all powers of Value:

              Values[Index + i] := IntPower(Value, i)

              at corresponding array Index
</remarks>
*)
    function CumProduct(Value: Double; Index, Len: integer): TMtxVec; overload; 

    (*<summary>Calculate the cumulative product for all Vec elements.</summary>
              
<remarks>The size must be set by the user. The function will store all powers of Value:

              CValues[Index + i] := IntPower(Value, i)

              at corresponding array Index
</remarks>
*)
    function CumProduct(const Value: TCplx; Index, Len: integer): TMtxVec; overload; 

    (*<summary>The forward discrete cosine transform (DCT).</summary>
      
<remarks>Calculates the forward discrete cosine transform (DCT) of the Vec and writes the result in the calling Matrix.
      If Vec.Length is a power of 2, the function uses an efficient algorithm that is significantly faster than
      the direct computation of DCT. For other values of Vec Length, this function uses the direct formulas
      given below; however, the symmetry of cosine function is taken into account, which allows to perform
      about half of the multiplication operations in the formulas. In the following definition of DCT,
      N=Vec.Length and V is the calling Matrix:

      <IMG name="TVec18"/>
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
        a.SetIt(1,4,False,[1,-2,3,4]);
        b.DCT(a,0,0,4);
      end;
      </code>
      </Example>

      <SeeAlso cref="IDCT"/>
      <SeeAlso cref="FFT"/>*)
    function DCT(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Difference.</summary>
      
<remarks>Calculate the difference for Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object
      elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/> properties of the calling Matrix must be set explicitly.
      The following formula is used to calculate the difference:

      <IMG name="tvec19"/>

      An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function Difference(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Matrix division.</summary>
      
<remarks>Divide each of Vec elements with corresponding elements in the calling object.
      Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.

      The threshold parameter is used to prevent against division by zero and
      numerical instabilities in the follow on processing.
      All values of Vec smaller than Threshold will be replaced with Threshold.
</remarks>


      <SeeAlso cref="Mul"/>*)
    function Divide(const Vec: TMtxVec; Threshold: double): TMtxVec; overload; 
    (*<summary>Divide each of Vec elements with corresponding elements in the calling object.</summary>
      
<remarks>Store the result in the calling object. Size and <see cref="Complex"/> property of the calling object are set automatically.
</remarks>
*)
    function Divide(const Vec: TMtxVec; Threshold: double; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide each of Vec1 elements with corresponding elements in the Vec2 object.</summary>
       
<remarks>Store the result in the calling Matrix.
</remarks>
*)
    function Divide(const Vec1, Vec2: TMtxVec; Threshold: double): TMtxVec; overload; 
    (*<summary>Divide Vec1 elements [Vec1Index]...[Vec1Index+Len-1] with corresponding elements
       [Vec2Index]...[Vec2Index+Len-1] from the Vec object.</summary>
        
<remarks>Store the result in the calling Matrix [Index]...[Index+Len-1].
</remarks>
*)
    function Divide(const Vec1, Vec2: TMtxVec; Threshold: double; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide each of Num elements with corresponding elements in Den.</summary>
      
<remarks>Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.

      Note
        The result of division by zero will be the INF constant. Division of zero
        by zero will result in NAN.
</remarks>
*)
    function Divide(Num, Den: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide each of calling Matrix elements with corresponding elements in the Vec object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.

      Note
        The result of division by zero will be the INF constant. Division of zero
        by zero will result in NAN.
</remarks>
*)
    function Divide(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide calling Matrix elements [Index]...[Index+Len-1] with corresponding elements
       [VecIndex]...[VecIndex+Len-1] from the Vec object.</summary>
       
<remarks>Store the result in the claling Matrix. The <see cref="Length"/>
       of the calling Matrix is not changed. An exception is raised if
       <see cref="ConditionCheck"/> is True and array borders are overrun
       or underrun.

       Note
        The result of division by zero will be the INF constant. Division of zero
        by zero will result in NAN.
</remarks>
*)
    function Divide(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide [NumIndex]..[NumIndex+Len-1] Num elements with [DenIndex]..[DenIndex+Len-1] elements in Den.</summary>
      
<remarks>Store result in the calling Matrix at positions [Index]..[Index+Len-1]
      <see cref="Size"/> and <see cref="Complex"/> property of the calling object are not changed.
      An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun or underrun.

      Note
        The result of division by zero will be the INF constant. Division of zero
        by zero will result in NAN.
</remarks>
*)
    function Divide(Num, Den: TMtxVec; NumIndex, DenIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Divide Value with elements of the calling object and store the result in the calling object.</summary>*)
    function DivideBy(Value: double): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements of the calling object and store the result in the calling object.</summary>
       
<remarks>Calling Matrix will be extended to complex, if the calling Matrix is real.
</remarks>
*)
    function DivideBy(Value: TCplx): TMtxVec; overload; 
    (*<summary>Divide Value with elements [Index]...[Index+Len-1] from the calling object.</summary>
       
<remarks>Store the result in the calling object at position [Index]...[Index+Len-1].
      An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function DivideBy(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements [Index]...[Index+Len-1] from the calling object.</summary>
       
<remarks>Store the result in the calling object at position [Index]...[Index+Len-1].
       Calling Matrix will be extended to complex, if the calling Matrix is real.
       An exception will be raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
</remarks>
*)
    function DivideBy(Value: TCplx; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide Value with elements from Vec and store the result in the corresponding elements of the calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object are set automatically.
</remarks>
*)
    function DivideBy(Value: double; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements from Vec and store the result in the corresponding elements of the calling object.</summary>
      
<remarks>Size of the calling object is set automatically.
      <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function DivideBy(Value: TCplx; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Divide Value with Vec elements [VecIndex]..[VecIndes+Len-1].</summary>
      
<remarks>Store the result in the elements [Index]..[Index+Len-1] of the calling object.
      Size of the calling object is not changed. An exception will be raised if <see cref="ConditionCheck"/> is
      True and array borders are overrun or underrun.
      <see cref="Complex"/> property of the calling object is set implicitly.
</remarks>
*)
    function DivideBy(Value: double; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Divide complex Value with elements [VecIndex]..[VecIndes+Len-1] from Vec and store the result in the
       elements [Index]..[Index+Len-1] of the calling object.</summary>
       
<remarks>Size of the calling object is not changed. An exception will be raised
       if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
      <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function DivideBy(Value: TCplx; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Scalar product of two real arrays.</summary>
      
<remarks>Returns the scalar product between Vec elements [VecIndex]..[VecIndex+Len-1] and calling object elements
      [Index]..[Index+Len-1]. An exception is raised if Vec and calling object <see cref="Complex"/> property is True.
      An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
      The dot product is defined by the equation:

      <IMG name="TVec13"/>

      Both objects must be of equal size. If they are not, the method will return the dot product of the largest sub-array.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      prod: double;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          b.SetIt(1,4,False,[5,6,7,8]);
          prod := a.DotProd(b,0,0,4); // = 1*5 + 2*6 + * 3*7 + 4*8
      end;
      </code>
      </Example>

      <SeeAlso cref="DotProdc"/>*)
    function DotProd(const Vec: TMtxVec; VecIndex, Index, Len: integer): double; overload; 

    (*<summary>Scalar product of two complex arrays.</summary>
      
<remarks>Returns the scalar product between Vec (complex) elements [VecIndex]..[VecIndex+Len-1] and calling object (complex) elements
      [Index]..[Index+Len-1]. An exception is raised if Vec and calling object <see cref="Complex"/> property is False.
      An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
      An exception is raised if calling or Vec object <see cref="Complex"/> property is false.
      The dot product is defined by the equation:

      <IMG name="TVec13"/>

      Both objects must be of equal size. If they are not, the method will return the dot product of the largest sub-array.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      prod: TCplx;
      begin
          a.SetIt(1,2,True,[1,2,3,4]);
          b.SetIt(1,2,True,[5,6,7,8]);
          prod := a.DotProdc(b,0,0,2); //= (1+2i)*(5+6i)+(3+4i)*(7+8i)
      end;
      </code>
      </Example>

      <SeeAlso cref="DotProd"/>*)
    function DotProdc(const Vec: TMtxVec; VecIndex, Index, Len: integer): TCplx; overload; 

    
    function DotProdc(const Vec: TMtxVec; ConjVec: boolean; VecIndex, Index, Len: integer): TCplx; overload; 

    (*<summary>Downsamples object values.</summary>
      
<remarks>Copy only every Factor sample from Src starting at SrcIndex up to Len to the calling object starting
      at Index. The phase parameter determines the initial sample offset. Phase must be less then Factor. Size and
      <see cref="Complex"/> properties of the calling object are set implicitly. An exception is raised if array borders are
      overrun/underrun.
</remarks>


      <SeeAlso cref="UpSample"/>*)
    function DownSample(const Src: TMtxVec; Factor, SrcIndex, Index, Len: integer; Phase: integer = 0): TMtxVec; overload; 

    (*<summary>Fast Furier Transformation (FFT) from complex to complex or from real to complex.</summary>
      
<remarks>Calculate the 1D FFT from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object elements
      [Index]..[Index+Len-1]. The Len parameter must be a power of two. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/>  is True and
      array borders are overrun. If Vec is complex, then complex to complex forward FFT is performed. If Vec is real, then real to
      complex forward FFT is performed.

      This is the indexed version of the FFT routine <see cref="Vector.FFT"/>. Look there
      for more information on FFT parameters and storage requirements.
</remarks>
*)
    function FFT(const Vec: TMtxVec; ConjugateExtend: boolean; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The forward Fast Fourier Transformation (FFT) from real to complex.</summary>
      
<remarks>Calculate the 1D FFT from real Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the calling object elements
      [Index]..[Index+Len-1]. The Len parameter must not be a power of two. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and Vec is not complex or if array borders are overrun.

      This is the indexed version of the FFT routine <see cref="FFTFromReal"/>. Look there
      for more information on FFT parameters and storage requirements.
</remarks>


      <SeeAlso cref="Vector.IFFT"/>
      <SeeAlso cref="IFFT1D"/>*)
    function FFTFromReal(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse discrete cosine transform (DCT).</summary>
      
<remarks>Calculate the inverse discrete cosine transform (DCT) from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1]. The Len parameter must be the power of two. Size and <see cref="Complex"/>
      properties of the calling Matrix must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.
</remarks>
*)
    function IDCT(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>The inverse FFT from complex to complex.</summary>
      
<remarks>Calculate the inverse 1D FFT from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1]. The Len parameter must be the power of two. Size and <see cref="Complex"/>
      properties of the calling Matrix must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True and
      array borders are overrun.

      Note
        This is the indexed version of the FFT routine <see cref="IFFT"/>. Look there
        For more information on FFT parameters and storage requirements.
</remarks>


      <SeeAlso cref="Vector.IFFT"/>
      <SeeAlso cref="Matrix.IFFT1D"/>*)
    function IFFT(const Vec: TMtxVec; VecIndex, Index, Len: integer; NoScale: boolean=False): TMtxVec; overload; 

    (*<summary>The inverse FFT from complex to real.</summary>
      
<remarks>Calculate the inverse FFT from Vec elements [VecIndex]..[VecIndex+Len-1] and store the results in the
      calling object elements [Index]..[Index+Len-1]. The Len parameter must not be a power of two. Size
      and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if
      <see cref="ConditionCheck"/> is True and array borders are overrun.

      Note
        This is the indexed version of the FFT routine <see cref="IFFTToReal"/>. Look there
        for more information on FFT parameters and storage requirements.
</remarks>


      <SeeAlso cref="Vector.IFFTToReal"/>
      <SeeAlso cref="Matrix.IFFT1DToReal"/>*)
    function IFFTToReal(const Vec: TMtxVec; VecIndex, Index, Len: integer; NoScale: boolean=False): TMtxVec; overload; 

    (*<summary>The Kurtosis (fourth central momentum).</summary>
      
<remarks>Calculate the calling object kurtosis by using mean value AMean and standard deviation AStdDev.
      Kurtosis is the fourth central moment, divided by fourth power of standard deviation:

      <IMG name="TVec06"/>
</remarks>


      <SeeAlso cref="Skewness"/>
      <SeeAlso cref="Mean"/>
      <SeeAlso cref="StdDev"/>*)
    function Kurtosis(AMean, AStdDev: double): double; overload; 
    (*<summary>Calculate the kurtosis for elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
      The AMean and AStdDev passed as parameters must be computed from the same
      elements (Index, Len) as the Kurtosis itself.
</remarks>
*)
    function Kurtosis(AMean, AStdDev: double; Index, Len: integer): double; overload; 

    (*<summary>Median.</summary>
      
<remarks>Calculate median value for all calling object elements.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          c: double;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          c := a.Median;
      end;
      </code>
      </Example>

      <SeeAlso cref="Mean"/>*)
    function Median: double; overload; 
    (*<summary>Calculate median value for calling Matrix elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and array borders are overrun.
</remarks>
*)
    function Median(Index: integer; Len: integer): double; overload; 

    (*<summary>Matrix multiplication.</summary>
      
<remarks>Multiply each of Vec elements with corresponding elements in the calling object.
      Size and <see cref="Complex"/> property of the calling object are set automatically.
      The result is stored in the calling object.
</remarks>

      <SeeAlso cref="Divide"/>*)
    function Mul(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Multiply Vec elements [VecIndex]..[VecIndex+Len-1] with calling object elements [Index]..[Index+Len-1] in-place.</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="Complex"/> property do not match or if array
      borders are overrun/underrun.
</remarks>
*)
    function Mul(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 







    (*<summary>Multiply Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 object elements [Vec2Index]..[Vec2Index+Len-1]
      and store the results in calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Size and <see cref="Complex"/> properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Mul(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Vectorised maximum.</summary>
      
<remarks>Compares Vec values with corresponding elements in the calling object and stores the bigger value in Self.
      Size and <see cref="TMtxVec.Complex"/> property of the calling object are set automatically.
      Supports real value data only.
</remarks>


      <SeeAlso cref="MinEvery"/>*)
    function MaxEvery(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec elements [VecIndex]..[VecIndex+Len-1] with calling object elements [Index]..[Index+Len-1] and store result in Self.</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="TMtxVec.Complex"/> property do not match or if array
      borders are overrun/underrun. Supports real value data only.
</remarks>
*)
    function MaxEvery(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Compare all Vec1 elements with corresponding Vec2 elements and store bigger value in Self.</summary>
      
<remarks>Stores the results in to the calling object.
      Size and <see cref="TMtxVec.Complex"/> property of calling object are adjusted automatically to match those of Vec1 and Vec2.
      An exception is raised if Vec1 and Vec2 size and <see cref="TMtxVec.Complex"/> property do not match.
      Supports real value data only.
</remarks>
*)
    function MaxEvery(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 object elements [Vec2Index]..[Vec2Index+Len-1] and store bigger value in Self.</summary>
      
<remarks>Stores the results in to the calling object elements [Index]..[Index+Len-1]. Size and <see cref="TMtxVec.Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck">ConditionCheck</see> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function MaxEvery(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Vectorised minimum.</summary>
      
<remarks>Compares Vec values with corresponding elements in the calling object and stores the smaller value in Self.
      Size and <see cref="TMtxVec.Complex"/> property of the calling object are set automatically.
      Supports real value data only.
</remarks>


      <SeeAlso cref="MinEvery"/>*)
    function MinEvery(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec elements [VecIndex]..[VecIndex+Len-1] with calling object elements [Index]..[Index+Len-1] and store result in Self.</summary>
      
<remarks>An exception is raised if Vec and calling object <see cref="TMtxVec.Complex"/> property do not match or if array
      borders are overrun/underrun. Supports real value data only.
</remarks>
*)
    function MinEvery(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Compare all Vec1 elements with corresponding Vec2 elements and store the smaller value in Self.</summary>
      
<remarks>Stores the results in to the calling object.
      Size and <see cref="TMtxVec.Complex"/> property of calling object are adjusted automatically to match those of Vec1 and Vec2.
      An exception is raised if Vec1 and Vec2 size and <see cref="TMtxVec.Complex"/> property do not match.
      Supports real value data only.
</remarks>
*)
    function MinEvery(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Compare Vec1 elements [Vec1Index]..[Vec1Index+Len-1] with Vec2 object elements [Vec2Index]..[Vec2Index+Len-1] and store the smaller value in Self.</summary>
      
<remarks>Stores the results in to the calling object elements [Index]..[Index+Len-1]. Size and <see cref="TMtxVec.Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="TMtxVecBase.ConditionCheck">ConditionCheck</see> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function MinEvery(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Maximum value.</summary>
      
<remarks>Returns the maximum value of all calling object elements. The result is a real value. An exception is
      raised is calling object <see cref="Complex"/> is true.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          b: double;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          b := a.Max; // b = 4
      end;
      </code>
      </Example>

      <SeeAlso cref="Min"/>
      <SeeAlso cref="Maxc"/>
      <SeeAlso cref="MaxMin"/>*)
    function Max: double; overload; 
    (*<summary>Returns the maximum value from calling object elements [Index]..[Index+Len-1]. The result is a real value.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Max(Index,Len: integer): double; overload; 
    (*<summary>Calculate the maximum value from calling object elements [Index]..[Index+Len-1]. The result AMean is a real value.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    procedure Max(out AMax: double; Index,Len: integer); overload; 
    
    procedure Max(out AMax: double; out AIndex: integer); overload; 
    (*<summary>Calculate the maximum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMax parameter returns the maximum value. The AIndex parameter returns the Index of maximum value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrud/underrun.
</remarks>
*)
    procedure Max(out AMax: double; out AIndex: integer; Index, Len: integer); overload; 

    (*<summary>Maximum value.</summary>
      
<remarks>Returns the maximum value of all calling object complex elements. Complex elements are first compared by the amplitude
      and then by the argument. An exception is raised if calling object <see cref="Complex"/> is False.
</remarks>

      <SeeAlso cref="Max"/>*)
    function Maxc: TCplx; overload; 
    (*<summary>Returns the maximum value of calling object complex elements [Index]..[Index+Len-1]. The result is a complex value.</summary>
      
<remarks>Complex elements are first compared by the amplitude and then by the argument. An exception is raised if calling object
      <see cref="Complex"/> property is False or array borders are overrud/underrun.
</remarks>
*)
    function Maxc(Index,Len: integer): TCplx; overload; 
    (*<summary>Calculate the maximum value of calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMax parameter returns
      complex maximum value. Returns the Index of maximum value. Complex elements are first compared by the amplitude and then by the argument.
      The AIndex parameter returns the Index of maximum value. An exception is raised if calling object <see cref="Complex"/>
      property is False or array borders are overrud/underrun.
</remarks>
*)
    function Maxc(out AMax: TCplx; Index, Len: integer): integer; overload; 

    (*<summary>Maximum and minimum value in a single pass.</summary>
      
<remarks>Calculates the maximum and minimum value of all calling object elements in a single pass. Maximum value is stored in AMax parameter,
      minimum value is stored in AMin parameter. Use this method if you require minimum AND maximum value.
</remarks>


      <SeeAlso cref="Min"/>
      <SeeAlso cref="Max"/>*)
    procedure MaxMin(out AMax,AMin: double); overload; 
    (*<summary>Calculates the maximum and minimum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Maximum value is stored in AMax parameter, minimum value is stored in AMin parameter.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrud/underrun.
</remarks>
*)
    procedure MaxMin(out AMax,AMin: double; Index, Len: integer); overload; 
    (*<summary>Calculates the maximum and minimum value of all calling object elements.</summary>
      
<remarks>Maximum value is returned in AMax parameter, minimum
      value in AMin parameter. The MaxIdx parameter returns the Index of maximum value. The MinIdx parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    procedure MaxMin(out AMax: double; out MaxIdx: integer; out AMin: double; out MinIdx: integer); overload; 
    (*<summary>Calculates the maximum and minimum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>Maximum value is returned in AMax parameter, minimum
      value in AMin parameter. The MaxIdx parameter returns the Index of maximum value. The MinIdx parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true or if array borders are overrud/underrun.
</remarks>
*)
    procedure MaxMin(out AMax: double; out MaxIdx: integer; out AMin: double; out MinIdx: integer; Index, Len: integer); overload; 

    (*<summary>Mean value.</summary>
      
<remarks>Calculate the mean value of all calling object elements. The result is a real value.
      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          b: double;
      begin
        a.SetIt(4,1,False,[1,2,3,4]);
        b := a.Mean; // b = 2.5
      end;
      </code>
      </Example>

      <SeeAlso cref="Sum"/>
      <SeeAlso cref="Meanc"/>*)
    function Mean: double; overload; 
    (*<summary>Returns real mean value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Mean(Index, Len: integer): double; overload; 
    (*<summary>Calculate the mean value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result AMean is a real value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun/underrun.
</remarks>
*)
    procedure Mean(out AMean: double; Index, Len: integer); overload; 

    (*<summary>Mean value (complex).</summary>
      
<remarks>Returns the mean value of all calling object complex elements. The result is a complex value. An exception is
      raised is calling object <see cref="Complex"/> is False.
</remarks>

      <SeeAlso cref="Mean"/>*)
    function Meanc: TCplx; overload; 
    (*<summary>Returns complex mean value from calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    function Meanc(Index, Len: integer): TCplx; overload; 
    (*<summary>Calculate the mean value from all calling object complex elements.</summary>
      
<remarks>The result AMean is a complex value.
      An exception is raised if calling object <see cref="Complex"/> property is False.
</remarks>
*)
    procedure Meanc(out AMean: TCplx); overload; 
    (*<summary>Calculate the mean value from calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result AMean is a complex value.
      An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    procedure Meanc(out AMean: TCplx; Index, Len: integer); overload; 

    (*<summary>Minimum value.</summary>
      
<remarks>Calculate the minimum value of all calling object elements. The result is a real value. An exception is
      raised if calling object <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var a: Matrix;
          b: double;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          b := a.Min; // b = 1
      end;
      </code>
      </Example>

      <SeeAlso cref="Max"/>
      <SeeAlso cref="Minc"/>*)
    function Min: double; overload; 
    (*<summary>Calculate the minimum value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result is a real value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Min(Index,Len: integer): double; overload; 
    (*<summary>Calculate the minimum value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result AMin is a real value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    procedure Min(out AMin: double; Index,Len: integer); overload; 
    (*<summary>Calculate the minimum value of calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMax parameter returns the minimum value. The AIndex parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrud/underrun.
</remarks>
*)
    procedure Min(out AMin: double; out AIndex: Integer; Index, Len: integer); overload; 
    (*<summary>Calculate the minimum value of all calling object elements.</summary>
      
<remarks>The AMin parameter returns the minimum value. The AIndex parameter returns the Index of minimum value.
      An exception is raised if calling object <see cref="Complex"/> property is true.
</remarks>
*)
    procedure Min(out AMin: double; out AIndex: integer); overload; 

    (*<summary>Minimum value (complex).</summary>
      
<remarks>Returns the minimum value of all calling object complex elements. Complex elements are first compared by the amplitude
      and then by the argument. An exception is raised if calling object <see cref="Complex"/> is False.
</remarks>


      <SeeAlso cref="Min"/>*)
    function Minc: TCplx; overload; 
    (*<summary>Returns the minimum value of calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The result is a complex value.
      Complex elements are first compared by the amplitude and then by the argument. An exception is raised if calling object
      <see cref="Complex"/> property is False or array borders are overrud/underrun.
</remarks>
*)
    function Minc(Index,Len: integer): TCplx; overload; 
    (*<summary>Calculate the minimum value of calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>The AMin parameter returns
      complex minimum value. Returns the Index of minimum value. Complex elements are first compared by the amplitude and then by the argument.
      An exception is raised if calling object <see cref="Complex"/> property is False or array borders are overrun/underrun.
</remarks>
*)
    function Minc(out AMin: TCplx; Index, Len: integer): integer; overload; 

    (*<summary>The C-norm.</summary>
      
<remarks>Calculates the C  norm: ||V-Vec||, where V is the calling Matrix.
      If the NormC is called without any parameters, the NormC
      calculates the norm of the calling Matrix. The C norm of ||V-Vec|| is defined by the formula:

      <IMG name="TVec10"/>

      If RelativeError is true then the computed norm is divided by the
      norm of V, and the function returns the "relative error":

      <IMG name="TVec09"/>
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
        c: double;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          b.SetIt(1,4,False,[4,3,2,1]);
          c := a.NormC(b,False);
      end;
      </code>
      </Example>

      <SeeAlso cref="NormL1"/>
      <SeeAlso cref="NormL2"/>*)
    function NormC(const Vec: TDenseMtxVec; RelativeError: boolean = False): double; overload; 
    (*<summary>Calculates the C norm ||V-Vec|| between Vec elements [VecIndex]..[VecIndex+Len-1]
      and calling Matrix elements [Index]..[Index+Len-1].</summary>*)
    function NormC(const Vec: TDenseMtxVec; VecIndex,Index,Len: integer; RelativeError: boolean = False): double; overload; 


    (*<summary>The C-norm of calling Matrix.</summary>
      
<remarks>Computes:

       <code>
       NormC = max|a[i]|, 0 &lt; i &lt; Length-1
       </code>
</remarks>
*)
    function NormC: double; overload; 
    (*<summary>Calculates the C norm from calling Matrix elements [Index]..[Index+Len-1].</summary>*)
    function NormC(Index,Len: integer): double; overload; 

    (*<summary>The L1-norm.</summary>
       
<remarks>Calculates the L1  norm : ||V-Vec||, where V is calling Matrix.
       If the NormL1 is called without any parameters,
       the NormL1 calculates the norm of calling Matrix. The L1 norm of ||V-Vec|| is defined by the formula:

       <IMG name="TVec12"/>

      If RelativeError is true then the computed norm is divided by the
      norm of V, and the function returns the "relative error":

      <IMG name="TVec09"/>
</remarks>


    <Example>
    <code>
    var a,b: Matrix;
      c: double;
    begin
        a.SetIt(1,4,False,[1,2,3,4]);
        b.SetIt(1,4,False,[4,3,2,1]);
        c := a.NormL1(b,True);
    end;
    </code>
    </Example>

      <SeeAlso cref="NormC"/>
      <SeeAlso cref="NormL2"/>*)
    function NormL1(const Vec: TDenseMtxVec; RelativeError: boolean = False): double; overload; 
    (*<summary>Calculates the L1 norm ||V-Vec|| between Vec elements [VecIndex]..[VecIndex+Len-1]
      and calling Matrix elements [Index]..[Index+Len-1].</summary>*)
    function NormL1(const Vec: TDenseMtxVec; VecIndex,Index,Len: integer; RelativeError: boolean = False): double; overload; 

    (*<summary>The L1-norm of the calling Matrix.</summary>
      
<remarks>Calculates:

       <code>
       NormL1 = Sum(|a[i]|), 0 &lt; i &lt; Length-1
       </code>
</remarks>
*)
    function NormL1: double; overload; 
    (*<summary>Calculates the L1 norm from calling Matrix elements [Index]..[Index+Len-1].</summary>*)
    function NormL1(Index,Len: integer): double; overload; 


    (*<summary>The L2-norm.</summary>
     
<remarks>Calculates the L2  norm : ||V-Vec||, where V is calling Matrix. If the NormL2 is called without any parameters,
     the NormL2 calculates the norm of calling Matrix. The L2 norm of ||V-Vec|| is defined by the formula:

      <IMG name="TVec11"/>

      If RelativeError is true then the computed norm is divided by the norm of V, and the function returns the "relative error":

      <IMG name="TVec09"/>
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
        c: double;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          b.SetIt(1,4,False,[4,3,2,1]);
          c := a.NormL2(b,True);  // or
          c := NormL2(a,b,true);
      end;
      </code>
      </Example>

      <SeeAlso cref="NormC"/>
      <SeeAlso cref="NormL1"/>*)
    function NormL2(const Vec: TDenseMtxVec; RelativeError: boolean = False): double; overload; 
    (*<summary>Calculates the L2 norm ||V-Vec|| between Vec elements [VecIndex]..[VecIndex+Len-1]
      and calling Matrix elements [Index]..[Index+Len-1].</summary>*)
    function NormL2(const Vec: TDenseMtxVec; VecIndex,Index,Len: integer; RelativeError: boolean = False): double; overload; 

    (*<summary>The L2-norm of the calling Matrix.</summary>
      
<remarks>Calculates:

       <code>
      NormaL2 = ( Sum(|a[i]|^2) )^0.5  , 0 &lt; i &lt; Length-1
      </code>
</remarks>
*)
    function NormL2: double; overload;  
    (*<summary>Calculates the L2 norm from calling Matrix elements [Index]..[Index+Len-1].</summary>*)
    function NormL2(Index,Len: integer): double;  overload; 

    (*<summary>Add/Subtract a value.</summary>
      
<remarks>Depreciated
        Use <see cref="Add"/> (Value) instead.
</remarks>
*)
    function Offset(Value: double): TMtxVec; overload;  
    (*<summary>Add/Subtract a complex value.</summary>*)
    function Offset(Value: TCplx): TMtxVec; overload;  
    (*<summary>Add/Subtract a value from [Index]..[Index+Len-1].</summary>*)
    function Offset(Value: double; Index,Len: integer): TMtxVec; overload;  
    (*<summary>Add/Subtract a complex value from [Index]..[Index+Len-1].</summary>*)
    function Offset(Value: TCplx; Index,Len: integer): TMtxVec; overload;  

    (*<summary>Calculate the range from all calling object elements.</summary>*)
    function Range: double; overload; 
    (*<summary>Returns real range value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun.
</remarks>
*)
    function Range(Index, Len: integer): double; overload; 
    (*<summary>Calculate the range from calling object elements [Index]..[Index+Len-1]. The result ARange is a real value.</summary>
      
<remarks>An exception is raised if calling object <see cref="Complex"/> property is true or array borders are overrun/underrun.
</remarks>
*)
    procedure Range(out ARange: double; Index, Len: integer); overload; 

    (*<summary>Reverse Matrix elements.</summary>
      
<remarks>The method reverses Vec Matrix elements from [VecIndex].. [VecIndex+Len-1]
      and stores them in the calling Matrix from [Index]...[Index+Len-1]
      by using the following equation:

      <IMG name="TVec24"/>

      This overload reverses calling Matrix elements in-place.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          a.Reverse(0,2);   // a = [2,1,3,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="Rotate"/>
      <SeeAlso cref="Shift"/>*)
    function Reverse(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Reverses the calling object elements [Index]..[Index+Len-1].</summary>
       
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Reverse(Index, Len: integer): TMtxVec; overload;

    (*<summary>A cyclic shift on Matrix elements in range.</summary>
      
<remarks>Performs cyclic shift on Matrix elements in specified range [Index..Index+Len].
      The number of elements to shift is specified in the Offset parameter.
      Offset can be any integer number, positive or negative.
</remarks>


      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Shift"/>*)
    function Rotate(Offset: integer; Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 
    (*<summary>A cyclic shift on Matrix elements in range.</summary>
      
<remarks>Performs cyclic shift on source Matrix elements in specified range [Index..Index+Len] and stores them to calling Matrix.
      The number of elements to shift is specified in the Offset parameter.
      Offset can be any integer number, positive or negative.
</remarks>


      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Shift"/>*)
    function Rotate(const Vec: TMtxVec; Offset: integer; VecIndex,Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 

    (*<summary>Shift Matrix elements in range.</summary>
      
<remarks>Shifts calling Matrix elements in specified range [Index..Index+Len].
      The number of elements by which to shift is specified in the Offset parameter.

      Offset can be any integer number, positive or negative.
</remarks>

      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Rotate"/>*)
    function Shift(Offset: integer; Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 
    (*<summary>A shift on Matrix elements in range.</summary>
      
<remarks>Performs shift on source Matrix elements in specified range [Index..Index+Len] and stores them to calling Matrix.
      The number of elements to shift is specified in the Offset parameter.
      Offset can be any integer number, positive or negative.
</remarks>


      <SeeAlso cref="Reverse"/>
      <SeeAlso cref="Shift"/>*)
    function Shift(const Vec: TMtxVec; Offset: integer; VecIndex,Index: integer; Len: integer = MtxVecEOA): TMtxVec; overload; 

    (*<summary>Subtracts Value from object elements.</summary>
      
<remarks>Subtracts Value from all calling object elements.
</remarks>

      <SeeAlso cref="Add"/>*)
    function Sub(Value: double): TMtxVec; overload; 
    (*<summary>Subtracts complex Value from all calling object complex elements.</summary>*)
    function Sub(Value: TCplx): TMtxVec; overload; 
    (*<summary>Subtracts Value from calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sub(Value: double; Index, Len: integer): TMtxVec; overload; 
    (*<summary>Subtracts complex Value from calling object complex elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if array borders are overrun.
</remarks>
*)
    function Sub(Value: TCplx; Index, Len: integer): TMtxVec; overload; 

    (*<summary>Subtract real Value from Src store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: double): TMtxVec; overload;
    (*<summary>Subtract complex Value from Src store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: TCplx): TMtxVec; overload;
    (*<summary>Subtract real Value from Src elements [SrcIndex]..[SrcIndex+Len-1].</summary>
      
<remarks>Store the result in calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: double; SrcIndex, Index, Len: integer): TMtxVec; overload;
    (*<summary>Subtract complex Value from Src elements [SrcIndex]..[SrcIndex+Len-1].</summary>
      
<remarks>Store the result in calling object elements [Index]..[Index+Len-1].
      Size and <see cref="Complex"/> properties of the calling object must be set explicitly.
      An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Src: TMtxVec; Value: TCplx; SrcIndex, Index, Len: integer): TMtxVec; overload;

    (*<summary>Array subtraction.</summary>
      
<remarks>Subtract each of Vec elements from corresponding elements in the calling object.
      An exception is raised if Vec and calling object size and <see cref="Complex"/> properties do not match.
</remarks>


      <SeeAlso cref="Add"/>*)
    function Sub(const Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Subtract Vec2 elements from Vec1 elements and store the results in calling object.</summary>
      
<remarks>Size and <see cref="Complex"/> property of calling object are adjusted automatically.
      An exception is raised if Vec1 and Vec2 size and <see cref="Complex"/> property do not match.
</remarks>
*)
    function Sub(const Vec1, Vec2: TMtxVec): TMtxVec; overload; 
    (*<summary>Subtract Vec elements [VecIndex]..[VecIndex+Len-1] from corresponding calling object elements [Index]..[Index+Len-1].</summary>
      
<remarks>The results are stored in the calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Subtract Vec22 elements [Vec2Index]..[Vec2Index+Len-1] from Vec1 object elements [Vec1Index]..[Vec1Index+Len-1].</summary>
      
<remarks>Store the results in calling object elements [Index]..[Index+Len-1]. Size and <see cref="Complex"/>
      properties of the calling object must be set explicitly. An exception is raised if <see cref="ConditionCheck"/> is True
      and array borders are overrun or underrun.
</remarks>
*)
    function Sub(const Vec1, Vec2: TMtxVec; Vec1Index, Vec2Index, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Subtraction from value.</summary>
      
<remarks>Subtract each of calling object elements from Value.
</remarks>


      <SeeAlso cref="Add"/>
      <SeeAlso cref="Sub"/>*)
    function SubFrom(Value: double): TMtxVec; overload; 
    (*<summary>Subtract each of calling object elements from complex Value.</summary>
      
<remarks>If the calling Matrix is not complex, the conversion is performed automatically in a performance efficient way.
</remarks>
*)
    function SubFrom(Value: TCplx): TMtxVec; overload; 
    (*<summary>Subtract elements [Index]..[Index+Len-1] from Value and store the result in Self.</summary>
       
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True
       and array borders are overrun or underrun.
</remarks>
*)
    function SubFrom(Value: double; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Subtract elements [Index]..[Index+Len-1] from complex Value and store the result in Self.</summary>
       
<remarks>If the calling Matrix is not complex, the conversion to complex is performed automatically
       in performance efficient way. An exception is raised if <see cref="ConditionCheck"/> is True
       and array borders are overrun or underrun.
</remarks>
*)
    function SubFrom(Value: TCplx; Index,Len: integer): TMtxVec; overload; 
    (*<summary>Substract Vec elements from Value and store the result in the calling object.</summary>
       
<remarks>Size and <see cref="Complex"/> properties of calling object are adjusted automatically.
</remarks>
*)
    function SubFrom(Value: double; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Substract complex Vec elements from Value and store the result in the calling object.</summary>
       
<remarks>Size property of the calling object is set automatically.
       <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function SubFrom(Value: TCplx; Vec: TMtxVec): TMtxVec; overload; 
    (*<summary>Substract Vec elements [VecIndex]..[VecIndex+Len-1] from Value and store the result
       to the calling object elements [Index]..[Index+Len-1].</summary>
       
<remarks>Size property of the calling object is not changed. An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
       <see cref="Complex"/> property of the calling object is adjusted automatically.
</remarks>
*)
    function SubFrom(Value: double; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 
    (*<summary>Substract Vec elements [VecIndex]..[VecIndex+Len-1] from complex Value and store the result to the
       calling object elements [Index]..[Index+Len-1].</summary>
       
<remarks>Size property of the calling object is not changed. An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun or underrun.
       <see cref="Complex"/> property of the calling object is set to True.
</remarks>
*)
    function SubFrom(Value: TCplx; Vec: TMtxVec; VecIndex, Index, Len: integer): TMtxVec; overload; 

    (*<summary>Calculate the Sum of squares of the calling Matrix.</summary>
       
<remarks>For complex numbers, the routine computes the squared L2 norm.

     <code>
     SumOfSquares = Sum(|a[i]|^2)   , 0 &lt; i &lt; Length-1
     </code>
</remarks>


     <SeeAlso cref="NormL2"/>*)
    function SumOfSquares: double; overload;  
    (*<summary>Calculates the sum of squares from the calling Matrix elements [Index]..[Index+Len-1].</summary>*)
    function SumOfSquares(Index,Len: integer): double;  overload; 

    (*<summary>Inserts zeroes between consecutive array values.</summary>
      
<remarks>Copy Len values from Src starting at SrcIndex to the calling object starting at position Index and place Factor-1 zeros
      between consecutive values. Size and <see cref="Complex"/> properties of the calling object must be set
      explicitly. Phase parameter defines the initial sample offset and must be less then Factor. An exception is raised,
      if array borders are overrun/underrun.
</remarks>

      <SeeAlso cref="DownSample"/>*)
    function UpSample(const Src: TMtxVec; Factor,SrcIndex, Index, Len: integer; Phase: integer = 0): TMtxVec; overload; 

    (*<summary>Skewness (third central momentum).</summary>
      
<remarks>Calculate the calling object skewness by using mean value AMean and standard deviation AStdDev.
      Skewness is the third central moment, divided by third power of standard deviation:

      <IMG name="TVec07"/>
</remarks>


      <Example>
      <code>
      var a: Matrix;
        c,d: double;
      begin
          a.SetIt(1,4,False,[1,2,3,4]);
          d := a.Mean;
          c := a.Skewness(d, a.StdDev(d)); //or

          d := Mean(a);
          c := Skewness(a, d, StdDev(a, d));
      end;
      </code>
      </Example>

      <SeeAlso cref="Kurtosis"/>
      <SeeAlso cref="Mean"/>
      <SeeAlso cref="StdDev"/>*)
    function Skewness(AMean, AStdDev: double): double; overload; 
    (*<summary>Calculate the skewness for elements [Index]..[Index+Len-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is True and array borders are overrun.
      The AMean and AStdDev parameters must be computed from the same elements from which
      the Skewness is to be computed.
</remarks>
*)
    function Skewness(AMean, AStdDev: double; Index, Len: integer): double; overload; 

    

    (*<summary>Calculates the tensor product of two vectors and adds the result to calling matrix.</summary>
      
<remarks>Calculates the tensor product of Vec1 and Vec2 vectors and adds the result  to the calling matrix by
      using the following formula:

      <code>Y=Vec1 X Vec2 + Y.</code>

      If the ConjVec2 parameter is true, then the result will be tensor product of Vec1 and conjugated Vec2.
      The <see cref="Rows"/> property is set to Vec1.<see cref="Length"/> and <see cref="Cols"/> property is set to
      Vec2.<see cref="Length"/>. The <see cref="Complex"/> property of the calling matrix is adjusted automatically.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
          v1,v2: Vector;
      begin
          // Test non quadratic general matrix

          a.SetIt(2,2,False,[0,2,2,0]);
          v1.SetIt(false,[1,0]);
          v2.setIt(false,[0,1]);
          a.AddTensorProd(v1,v2,False);
          b.SetIt(False,[1,2,2,1]);
          if not (a = b) then raise Exception.Create('Not same');
      end;
      </code>
      </Example>

      <SeeAlso cref="TensorProd"/>*)
    function AddTensorProd(const Vec1, Vec2: TVec; ConjVec2: boolean = False): TMtx; overload;

    (*<summary>Adjungate matrix.</summary>
      
<remarks>Calculate the adjungate matrix in-place. Adjungation is equal to transpose and conjugate.
</remarks>
*)
    function Adjung: TMtx; overload;
    (*<summary>Calculate the adjungate to X matrix and store the results in calling matrix.</summary>
      
<remarks>The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of the calling matrix are
      set implicitly to match those of X matrix.
</remarks>
*)
    function Adjung(const X: TMtx): TMtx; overload;

    (*<summary>Convert banded matrix to dense.</summary>
      
<remarks>Convert matrix stored in banded format to dense format.
</remarks>


      <SeeAlso cref="DenseToBanded"/>*)
    procedure BandedToDense(const Src: TMtx); overload;

    (*<summary>Test if the matrix is semi positive definite.</summary>
      <returns>True, if the matrix semi positive definite and at the same time performs
      the Cholesky decomposition of the calling matrix.</returns>*)
    function Cholesky: boolean; overload;

    (*<summary>Exchange matrix columns.</summary>
      
<remarks>Exchange the i-tj and j-th columns of the calling matrix in-place. An exception is raised if matrix bounds
      are overrun.
</remarks>


      <SeeAlso cref="RowExchange"/>*)
    function ColExchange(i, j: integer): TMtx; overload;

    (*<summary>Permute the columns of the Src matrix.</summary>
      
<remarks>The parameter PermuteIdx contains indexes of columns P[i] to which column at Index "i" is to be moved.
      The result of the permutation is stored in the calling matrix. Only entire matrix can be copied.
</remarks>


      <SeeAlso cref="RowExchange"/>
      <SeeAlso cref="RowPermute"/>*)

    function ColPermute(const Src: TMtx; PermuteIdx: TVecInt): TMtx; overload;

    (*<summary>Permute the rows of the Src matrix.</summary>
      
<remarks>The parameter PermuteIdx contains indexes of columns P[i] to which column at Index "i" is to be moved.
      The result of the permutation is stored in the calling matrix. Only entire matrix can be copied.
</remarks>


      <SeeAlso cref="RowExchange"/>
      <SeeAlso cref="ColPermute"/>*)
    function RowPermute(const Src: TMtx; PermuteIdx: TVecInt): TMtx; overload;

    (*<summary>Concatenate an array of matrices to single matrix.</summary>
      
<remarks>Concatenate an array of matrices to form one big matrix and store the result in the calling matrix. The dimensions
      of the block matrices in the Src array must match, to form the new matrix. The block matrices must be all real or
      all complex, otherwise an exception will be raised. You must specify Arows*ACols block matrices in the Src array.
      The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of the calling matrix
      are adjusted automatically.
</remarks>


      <Example>
      <code>
      var A,B,C,D,E: Matrix;
      begin
          A.Size(2,2);
          B.Size(A);
          C.Size(A);
          D.Size(A);
          E.Concat(2,2[A,B
                      C,D]);  // form one 4x4 matrix
      end;
      </code>
      </Example>

      <SeeAlso cref="ConcatHorz"/>
      <SeeAlso cref="ConcatVert"/>*)
    function Concat(ARows, ACols: integer;const Src: array of TMtx): TMtx;  overload;

    (*<summary>Concenates an array of matrices horizontally.</summary>
      
<remarks>Concenate the Src matrices horizontally and store the results in the calling matrix. The <see cref="Rows"/>,
      <see cref="Cols"/> and <see cref="Complex"/> properties of the calling matrix are adjusted
      automatically. An exception is raised if any of the Src matrices Complex or Rows property does not match.
</remarks>


      <Example>
      <code>
      var A,B,C,D,E: Matrix;
      begin
          A.Size(2,2);
          B.Size(A);
          E.Size(4,4);
          // overwrite the lower part of the E matrix
          //    with values from A and B
          E.ConcatHorz(2,2[A,B]);
          //E becomes:
          //[E11 E12 E13 E14]
          //[E21 E22 E23 E24]
          //[A11 A12 B11 B12]
          //[A21 A22 B21 B22]
      end;
      </code>
      </Example>

      <SeeAlso cref="Concat"/>
      <SeeAlso cref="ConcatVert"/>*)
    function ConcatHorz(const Src: array of TMtx): TMtx;  overload;
    (*<summary>Concenate the Src matrices horizontally and store the results in the calling matrix.</summary>
      
<remarks>The DestRow and DestCol parameters indicate the starting position (in the calling matrix) for concenating. An exception is raised, if the
      calling matrix array bounds are overrun. An exception is raised, if any of the Src matrices Complex or Rows properties
      do not match.
</remarks>
*)
    function ConcatHorz(DestRow, DestCol: integer;const Src: array of TMtx): TMtx; overload;

    (*<summary>Concenates an array of matrices vertically.</summary>
      
<remarks>Concenate the Src matrices vertically and store the results in calling matrix. The <see cref="Rows"/>,
      <see cref="Cols"/> and <see cref="Complex"/> properties of the calling matrix are adjusted automatically.
      An exception is raised, if any of the Src matrices Complex or Cols properties do not match.
</remarks>


      <Example>
      <code>
      var A,B,C,D,E: Matrix;
      begin
          A.Size(1,2);
          B.Size(A);
          E.Size(4,4);
          // overwrite the lower part of the E matrix
          // with values from A and B
          E.ConcatVert(2,2[A,B]);
          // E becomes:
          //[E11 E12 E13 E14]
          //[E21 E22 E23 E24]
          //[A11 A12 E33 E34]
          //[B11 B12 E43 E44]s
      end;
      </code>
      </Example>

      <SeeAlso cref="Concat"/>
      <SeeAlso cref="ConcatHorz"/>*)
    function ConcatVert(const Src: array of TMtx): TMtx;  overload;
    (*<summary>Concenate the Src matrices vertically and store the results in calling matrix.</summary>
      
<remarks>The DestRow and DestCol parameters indicate the starting position (in the calling matrix) for concatenating. An exception is raised, if the calling matrix
      array bounds are overrun. An exception is raised, if any of the Src matrices Complex or Cols properties do not match.
</remarks>
*)
    function ConcatVert(DestRow, DestCol: integer;const Src: array of TMtx): TMtx; overload;

 (*<summary>{:Performs finite, linear convolution of two two-dimensional signals.
      Performs finite, linear convolution of two two-dimensional signals. The argument names X and H are chosen to suggest
      FIR filtering. The result of the convolution is defined as follows:
      <IMG SRC="mtx014"/>
      In the above expressions, X[n, m] is a shorthand for X[n+ m* X.Cols], H[n, m] is a shorthand for H[n+ m* H.Cols],
      and y[n, m] is a shorthand for:
      <code>y[n+ m* (X.Cols+ H.Cols-1)].</code>
      If NoResize parameter is True, the size of the calling matrix is set to the size of the X matrix and filtering edge
      effect is equally distributed. If the NoResize parameter is False, the size of the calling matrix is set to:
      <code>
      Rows = X.Rows + H.Rows - 1
      Cols  = X.Cols +  H.Cols   - 1
      </code>

      In image processing X is the mitxure and H is the convolution kernel.

      <SeeAlso cref="FFT"/>
    }
    function Convolve(X,H :TMtx; NoResize: boolean = True): TMtx; overload;</summary>*)

    (*<summary>Copy the Mtx elements [MtxRow,MtxCol]..[MtxRow+NrRows-1,MtxCol+NrCols-1] to the calling matrix elements
      [Row,Col],,[Row+NrRows-1,Col+NrCols-1].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and bounds are
      overrun. If Transpose is true, the matrix is transposed as well. An exception is raised if <see cref="ConditionCheck"/>
      is true and Complex properties of the calling matrix and Mtx do not match.
</remarks>
*)
    function Copy(const Mtx: TMtx; MtxRow, MtxCol, Row, Col, NrRows, NrCols: integer; Transpose: boolean = false): TMtx;   overload;

    (*<summary>Copy and convert values from TVecInt.</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               The size of the matrix must match the length of the vector or an
               exception will be raised.
</remarks>
*)
    function Copy(const Src: TVecInt; const dstFloatPrecision: TMtxFloatPrecision):TMtxVec; overload;

    (*<summary>Copy and convert values from TVecInt at indexes [SrcIndex]...[SrcIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
               properties of the calling object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    function Copy(const Src: TVecInt; SrcIndex, Index, Len: integer):TMtxVec; overload;


    (*<summary>Copy and convert values from TVecInt.</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               The size of the matrix must match the length of the vector or an
               exception will be raised.
</remarks>
*)
    function Copy(const Src: TMtxInt; const DstFloatPrecision: TMtxFloatPrecision):TMtxVec; overload;

    (*<summary>Copy and convert values from TMtxInt at indexes [SrcIndex]...[SrcIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from TMtxInt.
               The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="Complex"/>
               properties of the calling object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    function Copy(const Src: TMtxInt; SrcIndex, Index, Len: integer):TMtxVec; overload;



    (*<summary>Copy and convert values to TVecInt.</summary>
               
<remarks>Applies appropriate conversion and copy data to TVecInt.
               The value TMtxVecInt.IntPrecision is preserved.
</remarks>
*)
    procedure CopyTo(const Dst: TVecInt; Rounding: TRounding); overload;

    (*<summary>Copy and convert values to TMtxInt.</summary>
               
<remarks>Applies appropriate conversion and copy data to TMtxInt.
               The value TMtxInt.IntPrecision is preserved.
</remarks>
*)
    procedure CopyTo(const Dst: TMtxInt; Rounding: TRounding); overload;

    (*<summary>Copy and convert values to TVecInt at indexes [DstIndex]...[DstIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="TMtxVecInt.IntPrecision"/>
               properties of the destination object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    procedure CopyTo(const Dst: TVecInt; Rounding: TRounding; DstIndex, Index, Len: integer); overload;

    (*<summary>Copy and convert values to TMtxInt at indexes [DstIndex]...[DstIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from TVecInt.
               The results are stored in calling object elements [Index]...[Index+Len-1]. Size and <see cref="TMtxVecInt.IntPrecision"/>
               properties of the destination object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    procedure CopyTo(const Dst: TMtxInt; Rounding: TRounding; DstIndex, Index, Len: integer); overload;

    (*<summary>Copy and convert values to specified dstFloatPrecision.</summary>
               
<remarks>Dst will be sized to hold all calling object data in specified dstFloatPrecision.
               The single/double and Complex/Not Complex conversion cant be handled concurrently.
</remarks>
*)
    procedure CopyTo(const Dst: TMtxVec; const dstFloatPrecision: TMtxFloatPrecision); overload;

    (*<summary>Copy and convert values to Dst.FloatPrecision at indexes [DstIndex]...[DstIndex+Len-1].</summary>
               
<remarks>Applies appropriate conversion and copy data from the calling object.
               The results are stored in Dst object elements [Index]...[Index+Len-1]. Size and <see cref="TMtxVec.FloatPrecision"/>
               properties of the destination object must be set explicitly. An exception is raised if array borders are overrun.
</remarks>
*)

    procedure CopyTo(const Dst: TMtxVec; const DstIndex, Index: integer; Len: integer); overload;

    (*<summary>Copy and if needed convert values to Dst.</summary>
               
<remarks>Existing value of Dst.FloatPrecision is preserved.
</remarks>
*)
    
    procedure CopyTo(const Dst: TMtxVec); overload;
    

    (*<summary>Copies matrix values to a 2D array.</summary>
      
<remarks>Copies all matrix values to a 2D array.
      The rows of the array will have two times as many columns, if the calling matrix object
       is Complex.
</remarks>
*)
    procedure CopyToArray(var Dst: T2DDoubleArray); overload;
    (*<summary>Copies all matrix values to a 2D array.</summary>*)
    procedure CopyToArray(var Dst: T2DCplxArray); overload;

    (*<summary>Copies the matrix from a 2D array.</summary>
      
<remarks>Sizes the matrix to match the size of the 2D array and
      copies all the values.
</remarks>
*)
    procedure CopyFromArray(const Src: T2DDoubleArray); overload;
    (*<summary>Sizes the matrix to match the size of the 2D array and
      copies all the values.</summary>*)
    procedure CopyFromArray(const Src: T2DCplxArray); overload;

    (*<summary>Sizes the Dst array to match the matrix.</summary>
      
<remarks>Sizes the Dst array to match the size of the matrix. An exception will be
      raised if the calling object is not complex.
</remarks>
*)
    procedure SizeToArray(var Dst: T2DCplxArray); overload;
    (*<summary>Sizes the Dst array to match the size of the matrix</summary>
      
<remarks>The rows will have two times as many columns, if the calling matrix object
       is Complex.
</remarks>
*)
    procedure SizeToArray(var Dst: T2DDoubleArray); overload;
    (*<summary>Sizes the calling matrix to match the size of the array.</summary>
      
<remarks>Sizes the calling matrix to match the size of the array.
      An exception will be raised if the calling object is not complex.
</remarks>
*)
    procedure SizeFromArray(const Src: T2DCplxArray); overload;
    (*<summary>Sizes the calling matrix to match the size of the array.</summary>*)
    procedure SizeFromArray(const Src: T2DDoubleArray); overload;

    (*<summary>Copies values from vector to a matrix.</summary>
      
<remarks>Copy all Vec elements to the calling matrix. Set the calling matrix <see cref="Rows"/> property to NrRows. Set the calling
      matrix <see cref="Cols"/> property to Vec.Length div NrRow (Length = Rows*Cols). The calling matrix <see cref="Complex"/>
      property is adjusted automatically. An exception is raised if Vec.Length mod NrRows &lt;&gt; 0.
</remarks>


      <Example>
      <code>
      var A: Matrix;
          v: Vector;
      begin
          v.SetIt(true,[1, 0, 2, -1, 5, 1.2]) ;
          A.CopyVec(v);
      end;
      </code>
      </Example>

      <SeeAlso cref="Copy"/>*)
    function CopyVec(const Vec: TVec; NrRows: Integer): TMtx; overload;
    (*<summary>Copy Vec elements [VecIndex]..[VecIndex+Len-1] to the calling matrix elements starting with [Row,Col].</summary>
      
<remarks>An exception is raised if <see cref="ConditionCheck"/> is true and bounds are overrun or if <see cref="Complex"/> properties of the calling matrix and
      Vec do not match.
</remarks>
*)
    function CopyVec(const Vec: TVec; VecIndex, Len, Row, Col: Integer): TMtx;   overload;

    (*<summary>Cumulative sum for each of the matrix columns.</summary>
      
<remarks>Calculate the cumulative sum for each of the calling matrix columns in-place.
</remarks>


      <Example>
      <code>
      var Mtx: Matrix;
      begin
          Mtx.Size(false,3,2,[1,2,
                              2,5,
                              3,1]);
          Mtx.CumSum;
          // Mtx becomes:
          // 1, 2
          // 3, 7
          // 6, 8
      end;
      </code>
      </Example>

      <SeeAlso cref="SumCols"/>*)
    function CumSum: TMtx; overload;
    (*<summary>Calculate tehe cumulative sum for each of the X matrix columns.</summary>
      
<remarks>Store the results in calling matrix. The <see cref="Rows"/>, <see cref="Cols"/> and
      <see cref="Complex"/> properties of the callig matrix are adjusted
      implicitly to match those of Mtx matrix.
</remarks>
*)
    function CumSum(const Mtx: TMtx): TMtx; overload;

    (*<summary>Determines type of the matrix.</summary>
      
<remarks>Tests the calling matrix and returns the <see cref="TMtxType"/> of the calling of matrix.
      The following types are supported:

      * mtSymmPosDef	= symmetric positive definite matrix
      * mtSymmetric = symmetric matrix
      * mtHermPosDef = Hermitian positive definite matrix
      * mtHermitian	= Hermitian matrix
      * mtTriangle	= triangular matrix, with unit or non unit main diagonal
      * mtGeneral	= general matrix (none of the above)

      Checking for positive definite matrix can be very expensive (O(n) = 1/3*n^3). Therefore the ChekPosDef
      parameter is False by default, unless the user specifies otherwise. The method will not detect banded matrix storage.
</remarks>


      <Example>
      <code>
      var X,B: Vector;
          A: Matrix;
          at: TMtxType;
      begin
          B.SetIt(false,[0,2]);
          A.SetIt(2,2,false,[1,2,
                  2,4]);  // 2x2 real matrix

          at := A.DetectMtxType;
          A.LUSolve(B,X,at);
          // This is the same for this example (except slower)
          A.LUSolve(B,X,mtSymmetric);
          // You could also specify
          A.AutoMtxType := True
          A.LUSolve(B,X);  // the type is autodetected
      end;
      </code>
      </Example>*)
    function DetectMtxType(CheckPosDef: boolean = False): TMtxType; overload;

    (*<summary>Convert dense matrix to banded.</summary>
      
<remarks>Convert the calling matrix stored in dense format to banded format and store the result in Dst.
      MaxElemCount defines the maximum number of elements that the Banded matrix may have before an
      exception will be raised.
</remarks>


      <SeeAlso cref="BandedToDense"/>*)
    procedure DenseToBanded(Dst: TMtx; MaxElemCount: integer = 10000000); overload;

    (*<summary>Determinant of squared matrix.</summary>
      
<remarks>Calculate the determinant of squared real matrix. An exception is raised if the calling matrix
      <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var A: Matrix;
          b: double;
      begin
          A.SetIt(2,2,false,[1,2,
                            2,4]);  // 2x2, not complex matrix
          b := A.Determinant; // 4 + 4 = 8
      end;
      </code>
      </Example>*)
    function Determinant(MtxType: TMtxType = mtGeneral): double; overload;
    (*<summary>Calculates the determinant of squared complex matrix.</summary>
      <returns>the result in result complex variable.</returns>
      
<remarks>An exception is raised if the calling matrix <see cref="Complex"/> property is false.
</remarks>
*)
    function Determinantc(MtxType: TMtxType = mtGeneral): TCplx; overload;

    (*<summary>Sets the matrix diagonal to values from the  vector.</summary>
      
<remarks>Sets the  k-th diagonal of the calling matrix to values from from the Vec object. If k = 0 then the main
      diagonal matrix is set, if k &lt; 0 then the k-th subdiagonal matrix is set and if k &gt; 0 the then the k-th
      super diagonal is set. The matrix must be large enough to hold diagonal or an exception is raised.
</remarks>


      <Example>
      <code>
      var A: Matrix;
          D: Vector;
      begin
          A.SetIt(2,2,True,[1,1, 2,1,
                           1,2, 2,2]);
          D.SetIt(2,  True,[2,2, 1,1]);
          A.Diag(D,0);
          // A becomes:
          // [2,2, 2,1]
          // [1,2, 1,1]
      end;
      </code>
      </Example>

      <SeeAlso cref="Diag"/>*)
    function Diag(const Vec: TVec; k: integer): TMtx; overload;

    (*<summary>Calculates matrix eigenvalues and eigenvectors.</summary>
      
<remarks>Calculates the eigenvalues (stored in vector D elements) and optionally the eigenvectors (stored in matrix the columns of
      matrices VL and VR) of the calling matrix. The MtxType parameter indicates the calling matrix <see cref="TMtxType"/>.
      Depending the type of the calling matrix the Eig method will use specific optimized algorithm. If you don't know the
      type of the calling matrix, you can not omit the MtxType parameter. To determine the type of matrix use the
      <see cref="DetectMtxType"/> method, or set <see cref="AutoMtxType"/> property to True.

      Depending on the MtxType parameter, the following algorithms will be used :

      <b>1)</b> for symmetric positive definite matrix (mtSymPosDef, mtHermPosDef):
      a) reduce the calling matrix to tridiagonal form A=Q*T*Q'
      b) generate matrix Q
      c) find eigenvalues and eigenvectors of the tridiagonal matrix T.

      <b>2)</b> for symmetric or hermitian matrix (mtSymetric, mtHermitian):
      a) reduce the calling matrix to tridiagonal form A=Q*T*Q'
      b) generate matrix Q
      c) find eigenvalues and eigenvectors of the tridiagonal matrix T.

      <b>3)</b> for general matrix (mtGeneral):
      A) VectorForm = vfEig:
        a) perform full balance of the calling matrix
        b) reduce the calling matrix to Hessenberg form A=Q*H*Q'
        c) generate matrix Q
        d) find eigenvalues and left and/or right eigenvectors.
        e) transform eigenvectors of the balanced matrix back to those of the original matrix.
      B) VectorForm = vfSchur:
      a) perform user defined balance of the calling matrix
      b) reduce the calling matrix to Hessenberg form A=Q*H*Q'
      c) generate matrix Q
      d) Find the real Schur form and optionally the eigenvectors Z*T*Z'. Matrix T is the real Schur form and Z are
        the eigen vectors.
      e) transform the eigenvectors of the balanced matrix to those of the original matrix.
         Matrix is in real Schur form, if it is upper quasi-triangular with  1-by-1 and 2-by-2 blocks. 2-by-2 blocks
         are standardized in the form

      <code>
      [ a  b  ]
      [ c  a  ]
      </code>

      where b*c &lt; 0. The eigenvalues of such a block are: a +/- sqrt(bc).

      Note
        The calling matrix <see cref="Quadratic"/> property must be true, otherwise an
        exception is raised.

      This overloaded version calculates the calling matrix eigenvalues and stores them in the vector D. The
      <see cref="Vector.Complex"/> and <see cref="Vector.Length"/> properties of
      the vector D are adjusted automatically. The MtxType parameter specifies the calling <see cref="TMtxType"/>.
      If MtxType parameter is omitted, the default value mtGeneral (general matrix) will be used, but for symmetric matrices the
      matrix type has to be specified explicitly, because the algorithm for general matrices will fail on the symmetric matrix.
      The matrix Q is not explicitly generated.
</remarks>


      <Example>
      <code>
      var  D: Vector;
          A,V: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);  // 2x2, real matrix
          A.Eig(D,mtSymmetric);
          // or if eigenvectors are also required
          A.Eig(V,D,nil,mtSymmetric);  // get left eigenvectors
      end;
      </code>
      </Example>

      <SeeAlso cref="EigGen"/>*)
    function Eig(D: TVec; MtxType: TMtxType = mtGeneral): TMtx; overload;
    (*<summary>Calculate the calling matrix eigenvalues and eigenvectors.</summary>
      
<remarks>Store the eigenvalues in the vector D.
      The Complex and Length properties of the vector D are adjusted automatically. If VectorForm is vfEig, store the left eigenvectors in matrix VL and
      the right eigenvectors in the matrix VR. Either of the eigenvector matrices VL and VR can be nil to indicate that they are not
      required. If the are both nil, an exception is raised. In case of symmetric matrices only VL is checked. The computed
      eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real and are stored in the columns of the VL and VR matrices.
      If VectorForm is vfSchur, it will store the real T form in the matrix VL and the eigenvectors Z in the matrix VR. VR can be nil,
      to indicate that eigenvectors are not required. If VL is nil an exception is raised. The Rows, Cols and Complex properties of
      matrices VR and VL are adjusted automatically. The MtxType parameter specifies the calling <see cref="TMtxType"/>. If MtxType
      parameter is omitted, the default value mtGeneral (general matrix) will be used, but for symmetric matrices the matrix type has to be
      specified explicitly, because the algorithm for general matrices will fail on the symmetric matrix.
</remarks>
*)
    function Eig(VL:TMtx; D: TVec; VR: TMTx = nil; MtxType: TMTxType = mtGeneral; VectorForm: TVectorForm = vfEig; Expand: boolean = True): TMtx; overload;

    (*<summary> Computes the eigenvalues and left and right eigenvectors of A general matrix. </summary>
                
<remarks>If VL and VR are not nil, corresponding left and right eigenvectors are computed.
                Does not work for symmetric matrices.
</remarks>
*)

    procedure Eig(D: TVec; VL, VR: TMtx); overload;

    (*<summary> Computes the eigenvalues and left and right eigenvectors of A general matrix. </summary>
                
<remarks>If VL and VR are not nil, corresponding left and right eigenvectors are computed.
                Additionally balancing can be speicifed with Balance. The info about balancing performed is stored in
                TEigBalancing object. This object can be nil, if no balancing was requested. If assigned the rconde
                parameter contains reciprocal condition number of the j-th eigenvalue. If assigned the rcondv
                contains reciprocal condition number of the j-th right eigenvector.
                Does not work for symmetric matrices.
</remarks>
*)

    procedure Eig(D: TVec; Balance: TBalanceType; BInfo: TEigBalancing = nil;
                                    rconde: TVec = nil; rcondv: TVec = nil; VL: TMtx = nil; VR: TMTx = nil); overload;

    (*<summary>Computes eigenvalues and optionally Schure matrix</summary>
           
<remarks>Computes for an N-by-N nonsymmetric matrix A, the eigenvalues, the Schur form T, and,
           optionally, the matrix of Schur vectors VS.  This gives the Schur factorization A = VS*T*(VS**H).

           Optionally the routine also orders the eigenvalues on the diagonal of the
           Schur form so that selected eigenvalues are at the top left.
           The Select function parameters accepts a function with two parameters. First is the real and the second is the
           imaginary part of the eigenvalue. The function is to return true, if the specified eigenvalue is to be
           included in to sorting at the top left of the Schur form. If sorting is not required pass nil (NULL) for this
           parameter.
</remarks>
*)

    procedure EigSchure(D: TVec; VS: TMTx = nil; T: TMtx = nil; Select: TSelectTwoFunction = nil; cSelect: TSelectOneFunctionC = nil;
                                                                SelectSingle: TSelectTwoFunctionSingle = nil; cSelectSingle: TSelectOneFunctionSingleC = nil); overload;

    (*<summary>Computes eigenvalues and optionally Schure matrix</summary>
           
<remarks>Computes for an N-by-N nonsymmetric matrix A, the eigenvalues, the Schur form T, and,
           optionally, the matrix of Schur vectors VS.  This gives the Schur factorization A = VS*T*(VS**H).

           Optionally, it also orders the eigenvalues on the diagonal of the
           Schur form so that selected eigenvalues are at the top left. If this is needed specify the Select function parameter
           and return true for each eigenvalue desired.
           Optionally computes a reciprocal condition number for the average of the
           selected eigenvalues (rconde[0]) and computes a reciprocal condition
           number for the right invariant subspace corresponding to the
           selected eigenvalues (rcondv[0]).  The leading columns of VS form an
           orthonormal basis for this invariant subspace.
</remarks>
*)

    procedure EigSchure(D: TVec; VS, T: TMTx; rconde: TVec; rcondv: TVec; Select: TSelectTwoFunction = nil; cSelect: TSelectOneFunctionC = nil;
                                                                          SelectSingle: TSelectTwoFunctionSingle = nil; cSelectSingle: TSelectOneFunctionSingleC = nil); overload;

























    (*<summary>Computes all the eigenvalues, and optionally, the eigenvectors of a generalized symmetric-definite eigenproblem.</summary>
                
<remarks>It can find solution to either of the following problems:
                <code>
                A*X = lambda*B*X, A*B*X = lambda*X, or B*A*X = lambda*X
                </code>
                Here A and B are assumed to be symmetric (Hermitian) and B is also positive definite.
                Eigenvector are stored within V in columns.
</remarks>


              <Example>
              <code>
              var  D: TVec;
                A,B,C: TMtx;
              begin
                CreateIt(D);
                CreateIt(A,B,C);
                try
                  D.SetIt(2  ,False,[0,2]); // vector, length 2, real
                  A.SetIt(2,2,False,[1,2,
                                     2,4]);  // 2x2, real matrix
                  // A must be symmetric
                  B.SetIt(2,2,False,[1,1,
                                     1,2]);  // 2x2, real matrix
                  // B must be symmetric and positive definite
                  A.EigSymGen(B,D);	// Use A and B to find eigenvalues
                finally
                  FreeIt(A,B,C);
                  FreeIt(D);
                end;
              end;
              </code>
              </Example>

              <SeeAlso cref="Eig"/>*)

    procedure EigSymGen(B: TMtx; D: TVec; V: TMtx; EigGenType: TEigGenType = etAzBz); overload;
    procedure EigSymGen(B: TMtx; D: TVec;  EigGenType: TEigGenType = etAzBz); overload;

    (*<summary>Computes generalized eigenvalues with reduction of the symmetric-definite generalized eigenvalues/eigenvectors problem to the normal eigenvalue case.</summary>
              
<remarks>The routine computes selected eigenvalues and optionally also eigenvectors. The problem is of type:
              <code>
               A*X = lambda*B*X, A*B*X = lambda*X, or B*A*X = lambda*X
              </code>
              A and B are symmetric (Hermitian) and B is also positive definite. Eigenvalues and eigenvectors can be selected
              by specifying a range of values. Eigenvectors are not computed, if V is passed as nil. (NULL).
              <para/>
              Tolerance parameter specifies the absolute error tolerance for the eigenvalues.
              An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b]
              of width less than or equal to
              <code>
              Tolerance + EPS / max( |a|,|b| ) ,
              </code>
              where EPS is the machine precision. If Tolerance is less than or equal to zero, then  EPS*|T|  will be used in its place,
              where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.

              Eigenvalues will be computed most accurately when Tolerance is set to twice the underflow threshold, not zero.
              If this routine returns fails , indicating that some eigenvectors did not converge, try setting Tolerance to
              2*UnderflowThreshold.
              <para/>
              If V is assinged, VInfo contains values equal to 0 at indices for which eigenvector calculation converged.
              Eigenvector are stored within V in columns. The returned column count may vary between calls depending on the number
              of eigenvectors that converged. The eigenvectors are normalized as follows:
              <code>
              etAzBz, etBAz, Z**T*B*Z = I;
              etABz        , Z**T*inv(B)*Z = I.
              </code>

              <see href="Lapack Users Guide"/>
</remarks>
*)

    procedure EigSymGen(B: TMtx; D: TVec; Minimum, Maximum: double; V: TMtx; var VInfo: TIntegerArray; Tolerance: double = 0; EigGenType: TEigGenType = etAzBz); overload;
    procedure EigSymGen(B: TMtx; D: TVec; Minimum, Maximum: double; Tolerance: double = 0; EigGenType: TEigGenType = etAzBz); overload;

    (*<summary>Computes generalized eigenvalues with reduction of the symmetric-definite generalized eigenvalues/eigenvectors problem to the normal eigenvalue case.</summary>
              
<remarks>The routine computes selected eigenvalues and optionally also eigenvectors. The problem is of type:
              <code>
               A*X = lambda*B*X, A*B*X = lambda*X, or B*A*X = lambda*X
              </code>

              A and B are symmetric (Hermitian) and B is also positive definite. Eigenvalues and eigenvectors can be selected
              by specifying a range of indexes of values. Eigenvectors are not computed, if V is passed as nil (NULL).
              <para/>
              Tolerance parameter specifies the absolute error tolerance for the eigenvalues.
              An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b]
              of width less than or equal to
              <code>
              Tolerance + EPS / max( |a|,|b| ) ,
              </code>
              where EPS is the machine precision. If Tolerance is less than or equal to zero, then  EPS*|T|  will be used in its place,
              where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.

              Eigenvalues will be computed most accurately when Tolerance is set to twice the underflow threshold, not zero.
              If this routine returns fails , indicating that some eigenvectors did not converge, try setting Tolerance to
              2*UnderflowThreshold.
              <para/>
              If V is assinged, VInfo contains values equal to 0 at indices for which eigenvector calculation converged.
              Eigenvector are stored within V in columns. The returned column count may vary between calls depending on the number
              of eigenvectors that converged. The eigenvectors are normalized as follows:
              <code>
              etAzBz, etBAz, Z**T*B*Z = I;
              etABz        , Z**T*inv(B)*Z = I.
              </code>
</remarks>
*)

    procedure EigSymGen(B: TMtx; D: TVec; LowerRange, UpperRange: integer; V: TMtx; var VInfo: TIntegerArray; Tolerance: double = 0; EigGenType: TEigGenType = etAzBz); overload;
    procedure EigSymGen(B: TMtx; D: TVec; LowerRange, UpperRange: integer; Tolerance: double = 0; EigGenType: TEigGenType = etAzBz); overload;

    (*<summary>Computes eigenvalues of a symmetric (Hermitian) matrix between minimum and maximum.</summary>
               
<remarks>The computation is based on Relatively Robust Representations.

               <para/>
               Tolerance parameter specifies the absolute error tolerance for the eigenvalues.
               An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b]
               of width less than or equal to
               <code>
               Tolerance + EPS / max( |a|,|b| ) ,
               </code>
               where EPS is the machine precision. If Tolerance is less than or equal to zero, then  EPS*|T|  will be used in its place,
               where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.

              Eigenvalues will be computed most accurately when Tolerance is set to twice the underflow threshold, not zero.
              If this routine returns fails , indicating that some eigenvectors did not converge, try setting Tolerance to
              UnderflowThreshold.
</remarks>
*)
    function EigSym(D: TVec; Minimum, Maximum: double; Tolerance: double = 0): TMtx; overload;
    (*<summary>Computes eigenvalues and eigenvectors of a symmetric (Hermitian) matrix between minimum and maximum.</summary>
               
<remarks>The computation is based on Relatively Robust Representations.

              Tolerance parameter specifies the absolute error tolerance for the eigenvalues.
              An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b]
              of width less than or equal to
              <code>
              Tolerance + EPS / max( |a|,|b| ) ,
              </code>
              where EPS is the machine precision. If Tolerance is less than or equal to zero, then  EPS*|T|  will be used in its place,
              where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.

              Eigenvalues will be computed most accurately when Tolerance is set to twice the underflow threshold, not zero.
              If this routine returns fails , indicating that some eigenvectors did not converge, try setting Tolerance to
              UnderflowThreshold.
</remarks>
*)
    function EigSym(D: TVec; V: TMtx; Minimum, Maximum: double; Tolerance: double = 0): TMtx; overload;
    (*<summary>Computes eigenvalues and eigenvectors of a symmetric (Hermitian) matrix between min and max Index.</summary>
               
<remarks>The computation is based on Relatively Robust Representations.

              Tolerance parameter specifies the absolute error tolerance for the eigenvalues.
              An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b]
              of width less than or equal to
              <code>
              Tolerance + EPS / max( |a|,|b| ) ,
              </code>
              where EPS is the machine precision. If Tolerance is less than or equal to zero, then  EPS*|T|  will be used in its place,
              where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.

              Eigenvalues will be computed most accurately when Tolerance is set to twice the underflow threshold, not zero.
              If this routine returns fails , indicating that some eigenvectors did not converge, try setting Tolerance to
              UnderflowThreshold.
</remarks>
*)
    function EigSymRange(D: TVec; V: TMtx; LowRange, HighRange: integer; Tolerance: double = 0): TMtx; overload;
    (*<summary>Computes eigenvalues of a symmetric (Hermitian) matrix between min and max Index.</summary>
               
<remarks>The computation is based on Relatively Robust Representations.

              Tolerance parameter specifies the absolute error tolerance for the eigenvalues.
              An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b]
              of width less than or equal to
              <code>
              Tolerance + EPS / max( |a|,|b| ) ,
              </code>
              where EPS is the machine precision. If Tolerance is less than or equal to zero, then  EPS*|T|  will be used in its place,
              where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form.

              Eigenvalues will be computed most accurately when Tolerance is set to twice the underflow threshold, not zero.
              If this routine returns fails , indicating that some eigenvectors did not converge, try setting Tolerance to
              UnderflowThreshold.
</remarks>
*)
    function EigSymRange(D: TVec; LowRange, HighRange: integer; Tolerance: double = 0): TMtx; overload;

    (*<summary>Computes all eigenvalues of a symmetric (Hermitian) matrix between min and max Index.</summary>
               
<remarks>The computation is based on Relatively Robust Representations.
</remarks>
*)
    function EigSym(D: TVec; V: TMtx): TMtx; overload;


    (*<summary>Computes generalized eigenvalues and eigenvectors of a non-symmetric matrix.</summary>

            
<remarks>A generalized eigenvalue for a pair of matrices (A = Self,B) is a scalar
            lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
            singular. It is usually represented as the pair (alpha,beta), as
            there is a reasonable interpretation for beta = 0, and even for both
            being zero.

            The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies:

            <code>
             A * v(j] = lambda(j) * B * v(j).
            </code>

            The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies:

            <code>
            u(j)**H * A  = lambda(j) * u(j)**H * B .
            </code>

            where u(j)**H is the conjugate-transpose of u(j). The individual
            eigevalues can be computed as:

            <code>
            lambda(j) = dAlpha(j)/dBeta(j);
            </code>
</remarks>
*)
    procedure EigGen(B: TMtx; DAlpha, DBeta: TVec; VL, VR: TMtx); overload;
    procedure EigGen(B: TMtx; DAlpha, DBeta: TVec); overload;

    (*<summary>Computes generalized eigenvalues and eigenvectors of a non-symmetric matrix.</summary>

            
<remarks>Computes for a pair of N-by-N real nonsymmetric matrices (A = Self,B)
            the generalized eigenvalues, and optionally, the left and/or right
            generalized eigenvectors (VL and/or VR).

            A generalized eigenvalue for a pair of matrices (A,B) is a scalar
            lambda or a ratio alpha/beta := lambda, such that A - lambda*B is
            singular. It is usually represented as the pair (alpha,beta), as
            there is a reasonable interpretation for beta = 0, and even for both
            being zero.

            The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies:

            <code>
             A * v(j) = lambda(j) * B * v(j).
            </code>

            The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
            of (A,B) satisfies:

            <code>
            u(j)**H * A  = lambda(j) * u(j)**H * B .
            </code>

            where u(j)**H is the conjugate-transpose of u(j). The individual
            eigevalues can be computed as:

            <code>
            lambda(j) = dAlpha(j)/dBeta(j);
            </code>

            Optionally also computes a balancing transformation to improve the conditioning of the eigenvalues and
            eigenvectors , reciprocal condition numbers for the eigenvalues
            (rconde), and reciprocal condition numbers for the right eigenvectors (rcondv).
</remarks>
*)

    procedure EigGen(B: TMtx; DAlpha, DBeta: TVec; Balance: TBalanceType; BInfo: TEigBalancing;
                         rconde: TVec = nil; rcondv: TVec = nil; VL: TMtx = nil; VR: TMTx = nil); overload;

    (*<summary>Computes generalized eigenvalues and Schur vectors of a non-symmetric matrix.</summary>
            
<remarks>It gives Schur factorization (A = Self) :

            <code>
            (A,B) = ( VL*S*VR^T, VL*T*VR^T )
            </code>

            If only the generalized eigenvalues EigGen is faster. The individual
            eigevalues can be computed as:

            <code>
            lambda(j) = dAlpha(j)/dBeta(j);
            </code>

             Optionally the routine also orders the eigenvalues on the diagonal of the
             Schur form so that selected eigenvalues are at the top left.
             The Select function parameters accepts a function with four parameters. In case of real data, the first is the real and the second is the
             imaginary part of the eigenvalue (alpha), the third is the real beta. In case of complex data, first two are complex dAlpha
             and the second two complex dBeta. The function is to return true, if the specified eigenvalue is to be
             included in to sorting at the top left of the Schur form. If sorting is not required pass nil (NULL) for this
             parameter.

             Optionally computes a reciprocal condition number for the average of the
             selected eigenvalues (rconde[0], rconde[1]) and computes a reciprocal condition
             number for the selected deflating subspaces (rcondv[0], rcondv[1]).
             If condition numbers are not required, pass nil (NULL) for this parameter.
</remarks>
*)

    procedure EigSchureGen(B: TMtx; DAlpha, DBeta: TVec; VL, VR, S, T: TMtx; rconde: TVec; rcondv: TVec; Select: TSelectThreeFunction = nil; cSelect: TSelectTwoFunctionC = nil;
                                                                                                         SelectSingle: TSelectThreeFunctionSingle = nil; cSelectSingle: TSelectTwoFunctionSingleC = nil); overload;



    procedure EigSchureGen(B: TMtx; DAlpha, DBeta: TVec; Select: TSelectThreeFunction = nil; cSelect: TSelectTwoFunctionC = nil;
                                                         SelectSingle: TSelectThreeFunctionSingle = nil; cSelectSingle: TSelectTwoFunctionSingleC = nil); overload;

    (*<summary> Computes generalized singular value decomposition. </summary>
                  
<remarks>Computes the generalized singular value decomposition (GSVD)
                  of an M-by-N real matrix A and P-by-N real matrix B:

                  <code>
                  U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
                  </code>

                  where U, V and Q are orthogonal matrices, and Z' is the transpose of Z.
                  The routine computes optionally the orthogonal transformation matrices U, V and Q.
                  D1 and D2 are diagonal matrices, which on their diagonals contain C and S.

                  <code>
                                K  L
                   D1 =     K [ I  0 ]
                            L [ 0  C ]
                        M-K-L [ 0  0 ]

                                K  L
                   D2 =     L [ 0  S ]
                          P-L [ 0  0 ]

                  </code>

                  The generalized singular values, stored in C and S on exit, have the
                  property:

                  <code>
                  sqr(C) + sqr(S) = I
                  </code>

                  The generalized singular value pairs of A and B in case of rank
                  deficiency are stored like this:

                  <code>
                  c(0:k-1) = 1,
                  s(0:k-1) = 0,

                  and if m-k-l = 0,

                  c(k:k+l-1) = C,
                  s(k:k+l-1) = S,

                  or if m-k-l &lt; 0,

                  c(k:m-1)= C, c(m:k+l-1)=0
                  s(k:m-1) = S, s(m:k+l-1) = 1

                  and

                  c(k+l:n-1) = 0
                  s(k+l:n-1) = 0
                  </code>

                  Effective rank is k + l.

                  If B is an N-by-N nonsingular matrix, then the GSVD of
                  A and B implicitly gives the SVD of A*inv(B):

                  <code>
                  A*inv(B] := U*(D1*inv(D2))*V'
                  </code>

                  If ( A',B')' has orthonormal columns, then the GSVD of A and B is
                  also equal to the CS decomposition of A and B. Furthermore, the GSVD
                  can be used to derive the solution of the eigenvalue problem:

                  <code>
                  A'*A X := lambda* B'*B X
                  </code>

                  In some literature, the GSVD of A and B is presented in the form
                  <code>
                  U'*A*X := ( 0 D1 ),   V'*B*X := ( 0 D2 )
                  </code>
                  where U and V are orthogonal and X is nonsingular, D1 and D2 are "diagonal".
                  The former GSVD form can be converted to the latter form by taking the nonsingular matrix X as:

                  <code>
                  X := Q*( I   0    )
                         ( 0 inv(R) )
                  </code>

                  The function returns the effective numerical rank of (A', B') = K + L.

                  Reference: Lapack v3.4 source code
</remarks>
*)

    function SVDGen(B: TMtx; C, S: TVec; U: TMtx; V: TMtx; Q: TMtx): integer; overload;
    function SVDGen(B: TMtx; C, S: TVec): integer; overload;


    (*<summary> Solves the linear equality-constrained least squares (LSE). </summary>
                  
<remarks>Solves the linear equality-constrained least squares (LSE) problem:

                  <code>
                  minimize || c - A*X ||_2   subject to   B*X = d
                  </code>

                  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
                  vector of length M, and d is a given vector of length P. The sign "_2", denotes Norm L2.
                  It is assumed that  P &lt;= N &lt;= M+P, and

                  <code>
                  rank(B) = P and  rank( (A) ) = N
                                       ( (B) )
                  </code>

                  These conditions ensure that the LSE problem has a unique solution,
                  which is obtained using a generalized RQ factorization of the
                  matrices (B, A) given by

                  <code>
                  B = (0 R)*Q,   A = Z*T*Q
                  </code>

                 References: <para/>
                 1.) Lapack v3.4 source code <para/>
                 2.) http://isites.harvard.edu/fs/docs/icb.topic774900.files/lec16.09.pdf <para/>
                 3.) http://www.cs.ucdavis.edu/~bai/publications/andersonbaidongarra92.pdf <para/>
</remarks>
*)

    function LSESolve(const B: TMtx; const C, D, X: TVec): double; overload;

    (*<summary>  Solves a general Gauss-Markov linear model (GLM) problem. </summary>

            
<remarks>The routine solves a general Gauss-Markov linear model (GLM) problem:
            <code>
                    minimize || y ||_2   subject to   d = A*X + B*y
                            X
            </code>
            where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
            given N-vector. It is assumed that M &lt;= N &lt;= M+P, and

            <code>
                       rank(A] = M    and    rank( A B ] = N.
            </code>

            Under these assumptions, the constrained equation is always
            consistent, and there is a unique solution X and a minimal 2-norm
            solution y, which is obtained using a generalized QR factorization
            of the matrices (A, B) given by

            <code>
               A = Q*(R),   B = Q*T*Z
                     (0)
            </code>

            In particular, if matrix B is square nonsingular, then the problem
            GLM is equivalent to the following weighted linear least squares
            problem
            <code>
                                 minimize || inv(B)*(d-A*X) ||_2
                                         X
            </code>

           where inv(B) denotes the inverse of B. The sign _2, denotes Norm L2.

           References:
           1.) Lapack v3.4 source code
</remarks>
*)


    procedure GLMSolve(const B: TMtx; const D, X, Y: TVec); overload;


    (*<summary>Compares two matrices.</summary>
      
<remarks>Compares Mtx with the calling matrix and returns true if the matrices are equal (if all elements match in position
      and value). Tolerance defines the comparison tolerance. The maximum difference between elements may not exceed: +/-Tolerance.
      If Tolerance is omitted, a direct comparison algorithm is used.
</remarks>


      <Example>
      <code>
      var A,B: Matrix;
        c: boolean;
      begin
          A.SetIt(2,2,false,[1,2,
                             2,4]);  // 2x2, real matrix
          B.SetIt(2,2,false,[1,2,
                             2,4]);  // 2x2, real matrix
          c := A.Equal(B,1e-8); // Check for differences bigger than 0.00000001
          c := (A = B); // Check for an exact match
      end;
      </code>
      </Example>*)
    function Equal(const Mtx: TMtx; Tolerance: double = 0): boolean; overload;
    (*<summary>Allows to specify the comparison method via the Compare parameter.</summary>*)
    function Equal(const Mtx: TMtx; Tolerance: double; Compare: TCompare):boolean; overload;

    (*<summary>Constructs an eye matrix.</summary>
      
<remarks>Construct an eye matrix. The number of rows and columns of an eye matrix is set by ARows and ACols
      parameters. The <see cref="Complex"/> property of an eye matrix is set by AComplex parameter.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
          A.Eye(3,3);
      end;
      </code>
      </Example>*)
    function Eye(ARows,ACols: integer; AComplex: boolean; AIsDouble: boolean): TMtx; overload;
    function Eye(ARows,ACols: integer; const aFloatPrecision: TMtxFloatPrecision): TMtx; overload;

    (*<summary> Applies 2D filtering </summary>
       
<remarks>Computes the dot-product between the kernel matrix and underlaying source matrix elements for each possible position of the kernel
       and stores the result in to the calling object. Typically the kernel is much smaller than the source matrix. The operation is equivalent to the
       2D Convolution and is used also for image resampling, image blurring etc..

       SrcRect must meet the following condtitions:

       SrcRect.Width &lt;= (Src.Cols - Kernel.Cols)
       SrcRect.Height &lt;= (Src.Rows - Kernel.Rows)

       KernelAnchor defines the value to be written in the destination matrix relative to the corresponding position
       of the Kernel in the Src matrix. This can be for example center element (Kernel.Rows div 2, Kernel.Cols div 2), top left (0,0), bottom right (Kernel.Rows-1, Kernel.Cols-1)
       element etc... The X and Y coordinates may not exceed Kernel row or column count.

       The kernel can be square or not. Symmetric or not. The only requirement is that it is rectangular.

       It is the users responsability to select such combination of SrcRect, Kernel size and KernelAnchor to get desired border value processing.
       If the Kernel is 3x3 in size, then it would make sense that SrcRect leaves out 2 rows above and below and also 2 columns left and right in the Src matrix.
       These regions then need to be initialized to some value for example 0 for black color or use the value of the closest border element.

       The DstRect defines the area to be overwritten in the destination matrix. The width and height parameters of DstRect and SrcRect
       need to match. The Size of the destination matrix needs to be big enough to allow DstRect position and dimensions.
</remarks>


      <Example>
      <code>
          var H, A, B: Matrix;
              i: integer;
              SrcRect, DstRect: TRect;
              KernelAnchor: TPoint;
          begin
              H := [[1, 1, 1],
                    [1, 1, 1],
                    [1, 1, 1]]; // simple average kernel

              A := [[  0,      0,   0,    0,   0,     0,     0,   0,   0],
                    [0.5,    0.5,   0.5,    0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                    [  0,      0,     0,    1,   1,     1,   1,   1,   0],
                    [  0,      0,     0,    2,   2,   2,     2,   2,   0],
                    [  0,      0,     0,    3,   3,   3,     3,   3,   0],
                    [  0,      0,     0,    4,   4,     4,   4,   4,   0],
                    [  0,      0,     0,    5,   5,     5,   5,   5,   0],
                    [  0,      0,     0,    6,   6,     6,   6,   6,   0],
                    [0.5,    0.5,   0.5,    0.5, 0.5,   0.5, 0.5, 0.5, 0.5]];

              SrcRect := TRect.Create(3,2, A.Cols-1, A.Rows-1 );
              DstRect := TRect.Create(0,0, SrcRect.Width, SrcRect.Height);
              KernelAnchor := TPoint.Create(H.Rows div 2, H.Cols div 2); //center element

              B.Size(DstRect.Height, DstRect.Width); //could be bigger also

              B.Filter2D( A, H, SrcRect, DstRect, KernelAnchor);

          //      B = [[  7.5,    10.5,    10.5,  10.5,     7.5],  //top left element at Index A[2,3]
          //           [ 12    ,  18  ,  18    ,  18  ,  12  ],
          //           [ 18    ,  27  ,  27    ,  27  ,  18  ],
          //           [ 24    ,  36  ,  36    ,  36  ,  24  ],
          //           [ 30    ,  45  ,  45    ,  45  ,  30  ],
          //           [ 23.5,    34.5,    34.5,  34.5,    23.5]]

          end;
      </code>
      </Example>*)

    function Filter2D(const Src, Kernel: TMtx; const SrcRect, DstRect: TMtxRect; const KernelAnchor: TMtxPoint; const Buffer: TVecInt = nil): TMtx; overload;

    (*<summary>Applies 2D filtering.</summary>
        
<remarks>The result is stored in to the calling object. The size of the calling object is set to match SrcRect dimensions.

       Important: The allocated size of the destination will never be overwritten, but the value of samples on the edge of the Dst matrix
       could be computed from elements outside of the Src thus making them appear to be random, because uninitialized memory was being
       referenced, if the parameters are not set carefully.
</remarks>
*)

    function Filter2D(const Src, Kernel: TMtx; const SrcRect: TMtxRect; const KernelAnchor: TMtxPoint; const Buffer: TVecInt = nil): TMtx; overload;

    (*<summary>Applies 2D filtering.</summary>
        
<remarks>The function will assume that Src has a border which is (Kernel.Cols div 2+1) wide on left and right and
        border which is (Kernel.Rows div 2 + 1) high on top and bottom. Kernel will be applied with its center element
        as the anchor. The filtered result will be stored in to the calling object without the extra borders. The size
        of the calling object is set automatically.

        It is the users responsability to initialize the border elements in the Src.
</remarks>
*)

    function Filter2D(const Src, Kernel: TMtx; const Buffer: TVecInt = nil): TMtx; overload;


    (*<summary>Forward parallel in-place 1D FFT.</summary>
      
<remarks>Performs forward 1D FFT on each row of the matrix. See <see cref="Vector.FFT"/> for
      more info on the forward FFT.
</remarks>
*)
    function FFT1D: TMtx; overload;
    (*<summary>Forward parallel not in-place 1D FFT. The size of the destination is set automatically.</summary>*)
    function FFT1D(const Mtx: TMtx): TMtx; overload;
    (*<summary>Forward parallel in-place 1D FFT from real to complex.</summary>
      
<remarks>Performs forward 1D FFT from real to complex on each row of the matrix. See <see cref="Vector.FFTFromReal"/> for
      more info on the forward real FFT.
</remarks>
*)
    function FFT1DFromReal: TMtx; overload;
    (*<summary>Forward parallel not in-place 1D real to complex FFT. The size of the destination is set automatically.</summary>*)
    function FFT1DFromReal(const Mtx: TMtx): TMtx; overload;

    (*<summary>Forward two-dimentional Fast Fourier Transformation from real/complex to complex.</summary>
      
<remarks>The transformation is applied in-place. The source matrix may be real or complex.
      The result will be always complex. The size of the calling matrix is not changed.
      (rows and cols will not chage).
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt(2,4,False,
                  [1, 2, 3, 4,
                  -5, 6,-7, 8]);
          a.FFT2D;
          // result will be
          [(12,0), ( 0,4),  (-28,0), (0,-4),
           ( 8,0), (-4,0),  ( 24,0), (-4,0)]
      end;
      </code>
      </Example>

      <SeeAlso cref="FFT2DFromReal"/>
      <SeeAlso cref="IFFT2D"/>
      <SeeAlso cref="IFFT2DToReal"/>*)
    function FFT2D: TMtx; overload;

    (*<summary>Forward two-dimentional Fast Fourier Transformation from real/complex to complex.</summary>
      
<remarks>The transformation is applied on data in Mtx matrix and results are saved in the calling matrix.
      The source matrix may be real or complex. The source matrix is not changed.
      The calling matrix will be complex and will be of the same size as the source matrix.
      (rows and cols will not chage).
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,4,False,
                  [1, 2, 3, 4,
                  -5, 6,-7, 8]);

          b.FFT2D(a);
          // result will be
 //         [(12,0), ( 0,4),  (-28,0), (0,-4),
//           ( 8,0), (-4,0),  ( 24,0), (-4,0)]
      end;
      </code>
      </Example>

      <SeeAlso cref="FFT2DFromReal"/>
      <SeeAlso cref="IFFT2D"/>
      <SeeAlso cref="IFFT2DToReal"/>*)
    function FFT2D(const Mtx: TMtx): TMtx; overload;

    (*<summary>Forward two-dimentional Fast Fourier Transformation for real numbers.</summary>
      
<remarks>The transformation is applied in-place. The source matrix must be real. An exception will be raised, if the source matrix is complex.
      The calling matrix stays real and does not change it's size, if <see cref="FFTStorageFormat"/> was set to fsfPack or to fsfPerm.
      If the <see cref="FFTStorageFormat"/> property was set to fsfCCS then the calling matrix
      becomes complex and is resized up to [Rows, Cols div 2],
      i.e. matrix changes <see cref="Complex"/> property, but does not reallocate storage for elements.
      The number of element which are involved in the transformation depends on the property <see cref="FFTStorageFormat"/>.
      If that property is set to fsfPerm or to fsfPack, then all elements are involved into the trasformation.
      If that property is set to fsfCCS (which is default), then number of element which are involved into the transformation depends
      on the property <see cref="FFTOddLength"/> and
      these rules will be followed:

      * Number of source columns must be even and more then two. Number of source rows must be more than two. Exception will be raised otherwise;
      * if <see cref="FFTOddLength"/> is set to False, elements from range [0..Cols-2] x [0..Rows-2] will be involved into transformation;
      * if <see cref="FFTOddLength"/> is set to True, elements from range [0..Cols-1] x [0..Rows-2] will be involved into transformation;

      Note
        Not all source elements are involved into transformation but all elements in the result matrix are needed for the inverse transformation.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt (4,4,False,
                   [1,  2,  3,  4,
                   -5,  6, -7,  8,
                    9, 12,-11, 10,
                   16,-15,-14,  0]);

          a.FFTStorageFormat := fsfCCS;
          a.FFTOddLength := False;

          // the next elements are involved into transformation
//              [1, 2,
//              -5, 6]

          a.FFT2DFromReal;
          // result will be
          // [(4,0), (-12,0),
          //  (0,0), (0,0),
          //  (2,12), (10,10),
          //  (0,-15), (0,0)]

          // after inverse transformation (a.IFFT2DToReal) only elements in range
          // [0..Col-2] x [0..Rows-2] will be reconstructed, other elements will be undefined
          //  [1, 2, undef, undef,
          //  -5, 6, undef, undef,
          //  undef, undef, undef, undef,
          //  undef, undef, undef, undef]
          //
          // if a.FFTOddLength is set to true,
          // then the range of reconstruction would be [0..Col-1] x [0..Rows-2].
      end;
      </code>
      </Example>

      <SeeAlso cref="FFT2D"/>
      <SeeAlso cref="IFFT2D"/>
      <SeeAlso cref="IFFT2DToReal"/>*)
    function FFT2DFromReal: TMtx; overload;

    (*<summary>Forward two-dimentional Fast Fourier Transformation from real to complex.</summary>
      
<remarks>The transformation is applied on the Mtx matrix and results are saved in the calling matrix.
      The Mtx matrix must be real. And exception will be raised if the source matrix is complex.
      The source matrix will not be changed. The calling matrix will be real and will be resized up to [Mtx.Rows,Mtx.Cols], if <see cref="FFTStorageFormat"/> is set to fsfPack or to fsfPack.
      If <see cref="FFTStorageFormat"/> is set to fsfCCS, calling matrix will be complex and will be resized up to [Mtx.Rows, Mtx.Cols div 2].
      The number of element which are involved in transformation depends on the property <see cref="FFTStorageFormat"/>.
      If that property is set to fsfPerm or to fsfPack, then all the source elements are involved into the trasformation.
      If that property is set to fsfCCS (which is default), then the number of elements which are involved into the transformation depends on the property <see cref="FFTOddLength"/> and
      these rules will be followed:

      * Number of source columns must be even and more then two. Number of source rows must be more than two. Exception will be raised otherwise;
      * if <see cref="FFTOddLength"/> is set to False, elements from range [0..Mtx.Cols-2] x [0..Mtx.Rows-2] will be involved into transformation;
      * if <see cref="FFTOddLength"/> is set to True, elements from range [0..Mtx.Cols-1] x [0..Mtx.Rows-2] will be involved into transformation;

      Note
        Not all source elements are involved into transformation but all elements in the result matrix are needed for the inverse transformation.
</remarks>


      <SeeAlso cref="FFT2D"/>
      <SeeAlso cref="IFFT2D"/>
      <SeeAlso cref="IFFT2DToReal"/>*)
    function FFT2DFromReal(const Mtx: TMtx): TMtx; overload;

    (*<summary>Flips the matrix elements horizontally.</summary>
      
<remarks>Flip calling matrix elements horizontally - element [row, j] = element [row, Cols-j]. This operation
      is performed on all calling matrix rows.
</remarks>


      <Example>
      <code>
      var  A,B: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);  // 2x2, not complex matrix
          B.FlipHor(A);
          // B becomes:
          // [2,1]
          // [4,2]
      end;
      </code>
      </Example>

      <SeeAlso cref="FlipVer"/>*)
    function FlipHor: TMtx; overload;
    (*<summary>Flip all SrcMtx matrix elements horizontally and store the results in the calling matrix.</summary>
      
<remarks>The flip operation is performed on all SrcMtx matrix rows. The <see cref="Rows"/>, <see cref="Cols"/> and
      <see cref="Complex"/> properties of callign matrix are adjusted automatically.
</remarks>
*)
    function FlipHor(const SrcMtx: TMtx): TMtx; overload;

    (*<summary>Flips the matrix elements vertically</summary>
      
<remarks>Flip calling matrix elements vertically - element [j, col] = element [Rows-j, col]. This operation
      is performed on all calling matrix columns.
</remarks>


      <Example>
      <code>
      var  A,B: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);  // 2x2, not complex matrix
          B.FlipVert(A);
          // B becomes:
          // [2,4]
          // [1,2]
      end;
      </code>
      </Example>

      <SeeAlso cref="FlipHor"/>*)
    function FlipVer: TMtx; overload;
    (*<summary>Flip all SrcMtx matrix elements vertically and store the results in the calling matrix. The flip
      operation is performed on all SrcMtx matrix columns.</summary>
      
<remarks>The <see cref="Rows"/>, <see cref="Cols"/> and
      <see cref="Complex"/> properties of callign matrix are adjusted automatically.
</remarks>
*)
    function FlipVer(const SrcMtx: TMtx): TMtx; overload;

    (*<summary>Constructs a Hankel matrix.</summary>
      
<remarks>Constructs a Hankel matrix whose first column is FirstColumn and whose elements are zero below the first anti-diagonal.
      The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of the
      calling matrix are adjusted automatically.
</remarks>


      <Example>
      <code>
      var v: Vector;
          H: Matrix;
      begin
          v.SetIt(False,[1,2,3,4]);
          H.Hankel(v);
          // H becomes:
          //[1  2  3  4]
          //[2  3  4  0]
          //[3  4  0  0]
          //[4  0  0  0]
      end;
      </code>
      </Example>*)
    function Hankel(const FirstColumn: TVec): TMtx; overload;

    (*<summary>Inverse parallel in-place 1D FFT.</summary>
      
<remarks>Performs inverse 1D FFT on each row of the matrix. See <see cref="Vector.IFFT"/> for
      more info on the inverse FFT. NoScale parameter allows the scaling
      to be turned off. The scaling scales the result by 1/(Length_Of_FFT).
</remarks>
*)
    function IFFT1D(NoScale: boolean = False): TMtx; overload;

    (*<summary>Inverse parallel not in-place 1D FFT.</summary>
       
<remarks>The size of the destination is set automatically.
</remarks>
*)
    function IFFT1D(const Mtx: TMtx; NoScale: boolean = False): TMtx; overload;

    (*<summary>Inverse parallel in-place 1D FFT from complex to real.</summary>
      
<remarks>Performs inverse 1D FFT from complex to real on each row of the matrix. See <see cref="IFFT1D"/> for
      more info on the inverse complex to real 1D FFT. NoScale parameter allows the scaling
      to be turned off. The scaling scales the result by 1/(Length_Of_FFT)
</remarks>
*)
    function IFFT1DToReal(NoScale: boolean = False): TMtx; overload;
    (*<summary>Inverse parallel not in-place 1D complex to real FFT.</summary>
      
<remarks>The size of the destination is set automatically.
</remarks>
*)
    function IFFT1DToReal(const Mtx: TMtx; NoScale: boolean = False): TMtx; overload;

    (*<summary>Inverse two-dimensional Fast Fourier Transformation from complex to complex.</summary>
      
<remarks>Transformation is applied in-place. Source matrix must be complex. If source matrix is real,
      an exception will be raised.
      result matrix will be complex. Size of the calling matrix is not changed.
      NoScale parameter allows the scaling to be turned off.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt (2,4,False,
                   [1, 2, 3, 4,
                   -5, 6,-7, 8] );
          a.ExtendToComplex;

          a.IFFT2D;
          // result will be
          // [(1.5, 0), (0, -0.5), (-3.5, 0),  (0, 0.5),
          // [1, 0), (-0.5, 0),    (3, 0), (-0.5, 0) ]
      end;
      </code>
      </Example>

      <SeeAlso cref="FFT2D"/>
      <SeeAlso cref="FFT2DFromReal"/>
      <SeeAlso cref="IFFT2DToReal"/>*)
    function IFFT2D(NoScale: boolean = False): TMtx; overload;

    (*<summary>Inverse two-dimensional Fast Fourier Transformation from complex to complex.</summary>
      
<remarks>Transformation is applied on Mtx matrix and results are saved in the calling matrix.
      The source matrix must be complex. If source matrix is real, an exception will be raised.
      The source matrix is not changed. Calling matrix will be complex and will have the same size as
      the source matrix. NoScale parameter allows the scaling to be turned off.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt (2,4,False,
                   [1, 2, 3, 4,
                   -5, 6,-7, 8] );
          a.ExtendToComplex;

          b.IFFT2D(a);
          // result will be
//          [(1.5, 0), (0, -0.5), (-3.5, 0),  (0, 0.5),
//             (1, 0), (-0.5, 0),    (3, 0), (-0.5, 0) ]

      end;
      </code>
      </Example>

      <SeeAlso cref="FFT2D"/>
      <SeeAlso cref="FFT2DFromReal"/>
      <SeeAlso cref="IFFT2DToReal"/>*)
    function IFFT2D(const Mtx: TMtx; NoScale: boolean = False): TMtx; overload;

    (*<summary>Inverse two-dimensional Fast Fourier Transformation from complex to real.</summary>
      
<remarks>Transformation is applied in-place. Source matrix Complex property must be false, if <see cref="FFTStorageFormat"/> was set to fsfPack or to fsfPack.
      Source matrix Complex property must be True, if <see cref="FFTStorageFormat"/> was set to fsfCCS.      The calling matrix becomes real. Size of the calling matrix is not changed if <see cref="FFTStorageFormat"/> was set to fsfPack or to fsfPack.
      Size of calling matrix will be set to [Rows, 2*Cols], if <see cref="FFTStorageFormat"/> is set to fsfCCS,
      i.e. matrix changes <see cref="Complex"/> property, but does not reallocate storage for elements.
      All elements are involved into inverse transformation, but number of reconstructed elements depends on the property <see cref="FFTStorageFormat"/>.
      If that property is set to fsfPerm or to fsfPack, then all elements will be reconstructed after inverse transformation.
      If that property is set to fsfCCS (which is default), then the number of element's which will be reconstructed depends on the
      property <see cref="FFTOddLength"/> and these rules will be followed:

      * Number of source columns and rows must be more than one. Exception will be raised otherwise;
      * if <see cref="FFTOddLength"/> is set to False, elements in range [0..Cols-2] x [0..Rows-2] will be reconstructed;
      * if <see cref="FFTOddLength"/> is set to True, elements in range [0..Cols-1] x [0..Rows-2] will be reconstructed;
        Here Cols and Rows are the number of columns and rows of the calling matrix after the inverse transformation.

      Note
        Both properties <see cref="FFTStorageFormat"/> and <see cref="FFTOddLength"/> must be set to the same values for forward and inverse transformation
        to get reversible results. NoScale parameter allows the scaling to be turned off.
</remarks>


      <Example>
      <code>
      var a: Matrix;
      begin
          a.SetIt (4,4,False,
                   [1,  2,  3,  4,
                   -5,  6, -7,  8,
                    9, 12,-11, 10,
                   16,-15,-14,  0]);

          a.FFTStorageFormat := fsfCCS;
          a.FFTOddLength := TRUE;

          // the next elements are involved into transformation
//              [1, 2, 3,
//              -5, 6, -7]

          a.FFT2DFromReal;
          // result will be
          // [(0,0), (-6, -10.39),
          //  (0,0), (3, 12.12),
          //  (12,12), (-11,10),
          //  (0,-15), (-14,0)]

          a.IFFT2DToReal;
          // [ 1,  2,  3, 0
          //  -5,  6, -7, 0
          //  12, 12,-11, 10
          //   0,-15,-14, 0]

          // the next elements are reconstructed
          // [ 1, 2, 3,  undef,
          //  -5, 6, -7, undef,
          //  undef, undef, undef, undef,
          //  undef, undef, undef, undef]
          //
          // if a.FFTOddLength is set to False,
          // then range of reconstruction would be one column less, i.e.
          // [ 1, 2, undef, undef,
          //  -5, 6, undef, undef,
          //  undef, undef, undef, undef,
          //  undef, undef, undef, undef]
      end;
      </code>
      </Example>

      <SeeAlso cref="FFT2D"/>
      <SeeAlso cref="FFT2DFromReal"/>
      <SeeAlso cref="IFFT2D"/>*)
    function IFFT2DToReal(NoScale: boolean = False): TMtx; overload;

    (*<summary>Inverse two-dimensional Fast Fourier Transformation from complex to real.</summary>
      
<remarks>Transformation is applied on source Mtx matrix and results are saved in the calling matrix.
      Source matrix must be real, if <see cref="FFTStorageFormat"/> was set to fsfPack or to fsfPack.
      Check the storage format requirements to see how the complex numbers are to be stored in a real matrix.
      Source matrix must be complex, if <see cref="FFTStorageFormat"/> was set to fsfCCS.
      The source matrix will not be changed. The calling matrix becomes real.
      Size of the calling matrix will be set to [Mtx.Rows,Mtx.Cols], if <see cref="FFTStorageFormat"/> was set to fsfPack or to fsfPack.
      Size of calling matrix will be set to [Mtx.Rows, 2*Mtx.Cols], if <see cref="FFTStorageFormat"/> is set to fsfCCS.
      All element are involved into the inverse transformation, but the number of reconstructed elements depends on the property <see cref="FFTStorageFormat"/>.
      If that property is set to fsfPerm or to fsfPack, then all elements will be reconstructed after inverse transformation.
      If that property is set to fsfCCS (which is default), then the number of elements which will be reconstructed depends on the property
      <see cref="FFTOddLength"/> and these rules will be followed:

      * Number of source columns and rows must be more than one. An exception will be raised otherwise;
      * if <see cref="FFTOddLength"/> is set to False, elements in range [0..Cols-2] x [0..Rows-2] will be reconstructed;
      * if <see cref="FFTOddLength"/> is set to True, elements in range [0..Cols-1] x [0..Rows-2] will be reconstructed;
      * Here Cols and Rows are the number of columns and rows of the calling matrix after the inverse transformation.

      Note
        Both properties <see cref="FFTStorageFormat"/> and <see cref="FFTOddLength"/> must be set to the same values for forward and inverse transformation to get reversible results.
        NoScale parameter allows the scaling to be turned off.
</remarks>


      <SeeAlso cref="FFT2D"/>
      <SeeAlso cref="FFT2DFromReal"/>
      <SeeAlso cref="IFFT2D"/>*)
    function IFFT2DToReal(const Mtx: TMtx; NoScale: boolean = False): TMtx; overload;

    (*<summary>Calculates matrix inverse (Mtx^-1).</summary>
      
<remarks>Calculate the inverse (Mtx^-1) of the calling matrix. If the calling matrix is not <see cref="Quadratic"/>,
      an exception is raised. Parameter <see cref="TMtxType"/> determines which optimized method will
      be used for calculating the inverse matrix. If MtxType is omitted, the default value mtGeneral
      (general quadratic matrix) is used.

      Note
        The MtxType parameter is not verified. To determine if the calling matrix type is actually MtxType,
        use the <see cref="DetectMtxType"/> method.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);  // 2x2, real matrix
          A.Inv;
      end;
      </code>
      </Example>

      <SeeAlso cref="DetectMtxType"/>
      <SeeAlso cref="MtxError"/>*)
    function Inv(): TMtx; overload;
    (*<summary>Compute inverse of the matrix.</summary>
      
<remarks>Specify the matrix type to select the most performance efficient algorithm.
</remarks>
*)
    function Inv(MtxType: TMtxType): TMtx; overload;

    (*<summary>The inverse of matrix elements.</summary>
      
<remarks>Calculates the inverse of all matrix elements in place. The computation occurs after first limiting the
      magnitude of each elements by the lower bound of Treshhold. The limiting operation is performed to avoid
      division by zero. Since Treshold represents a magnitude, it is always real and must always be positive.
      For complex versions, the magnitude of the input is limited, but the phase remains unchanged. Zero-valued
      input is assumed to have zero phase. To bypass the limiting operation set the Threshold to zero.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);  // 2x2, not complex matrix
          A.InvElem(1.0e-7);
      end;
      </code>
      </Example>

      <SeeAlso cref="MulElem"/>*)
    function InvElem(): TMtx; overload;
    (*<summary>Invert all Mtx elements and store them in the calling matrix.</summary>*)
    function InvElem(Threshold: double): TMtx; overload;
    (*<summary>Invert all Mtx elements and store them in the calling matrix.</summary>
      
<remarks>The <see cref="Rows"/>,  <see cref="Cols"/> and <see cref="Complex"/> properties of the
      calling matrix are set implicitly to match Mtx matrix.
      If Treshold is omitted then the default value 1/MAXNUM is used.
</remarks>
*)
    function InvElem(const SrcMtx: TMtx; Threshold: double = 1/MAXNUM): TMtx; overload;

    (*<summary>Construct the Kac (Clement) matrix.</summary>
      
<remarks>Constructs the so called Kac (Clement) (n+1)x(n+1) tridiagonal matrix, defined by:

      <code>
      | 0, n, 0, ...    ,  0 |
      | 1, 0, n-1, 0, ..., 0 |
      | 0, 2, 0, n-2, 0, ... |
      | ...........n-1, 0, 1 |
      | 0, ... ........, n, 0|
      </code>

      The eigenvalues of so defined matrix are 2k-n for k=0,1,2,...,n.
</remarks>
*)
    function Kac(n: Integer): TMtx;

    (*<summary>The Kronecker product between two vectors.</summary>
      
<remarks>Calculates the Kronecker product between Vec1 and Vec2 and stores the result in the
      calling matrix. The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/>
      properties of calling matrix are set automatically.
</remarks>


      <Example>
      <code>
      var A: Matrix;
          V1,V2: Vector;
      begin
          V1.SetIt(False,[1,2,3]);
          V2.SetIt(False,[4,5,6]);
          A.Kron(V1,V2);
          // A becomes:
          // [4   5  6]
          // [8  10 12]
          // [12 15 18]
      end;
      </code>
      </Example>

      <SeeAlso cref="Vector.Kron"/>*)
    function Kron(const Vec1, Vec2: TVec): TMtx; overload;
    function Kron(const Mtx1, Mtx2: TMtx): TMtx; overload;

    
    function LMinQR(L,Q,R: TMtx): TMtx; overload;

    (*<summary>Constructs lower triangular matrix.</summary>
      
<remarks>The method uses Mtx matrix to construct a lower triangular matrix. The results are stored in the calling matrix.
      If the ZeroLower parameter is true then the calling matrix superdiagonal elements will be set to zero - otherwise
      the superdiagonal elements will not be initialized. If the Diagonal boolean parameter is true then the Mtx matrix
      main diagonal elements will be copied to the calling matrix main diagonal elements. If the Diagonal parameter is
      false, the calling matrix main diagonal elements will be set to zero.
</remarks>


      <Example>
      <code>
      var  A,B: Matrix;
      begin
          A.SetIt(2,1,True,[1,2,
                            2,4]);  // 2x2, not complex matrix
          B.LowerTriangle(A,True,True);
          // B becomes:
          //  [1,0,
          //  [2,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="UpperTriangle"/>*)
    function LowerTriangle(const Mtx: TMtx; ZeroUpper, Diagonal: boolean): TMtx; overload;

    (*<summary>QR or LQ factorization.</summary>
      
<remarks>Performs QR or LQ factorization. If <see cref="Rows"/> is bigger or equal than <see cref="Cols"/>
      for the calling matrix, the linear system of  equations is overdetermined and the method performs QR factorization.
      The  matrix L is not used and can be nil. If Rows is smaller than Cols, the linear system equations is
      underdetermined and the method performs LQ factorization. The matrix R is not used and can be nil. If the
      Matrix Q is nil, then it's not explicitly formed. If the pointer is not nil, the full size Q is computed.
      If you do not want economy size L, Q and R, set MinSize to false. The calling matrix must have full rank.
      If the rank is not full, use the <see cref="SVD"/> method.
</remarks>


      <Example>
      <code>
      var Q,R,A: Matrix;
      begin
          A.SetIt(3,2,False,[1,2,
                              3,4,
                             3,3]);
          A.LQR(nil,Q,R,false);
      end;
      </code>
      </Example>

      <SeeAlso cref="SVD"/>
      <SeeAlso cref="LQRSolve"/>*)
    function LQR(const L,Q,R: TMtx; Minimized: boolean = true): TMtx; overload;
    (*<summary>QR or LQ factorization.</summary>
      
<remarks>Performs QR factorization with optional pivoting or LQ factorization. The pivoting of columns
      in the calling matrix is performed only when P is not nil and Rows &gt; Cols.

      The P[i] holds the permutation of columns in A, so that:
      <code>

      P(A) = Q*R

      </code>
</remarks>
*)
    function LQR(const L,Q,R: TMtx; const P: TVecInt; Minimized: boolean = true): TMtx; overload;

    (*<summary>Solve overdetermined or underdetermined system of real linear equations.</summary>
      
<remarks>Solve overdetermined or underdetermined real linear systems involving a Rows-by-Cols matrix or its transpose,
      using a QR or LQ factorization of the calling matrix. It is assumed that the calling matrix has full rank.
      The following options are provided:

      <b>1.</b>If Op = opNone and m &gt;= n:  find the least squares solution of an overdetermined system, i.e., solve
      the least squares problem
      <code>minimize || B - A*X ||.</code>

      <b>2.</b>If Op = opNone and m &lt; n:  find the minimum norm solution of an underdetermined system
      <code>A * X = B.</code>

      <b>3.</b>If Op = opTrans and m &gt;= n:  find the minimum norm solution of an undetermined system
      <code>A**T * X = B.</code>

      <b>4.</b>If Op = opTran and m &lt; n:  find the least squares solution of an overdetermined system, i.e., solve
      the least squares problem
      <code>minimize || B - A**T * X ||</code>

      <b>5.</b>If Op = opHerm and m &gt;= n:  find the minimum norm solution of an undetermined system
      <code>A**H * X = B.</code>

      <b>6.</b>If Op = opHerm and m &lt; n:  find the least squares solution of an overdetermined system, i.e., solve
      the least squares problem
      <code>minimize || B - A**H * X ||.</code>

      Note
        If the parameters are of TVec type (const Vectors), the routine requires less pre and post processing.
</remarks>


      <SeeAlso cref="LQR"/>
      <SeeAlso cref="SVDSolve"/>
      <SeeAlso cref="MtxError"/>*)
    function LQRSolve(const B, X: TMtx; const R: TMtx = nil; Op: TMtxOperation = opNone): TMtx; overload;
    (*<summary>Matrix version of LQRSolve. Perfroms a LQRSolve for each B and X matrices columns in single pass.</summary>*)
    function LQRSolve(const B, X: TVec; const R: TMtx = nil;Op: TMtxOperation = opNone): TMtx; overload;

    (*<summary>Rank deficient version of LQRSolve. Perfroms LQRSolve for B vector.  </summary>
      
<remarks>Computes the minimum-norm solution to a linear least squares problem:
      <code>
      minimize || A * X - B ||
      </code>
      using a complete orthogonal factorization of A. A is an M-by-N  matrix which may be rank-deficient.

      The function returns the effective rank of the matrix A.  The effective rank is determined with the rcond parameter.
      A is factorized in such a way that condition number of leading submatrix of A will be less then 1/rcond.
      Set value of rcond to 1E-6 for less strict and to 1E-3 for more strict stability conditition.
      If R is assigned, the function returns the factorization of matrix A.
      Op parameter specified the operation to be applied to A before the computation.
</remarks>
*)
    function LQRSolve(const B, X: TVec; rcond: double; const R: TMtx = nil;  Op: TMtxOperation = opNone): integer; overload;

    (*<summary>Rank deficient version of LQRSolve. Perfroms LQRSolve for each B column in one pass.  </summary>
      
<remarks>Computes the minimum-norm solution to a linear least squares problem:
      <code>
      minimize || A * X - B ||
      </code>
      using a complete orthogonal factorization of A. A is an M-by-N  matrix which may be rank-deficient.

      The function returns the effective rank of the matrix A.  The effective rank is determined with the rcond parameter.
      A is factorized in such a way that condition number of leading submatrix of A will be less then 1/rcond.
      If R is assigned, the function returns the factorization of matrix A.
      Op parameter specified the operation to be applied to A before the computation.
</remarks>
*)
    function LQRSolve(const B,X: TMtx; rcond: double; const R: TMtx = nil;  Op: TMtxOperation = opNone): integer; overload;

    (*<summary>General LU, Cholesky or Bunch-Kaufmann factorization.</summary>
      
<remarks>Performs a general LU, Cholesky or Bunch-Kaufmann factorization on the calling matrix and stores the results in lower
      triangular matrix L and upper triangular matrix U. The MtxType parameter defines which optimized method will be used to
      calculate the LU factorization. The P parameter stores the row permutations in the IValues.
      Depending on the type of the calling matrix the LU method will use specific optimized
      algorithm to perform the factorization. If you don't know the <see cref="TMtxType"/> of the calling matrix, you
      can omit the MtxType parameter (the default value mtGeneral will be used) or determine the type of matrix with the
      <see cref="DetectMtxType"/> method. The following methods can be used to calculate the LU factorization:

      * Matrix type is mtSymmPosDef, mtHermPosDef, mtBandSymmPosDef, mtBandHermPosDef : Cholesky factorization.
      * mtSymmetric : Bunch-Kaufmann factorization.
      * mtHermitian : Bunch-Kaufmann factorization (only for complex calling matrix).
      * mtTriangle : <see cref="LowerTriangle"/> or <see cref="UpperTriangle"/> method.
      * mtGeneral, mtBandGeneral : general m x n matrix LU factorization.

      Note
        An exception will be raised if the calling matrix <see cref="Quadratic"/> property is not true and
        matrix storage format is not banded.
</remarks>


      <Example>
      <code>
      var LU,A: Matrix;
          P: TVec;
      begin
          A.SetIt(3,2,False,[1,2,
                             3,4]);
          A.LU(LU,P);
      end;
      </code>
      </Example>

      <SeeAlso cref="LUSolve"/>*)
    function LU(const Dst: TMtx; const P: TVecInt; MtxType: TMtxType = mtGeneral): TMtx;

    (*<summary>Solves system of linear equations by using LU factorization.</summary>
      
<remarks>Uses the LU factorization to solve the system of linear equations. <c>AX = B</c>.
      The matrix must be full rank. If there are more rows than columns use the least square solver <see cref="LQRSolve"/>
      and if the matrix is also rank deficient use the <see cref="SVDSolve"/> method. MtxType allows the selection of an
      optimized algorithm and Op defines the operation to be performed on the calling matrix prior to solve.

      LUSolve also supports banded matrices. The banded matrix storage is defined with the help of two additional properties:
      <see cref="SubDiag"/> and <see cref="SuperDiag"/>. SubDiag defines the number of non-zero subdiagonals and the
      SuperDiag the number of non-zero super diagonals. An example of the storage format for the first sub and super diagonal:

      <code>
      A.SubDiag := 1;
      A.SuperDiag := 1;
      A.Size(3,6);
      // ...
      [0 , ud2, ud3, ud4 ,ud5 ,ud6]   first upper diagonal
      [md1, md2, md3, md4, md5, md6]      main diagonal
      [ld1, ld2, ld3, ld4, ld5,  0] first lower diagonal
      </code>

      The columns must be aligned. All the diagonals between the SubDiag and SuperDiag diagonals including the main diagonal must
      always be included. Similarly you can define two sub/super diagonal storage format :

      <code>
      aXY =   (X Row Index, Y Column Index)

      [a11,  a12,  a13,      0,     0,     0]
      [a21,  a22,  a23,  a24,     0,     0]
      [a31,  a32,  a33,  a34,  a35,     0]
      [0,      a42,  a43,  a44,  a45, a46]
      [0,          0,  a53,  a54,  a55, a56]
      [0,          0,      0,  a64,  a65, a66]

      A.SubDiag := 2;
      A.SuperDiag := 2;
      A.Size(5,6);

      [0   ,  0,  a13, a24 ,a35, a46]    second upper diagonal
      [0   , a12, a23, a34, a45, a56]     first upper diagonal
      [a11 , a22, a33, a44, a55, a66]      main diagonal
      [a21 , a32, a43, a54, a65,   0]     first lower diagonal
      [a31 , a42, a53, a64,   0,   0]     second lower diagonal

      </code>

      If you would like to solve X for several different B vectors (from the formula AX= B), you can pass TMtx
      objects to LUSolve method. With one call you solve the system for several different B vectors and save
      time.
</remarks>


      <SeeAlso cref="LU"/>
      <SeeAlso cref="MtxError"/>
      <SeeAlso cref="RefineSolution"/>
      <SeeAlso cref="ForwError"/>
      <SeeAlso cref="BackError"/>
      <SeeAlso cref="ConditionNr"/>
      <SeeAlso cref="ConditionNumber"/>*)
    function LUSolve(const B, X: TVec; MtxType: TMtxType = mtGeneral; Operation: TMtxOperation = opNone): TMtx; overload;
    (*<summary>Desc Matrix version of LUSolve. Perfroms a LUSolve for each B and X matrices columns in single pass.</summary>*)
    function LUSolve(const B, X: TMtx; MtxType: TMtxType = mtGeneral; Operation: TMtxOperation = opNone): TMtx; overload;  

    (*<summary>Performs factorization for LUSolve. </summary>
               
<remarks>Mtx, origMtx and ipiv contain result of factorization on exit. This result is again to be passed to the LUSolve together with B to obtain solution for X.
</remarks>
*)
    function LUSolve(MtxType: TMtxType; const Mtx, OrigMtx: TMtx; const pipiv: TVecInt): TMtx; overload;
    (*<summary>Finds solution with an already precomputed factorization. </summary>
               
<remarks>Mtx, origMtx and ipiv contain result of factorization on exit. The factorization was obtained with a previous call to LUSolve, which did not require B and X params.
</remarks>
*)
    function LUSolve(const B,X: TVec; MtxType: TMtxType;  Operation: TMtxOperation; const Mtx, OrigMtx: TMtx; const pipiv: TVecInt): TMtx; overload;
    (*<summary>Finds solution with an already precomputed factorzation. </summary>
               
<remarks>Mtx, origMtx and ipiv contain result of factorization on exit. The factorization was obtained with a previous call to LUSolve, which did not require B and X params.
</remarks>
*)
    function LUSolve(const B,X: TMtx; MtxType: TMtxType;  Operation: TMtxOperation; const Mtx, OrigMtx: TMtx; const pipiv: TVecInt): TMtx; overload;


    (*<summary>Calculates the mean value of each of the matrix columns.</summary>
      
<remarks>Calculate the mean vale of each of the calling matrix columns and store the results in result vector.
      The <see cref="Length"/> and <see cref="Complex"/> properties of the
      result vector are adjusted automatically.
</remarks>


      <Example>
      <code>
      var A: Matrix;
          res: Vector;
      begin
          A.SetIt(2,2,false,[1,5,
                            -3,6]);
          A.MeanCols(Res); // res = (-1.0, 5.5)
          //or
          Res := MeanCols(A);
      end;
      </code>
      </Example>

      <SeeAlso cref="MeanRows"/>*)
    procedure MeanCols(const result: TVec); overload;

    (*<summary>Calculates the mean value of each of the matrix rows.</summary>
      
<remarks>Calculate the mean vale of each of the calling matrix rows and store the results in result vector.
      The <see cref="Length"/> and <see cref="Complex"/> properties of the
      result vector are adjusted automatically.
</remarks>


      <Example>
      <code>
      var A: Matrix;
          res: Vector;
      begin
          A.SetIt(2,2,false,[1,5,
                            -3,6]);
          A.MeanRows(res); // res = (3, 1.5)
      end;
      </code>
      </Example>

      <SeeAlso cref="MeanCols"/>*)
    procedure MeanRows(const result: TVec); overload;

    (*<summary>Compute matrix function as a function of matrix.</summary>
      
<remarks>The method allows you to compute any function as a function of the Src matrix. For example, a square of root of the matrix would not
      compute the square root of the elements of the matrix, but instead, the result would be such, that the
      matrix product of two resulting matrices would return the original matrix. The Params parameters allow you to specify aditional parameter for the  Func function.
      Because the method is based on the eigenvalue decomposition and the eigenvalue, the SourceType for symmetric and symmetric positive
      definite matrices has to be defined explicitly.
</remarks>


      <Example>The MtxPower function declaration:

      <code>
      function TMtx.MtxPower(Src: TMtx; Exponent: TCplx; SourceType: TMtxType = mtGeneral): TMtx;
      begin
        MtxPower := MtxFunction(Src,[Exponent],@DoToPower,SourceType);
      end;
      </code>
      </Example>

      <SeeAlso cref="TMtxFunction"/>*)
    function MtxFunction(const Src: TMtx; const Params: array of TCplx; Func: TMtxFunction = nil;
                                          SourceType: TMtxType = mtGeneral): TMtx; overload;

    (*<summary>Calculates the matrix to integer power.</summary>
      
<remarks>Calculate the matrix to any integer power. Because the <see cref="MtxFunction"/> method is based on the eigenvalue
      decomposition and the eigenvalue, the SourceType for symmetric and symmetric positive definite matrices has to be defined explicitly.

      Note
        The algorithm for general matrices will fail on a symmetric matrix.
</remarks>


      <SeeAlso cref="MtxPower"/>*)
    function MtxIntPower(const Src: TMtx; Exponent: Integer): TMtx; overload;

    (*<summary>Calculates the matrix to any power, real or integer.</summary>
      
<remarks>Calculate the matrix to any power, real or integer. It can also be used to compute the square root of the matrix. Because the <see cref="MtxFunction"/>
      method is based on the eigenvalue decomposition and the eigenvalue, the SourceType for symmetric and symmetric positive definite matrices has to be
      defined explicitly.

      Note
        The algorithm for general matrices will fail on a symmetric matrix.
</remarks>


      <SeeAlso cref="MtxSqrt"/>
      <SeeAlso cref="MtxFunction"/>*)
    function MtxPower(const Src: TMtx; Exponent: double; SourceType: TMtxType = mtGeneral): TMtx; overload;
    (*<summary>Calculate the matrix to complex power Exponent.</summary>*)
    function MtxPower(const Src: TMtx; Exponent: TCplx; SourceType: TMtxType = mtGeneral): TMtx; overload;

    (*<summary>Calculates the square root of the matrix.</summary>
      
<remarks>Calculates the square root of the Src matrix and stores the results to calling matrix. The product of the result with itself will
      give the original matrix. Because the <see cref="MtxFunction"/> method is based on the eigenvalue decomposition and the eigenvalue,
      the SourceType for symmetric and symmetric positive definite matrices has to be defined explicitly.

      Note
        The algorithm for general matrices will fail on a symmetric matrix.
</remarks>


      <SeeAlso cref="MtxPower"/>
      <SeeAlso cref="MtxFunction"/>*)
    function MtxSqrt(const Src: TMtx; SourceType: TMtxType = mtGeneral): TMtx; overload;

    (*<summary>Matrix multiplication.</summary>
      
<remarks>Performs matrix multiplication, which is JIT-ed (faster) up to size 64 for square matrices. In most general case the matrix multiplication is defined by the following equation (result = calling matrix):

      <IMG name="mtx002"/>

      where a and b are <See Var="Alfa"/> and <See Var="Beta"/> variables. The default values for a and b are Cplx(1,0) and Cplx(0,0), so the above
      equation is reduced to:

      <IMG name="mtx006"/>

      The Operation1 and Operation2 indicate additional <see cref="TMtxOperation"/>, performed on Mtx1 and Mtx2 respectively.
      Default value for operation is opNone (no additional operation). The Mtx1Type and Mtx2Type parameters indicate the <see cref="TMtxType"/>
      of Mtx1 and Mtx2 matrices. Depending what type of matrices you are multiplying, the Mul method will choose most optimized multiplication method.
      So, choosing the correct values for Mtx1Type and Mtx2Type can significantly speed up the multiplication.
      This overloaded function performs a left side multiply operation Mtx2 with Mtx1 matrix and stores the results in the calling matrix. If Operation1
      and/or Operation2 parameters are specified, perform additional operation on Mtx1 or Mtx2. If Operation1 and/or Operation2 parameters are omitted,
      the default values (no operation) will be used. The <see cref="Rows"/>, <see cref="Cols"/> and
      <see cref="Complex"/> properties of the calling matrix are adjusted automatically. An exception is raised is Mtx1 Cols property does not match
      the Mtx2 Rows property (matrix multiplication is not possible). An exception is raised, if <see cref="Complex"/> property of Mtx1 and Mtx2
      does not match.

      Notes
        1. NOTE: If you are not sure, which <see cref="TMtxType"/> of matrix are you multiplying, you can use the mtGeneral type (general case).
          You can also use the <see cref="DetectMtxType"/> method to determine the type of matrix.
        2. The routine is multithreaded, if specified by the environment variable.
</remarks>


      <Example>
      <code>
      var  A,B,C: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);
          B.SetIt(2,2,False,[1,2,
                             2,4]);
          C.Mul(A,B);  //or
          C := Mul(a,b); // but this is not the same as:
          c := a*b; //which is the same as
          c.MulElem(A,B);s
      end;
      </code>
      </Example>

      <SeeAlso cref="MulElem"/>*)
    function Mul(const Mtx1, Mtx2: TMtx): TMtx; overload;

    (*<summary>Left side multiply Mtx2 with Mtx1 matrix and store the results in the calling matrix.</summary>
      
<remarks>If Operation1 and/or Operation2 parameters are specified, perform additional operation on Mtx1 or Mtx2. If Operation1 and/or Operation2 parameters
      are omitted, the default values (no operation) will be used.
      The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties
      of the calling matrix are adjusted automatically. An exception is raised is Mtx1 Cols property does not match the Mtx2 Rows property (matrix
      multiplication is not possible). An exception is raised, if Complex property of Mtx1 and Mtx2 does not match.
</remarks>
*)

    function Mul(const Mtx1, Mtx2: TMtx; Operation1: TMtxOperation;  Operation2: TMtxOperation = opNone): TMtx; overload;
    (*<summary>Left side multiply Mtx2 with Mtx1 matrix and store the results in the calling matrix. If parameters Mtx1Type and/or Mtx2Type are specified,
      the optimized multiplication method will be used.</summary>
      
<remarks>If parameters Mtx1Type and/or Mtx2Type are omitted, default values (general matrix) will be used.
      If Operation1 and/or Operation2 parameters are specified, perform additional operation on Mtx1 or Mtx2. If Operation1 and/or Operation2 parameters
      are omitted, the default values (no operation) will be used. The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties
      of the calling matrix are adjusted automatically. An exception is raised is Mtx1 Cols property does not match the Mtx2 Rows property (matrix
      multiplication is not possible). An exception is raised, if Complex property of Mtx1 and Mtx2 does not match.
</remarks>
*)
    function Mul(const Mtx1, Mtx2: TMtx; Mtx1Type: TMtxType; Mtx2Type: TMtxType = mtGeneral; Operation1: TMtxOperation = opNone; Operation2: TMtxOperation = opNone): TMtx; overload;

    (*<summary>Returns the matrix product of three matrices. </summary>
               
<remarks>Internally calls <see cref="TMtx.Mul"/> and does JIT-ed (faster) multiply for small square matrices.
</remarks>
*)
    function Mul(const Mtx1, Mtx2, Mtx3: TMtx): TMtx; overload;

    (*<summary>Returns the matrix product of four matrices. </summary>
               
<remarks>Internally calls <see cref="TMtx.Mul"/> and does JIT-ed (faster) multiply for small square matrices.
</remarks>
*)
    function Mul(const Mtx1, Mtx2, Mtx3, Mtx4: TMtx): TMtx; overload;

    (*<summary>Initializes small matrix multiply according to lapacks dgemm api standard.</summary>

               
<remarks>Initializes compute of: C = alpha*opA(A)*opB(B)+ beta*C

               The routine generates code by using JIT (just in time compilation) to create a kernel, which is optimized for the specified parameters.
               To release existing kernel and create a new one call this routine again. The process of creating a kernel is about 1000x slower than multiplying
               two matrices with size 2x2. The JIT targets small matrices and will fallback to standard dgemm for large matrices.

               The routine will set the size the calling matrix to match the size of the result of the multiplication.

               The actual matrix multiplication is performed by calling TMtx.MulSmall method.

               The function returns true, if custom code kernel was created. It returns false, if the code was routed to the default dgemm/zgemm routine, because
               the two matrices are too big to expect an improvement.
</remarks>
*)
    function MulSmallInit(const A, B: TMtx; opA: TMtxOperation = opNone;  opB: TMtxOperation = opNone; const alpha: double = 1; const beta: double = 0): boolean; overload;
    (*<summary>Initializes small matrix multiply according to lapacks dgemm api standard.</summary>

               
<remarks>Initializes compute of: C = alpha*opA(A)*opB(B)+ beta*C

               The routine generates code by using JIT (just in time compilation) to create a kernel, which is optimized for the specified parameters.
               To release existing kernel and create a new one call this routine again. The process of creating a kernel is about 1000x slower than multiplying
               two matrices with size 2x2. The JIT targets small matrices and will fallback to standard dgemm for large matrices.

               The routine will set the size the calling matrix to match the size of the result of the multiplication.

               The actual matrix multiplication is performed by calling TMtx.MulSmall method.

               The function returns true, if custom code kernel was created. It returns false, if the code was routed to the default dgemm/zgemm routine, because
               the two matrices are too big to expect an improvement.
</remarks>
*)
    function MulSmallInit(const A, B: TMtx; opA: TMtxOperation;  opB: TMtxOperation; const alpha: TCplx; const beta: TCplx): boolean; overload;

    (*<summary>Small matrix multiply. Performs arbitrary small matrix multiplication.</summary>
               
<remarks>The routine does no error checking and assumes that both A and B matrix sizes, FloatPrecision and layout do not change between calls.
               The size of the calling matrix is set automatically.
               The kernel for the particular precision is initialized with a call to MulSmallInit and released either when a new one is created or when the calling matrix is freed.
</remarks>
*)
    function MulSmall(const A, B: TMtx): TMtx; overload; 
    (*<summary>Small matrix multiply. Performs arbitrary small matrix multiplication.</summary>
               
<remarks>The routine does no error checking and assumes that both A and B matrix and for the calling matrix, the sizes, FloatPrecision, the layout and the memory location (!) do not change between calls.
               The matrices multiplied are those passed to the MulSmallInit routine. You can change the values in the memory allocated by those matrices, but may not
               resize them or resize the calling matrix.

               The kernel for the particular configuration is initialized with a call to MulSmallInit and released either when a new one is created or when the calling matrix is freed.
</remarks>
*)
    function MulSmall: TMtx; overload; 

    (*<summary>Matrix array multiplication.</summary>
      
<remarks>Multiplies elements in Mtx matrix with the elements in the calling matrix (array multiplication) and stores the results in calling matrix.
      The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of both matrices must match, otherwise an exception is
      raised.
</remarks>


      <Example>
      <code>
      var  A,B,C: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);
          B.SetIt(2,2,False,[1,2,
                             2,4]);
          C.MulElem(A,B);
          // C becomes:
          // [1, 4,
          //  4,16]
      end;
      </code>
      </Example>

      <SeeAlso cref="InvElem"/>*)
    function MulElem(const Mtx: TMtx): TMtx; overload;
    (*<summary>Multiplies elements in Mtx1 matrix with the elements in Mtx2 matrix (array multiplication) and stores the results in calling matrix.</summary>
      
<remarks>The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of calling matrix are set implicitly to match those
      of Mtx1 and Mtx2 matrices. Mtx1 and Mtx2 Rows, Cols, and Complex properties must be the same, otherwise an exception is raised.
</remarks>
*)
    function MulElem(const Mtx1, Mtx2: TMtx): TMtx; overload;

    function MulElem(const Vec: TVec; const Mtx: TMtx): TMtx; overload;
    function MulElem(const Mtx: TMtx; const Vec: TVec): TMtx; overload;
    function MulElem(const Vec1: TVec; const Vec2: TVec): TMtx; overload;

    (*<summary>Calculates the matrix norm-1.</summary>
      
<remarks>Calculates calling matrix norm-1. The "norm-1" is defined as the largest column sum.
</remarks>


      <Example>
      <code>
      var A: Matrix;
        b: double;
      begin
          A.SetIt(2,2,false,[1,2,
                  2,4]);  // 2x2, not complex matrix
          b := A.Norm1;
      end;
      </code>
      </Example>

      <SeeAlso cref="NormInf"/>
      <SeeAlso cref="NormFro"/>*)
    function Norm1: double; overload;

    (*<summary>Calculates the matrix Frobenius norm.</summary>
      
<remarks>Calculate the calling matrix Frobenius norm. The Frobenius norm is defined as
      the square root of the sum of sums of squared elements of rows. An exception is raised
      if calling matrix <see cref="Complex"/> property is true.
</remarks>


      <Example>
      <code>
      var A: Matrix;
        b: double;
      begin
          A.SetIt(2,2,false,[1,2,
                  2,4]);  // 2x2, not complex matrix
          b := A.NormFro;
      end;
      </code>
      </Example>

      <SeeAlso cref="NormInf"/>
      <SeeAlso cref="Norm1"/>*)
    function NormFro: double; overload;

    (*<summary>Calculates the matrix infinity norm.</summary>
      
<remarks>Calculate the calling matrix infinity norm. The "infinity norm" is defined as the largest row sum.
</remarks>


      <Example>
      <code>
      var A: Matrix;
        b: double;
      begin
          A.SetIt(2,2,false,[1,2,
                  2,4]);  // 2x2, not complex matrix
          b := A.NormInf; // b= 6
      end;
      </code>
      </Example>

      <SeeAlso cref="NormFro"/>
      <SeeAlso cref="Norm1"/>*)
    function NormInf: double; overload;

    (*<summary>Constructs a Pascal matrix.</summary>
      
<remarks>Construct a Pascal matrix of order Order with integer elements, taken from the Pascal's triangle. The Pascal matrix
      is by definition symmetric positive definite. The Pascal matrix is written to the calling matrix. The <see cref="Rows"/>,
      <see cref="Cols"/> and <see cref="Complex"/> properties of the calling matrix are adjusted automatically.
</remarks>
*)
    function Pascl(Order: integer): TMtx; overload;

    (*<summary>Raises matrix elements to any power.</summary>
      
<remarks>Raises Base matrix elements to the Exponent matrix elements power and stores the results in the calling matrix. The
      <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of the calling matrix are
      adjusted automatically. The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties
      of Base and Exponent matrices must match otherwise an exception is raised.

      Note
        Only positive exponents can be handled if Exponent matrix is not complex.
</remarks>


      <Example>
      <code>
      var  A,B,C: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);
          B.SetIt(2,2,False,[1,2,
                             2,4]);
          C.Power(A,B); // or
          C := Power(A,B);
      end;
      </code>
      </Example>

      <SeeAlso cref="Power"/>*)
    function PowerMtx(Base, Exponent: TMtx): TMtx; overload;

    (*<summary>Creates a reduced size dense matrix for screen display (bitmap) to show the matrix pattern.</summary>
      
<remarks>Creates a reduced size dense matrix for screen display (bitmap) to show the matrix pattern.
      Pixels parameter defines the target number of pixels to reduce <see cref="Rows"/> and <see cref="Cols"/> to.
      The size reduction method depends on what you want to see:

      * pdsPattern , Returns 1 for all areas with at least one nonzero value regardless of its amplitude.
      * pdsAverage, Average all values within an area (pixel).
      * pdsPeak, Return only the maximum absolute value within an area (region will become one pixel).
</remarks>


      <Example>
      <code>
      Uses ..., MtxVecTee;
      var Mtx, ReducedMtx: Matrix;
      begin
          Mtx.Size(1000,1000,false);
          Mtx.RandGauss;
          // we're interested in averages, not pattern
          ReducedMtx.PixelDownSample(Mtx,200,pdsAverage);
          DrawIt(ReducedMtx);
      end;
      </code>
      </Example>*)
    procedure PixelDownSample(Dst: TMtx; Pixels: integer  = 500; Mode: TPixelDownSample = pdsPattern); overload;

    (*<summary>Allows to exactly specify the size of the destination matrix with PixelsHeight
       and PixelsWidth parameters.</summary>
       
<remarks>The source matrix can be bigger or smaller than
       the destination.
</remarks>
*)
    procedure PixelResample(Dst: TMtx;
          const ZoomRect:  TMtxRect;
          Mode: TPixelDownSample = pdsPattern); overload;

    (*<summary>Resizes the matrix, while preserving the values in already allocated memory.</summary>
      
<remarks>Sets the <see cref="Rows"/> property to NewRows,
      <see cref="Cols"/> property to NewCols, while preserving the values in already allocated memory.
</remarks>


      <Example>
      <code>
      var  A,B: Matrix;
      begin
          A.SetIt(2,2,False,[1,3,
                             2,4]);
          B.Resize(A,3,2,True);
          // B becomes:
          // [1,2,0,
          //  3,4,0]);
      end;
      </code>
      </Example>

      <SeeAlso cref="Size"/>*)
    function Resize(NewRows , NewCols: integer): TMtx; overload;
    (*<summary>Performs resize of the calling matrix to NewRows and NewCols.</summary>
       
<remarks>Copies the Src matrix values to the calling matrix.
       The elements outside the newly created matrix size are not referenced.
</remarks>
*)
    function Resize(const Src: TMtx; NewRows, NewCols: integer): TMtx; overload;

    (*<summary>Resize and transpose.</summary>
      
<remarks>Resizes the calling matrix to NewRows and NewCols and then copies
      the Src matrix values to the calling matrix. The elements outside
      the newly created matrix size are not referenced. At the end
      the method also transposes the calling matrix. All this operations
      are performed in one single pass.
</remarks>
*)
    function ResizeAndTranspose(const Src: TMtx; NewRows, NewCols: integer): TMtx;

    (*<summary>Rotates matrix rows 90 degrees clockwise.</summary>
      
<remarks>Rotates all calling matrix rows 90 degrees clockwise in-place (check the scheme bellow).

      <IMG name="mtx013"/>

      Note
        This operation differs from the <see cref="Transp"/> operation.
</remarks>


      <Example>
      <code>
      var  A,B: Matrix;
      begin
        A.SetIt(2,2,False,[1,3,
                           2,4]);
        B.Rotate90(A);
      end;
      </code>
      </Example>

      <SeeAlso cref="Transp"/>*)
    function Rotate90: TMtx; overload;
    (*<summary>Rotate all Mtx matrix rows 90deg clockwise and store the results in calling matrix.</summary>
      
<remarks>The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of the calling
      matrix are adjusted automatically.
</remarks>
*)
    function Rotate90(const Mtx: TMtx): TMtx; overload;

    (*<summary>Exchanges two matrix rows.</summary>
      
<remarks>Exchange the i-th and j-th rows of the calling matrix in-place. An exception is raised if matrix bounds are
      overrun. The indexes i and j are zero based. (the first row has Index 0).
</remarks>


      <Example>
      <code>
      var  A,B: Matrix;
      begin
          A.SetIt(2,2,False,[1,3,
                             2,4]);
          B.RowExchange(0,1);
          // B becomes:
          // [2,4,
          //  1,3]);
      end;
      </code>
      </Example>

      <SeeAlso cref="ColExchange"/>*)
    function RowExchange(i, j: integer): TMtx; overload;

    (*<summary>Copies values from vector to matrix column.</summary>
      
<remarks>Copy all Vec elements to the calling matrix Col column. The <see cref="Complex"/> property of the calling
      matrix is adjusted automatically. An exception is raised, if array bounds are overrun.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
            V: Vector;
      begin
          A.Size(2,1,True);
          V.SetIt(True,[1,2, 2,4]);  // complex vector
          A.SetCol(V,0);
      end;
      </code>
      </Example>

      <SeeAlso cref="SetRow"/>*)
    function SetCol(const Vec: TDenseMtxVec; Col: integer): TMtx; overload;
    (*<summary>Copy vector Vec elements [VecIndex]..[VecIndex+Len-1] to the calling matrix elements [Row,Col]..[Row+Len-1,Col].</summary>
      
<remarks>An exception is raised if condition checking is enabled and array bounds are overrun. An exception is raised, if Vec
      and the calling matrix complex properties do not match.
</remarks>
*)
    function SetCol(const Vec: TDenseMtxVec; VecIndex, Row, Col, Len: integer): TMtx; overload;

    (*<summary>Sets matrix values.</summary>
      
<remarks>Sets matrix values. This method gives you the possibility to pass large arrays of elements without having to declare constant arrays.
      Pass all elements in A array to the calling matrix. The <see cref="Rows"/> and <see cref="Cols"/> properties of the calling
      matrix are set to ARows and ACols and the <see cref="Complex"/> property is set to AComplex. An exception is raised if the matrix size
      (ARows*ACols) does not match the number of complex numbers in A.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             2,4]);
      end;
      </code>
      </Example>

      <SeeAlso cref="SetVal"/>*)
    function SetIt(ARows, ACols: integer; AComplex: Boolean;const A: array of double): TMtx; overload;

    (*<summary>Copies values from vector to matrix row.</summary>
      
<remarks>Copy all Vec elements to the calling matrix Row row. The <see cref="Complex"/> property of the calling
      matrix is adjusted automatically. An exception is raised, if array bounds are overrun.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
            V: Vector;
      begin
          A.Size(1,2,True);
          V.SetIt(True,[1,2, 2,4]);  // complex vector
          A.SetCol(V,0);
      end;
      </code>
      </Example>

      <SeeAlso cref="SetCol"/>*)
    function SetRow(const Vec: TDenseMtxVec; Row: integer): TMtx; overload;
    (*<summary>Copy vector Vec elements [VecIndex]..[VecIndex+Len-1] to the calling matrix elements [Row,Col]..[Row,Col+Len-1].</summary>
      
<remarks>An exception is raised if condition checking is enabled and array bounds are overrun. An exception is raised, if Vec
      and the calling matrix complex properties do not match.
</remarks>
*)
    function SetRow(const Vec: TDenseMtxVec; VecIndex, Row, Col, Len: integer): TMtx; overload;

    (*<summary>Initializes matrix values to zero.</summary>
      
<remarks>Sets the calling matrix elements [Row,Col]..[Row+ToRow,Col+ToCol] to zero. An exception is raised if
      <see cref="ConditionCheck"/> is true and array bounds are overrun.
</remarks>
*)
    function SetZero(Row, Col, ToRow, ToCol: integer): TMtx; overload;

    (*<summary>Initializes matrix values to Value.</summary>
      
<remarks>Sets the calling matrix elements [Row,Col]..[Row+ToRow,Col+ToCol] to Value. An exception is raised if
      <see cref="ConditionCheck"/> is true and array bounds are overrun.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetZero"/>*)
    function SetVal(const Value: double; Row, Col, ToRow, ToCol: integer): TMtx; overload;
    (*<summary>Sets the calling matrix elements [Row,Col]..[Row+ToRow,Col+ToCol] to complex value Value.</summary>
      
<remarks><see cref="Complex"/> properties of the calling object are set to true even before the call it was false.
      An exception is raised if array bounds are overrun.
</remarks>


      <SeeAlso cref="SetIt"/>
      <SeeAlso cref="SetZero"/>*)
    function SetVal(const Value: TCplx; Row, Col, ToRow, ToCol: integer): TMtx; overload;

    (*<summary>Sets the size of matrix.</summary>
      
<remarks>Set the calling matrix properties:

      <c><see cref="Rows"/> = ARows,</c>
      <c><see cref="Cols"/> = ACols</c>
      and <c>See cref="Complex"/> = AComplex</c>.

      Calling the Size method does not preserve the contents of the matrix.
      Use the Resize method, if you want to preserve existing values.

      The floating point precision is defined with aIsDouble.

      Note
        The Size method performs an out-of-memory safe resize, if the matrix already has memory allocated. This prevents out
        of memory message for example when redefining the size of the matrix from single
        column to single row:

      <code>
      A.Rows := 10000; // matrix size = 0
      A.Cols := 1;     // matrix size = 10000
      // ...
      A.Cols := 10000; // matrix size = 100 000 000 (problems here)
      A.Rows := 1;     // matrix size = 10 000
      </code>
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
          A.Size(2,1,True, true); // 2x1 complex double matrix
          A.SetZero;
          // A becomes:
          // [0,0]
          // [0,0]
      end;
      </code>
      </Example>

      <SeeAlso cref="Rows"/>
      <SeeAlso cref="Cols"/>
      <SeeAlso cref="Complex"/>*)
    function Size(const ARows, ACols: integer; const AComplex: boolean; const AIsDouble: boolean): TMtx ; overload;

    (*<summary>Specifies size of the matrix.</summary>
      
<remarks>Set the following matrix properties:

      <c><see cref="Rows"/> = ARows,</c>
      <c><see cref="Cols"/> = ACols</c>
      and <c>See cref="FloatPrecision"/> = aFloatPrecision</c>.

      Calling the Size method does not preserve the contents of the matrix.
      Use the Resize method, if you want to preserve existing values.
</remarks>
*)
    function Size(const ARows, ACols: integer; const aFloatPrecision: TMtxFloatPrecision): TMtx ; overload;
    (*<summary>Specifies size of the matrix.</summary>
      
<remarks>Set the following matrix properties:

      <c><see cref="Rows"/> = ARows,</c>
      <c><see cref="Cols"/> = ACols</c>
      and <c>See cref="FloatPrecision"/> = aFloatPrecisionRef.FloatPrecision</c>.

      Calling the Size method does not preserve the contents of the matrix.
      Use the Resize method, if you want to preserve existing values.
</remarks>
*)
    function Size(const ARows, ACols: integer; const aFloatPrecisionRef: TMtxVec): TMtx ; overload;

    
    (*<summary>Sets the size of matrix.</summary>
      
<remarks>Set the calling matrix properties:

      <c><see cref="Rows"/> = ARows,</c>
      <c><see cref="Cols"/> = ACols</c>
      and <c>See cref="Complex"/> = AComplex</c>.

      Existing floating point precision is preserved. Calling the Size method does not preserve the contents of the matrix.
      Use the Resize method, if you want to preserve existing values.
</remarks>
*)

    function Size(const ARows, ACols: integer; const AComplex: boolean): TMtx ; overload;
    (*<summary>Sets the size of matrix.</summary>
      
<remarks>Set the calling matrix properties:

      <c><see cref="Rows"/> = ARows,</c>
      <c><see cref="Cols"/> = ACols</c>
      and <c>See cref="Complex"/> = false</c>.

      Existing floating point precision is preserved. Calling the Size method does not preserve the contents of the matrix.
      Use the Resize method, if you want to preserve existing values.
</remarks>
*)
    function Size(const ARows, ACols: integer): TMtx ; overload;
    


    (*<summary>Sorts the elements in a matrix row(s) in ascending order.</summary>
      
<remarks>Sorts the elements in calling matrix row(s) in ascending order in-place. If the calling matrix is complex,
      then complex values are first compared by the absolute value and then by the argument.

      Note
        Wach row is sorted independently from the other.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             4,2]);
          A.SortAscend;
          // A becomes:
          // [1,2]
          // [2,4]
      end;
      </code>
      </Example>

      <SeeAlso cref="SortDescend"/>*)
    function SortAscend: TMtx; overload;
    (*<summary>Performs row based sort in ascending order. The Col parameter defines the column based on which the rows are compared with each other.</summary>*)
    function SortAscend(Col: integer): TMtx; overload; 

    (*<summary>Sorts the elements in a matrix row(s) in descending order.</summary>
      
<remarks>Sorts the elements in calling matrix row(s) in descending order in-place. If the calling matrix is complex,
      then complex values are first compared by the absolute value and then by the argument.

      Note
        Each row is sorted independently from the other.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
          A.SetIt(2,2,False,[1,2,
                             4,2]);
          A.SortDescend;
          // A becomes:
          // [2,1]
          // [4,2]
      end;
      </code>
      </Example>

      <SeeAlso cref="SortAscend"/>*)
    function SortDescend: TMtx; overload;
    (*<summary>Performs row based sort in descending order. The Col parameter defines the column based on which the rows are compared with each other.</summary>*)
    function SortDescend(Col: integer): TMtx; overload; 

      (*<summary>Standard deviation for matrix columns.</summary>
        
<remarks>Calculates the standard deviation for each of the calling matrix columns and stores the
        results in vector result. An exception is raised if calling matrix is complex.
        The Length  and Complex properties of the result vector are adjusted automatically.
</remarks>


        <SeeAlso cref="StdDevRows"/>
        <SeeAlso cref="MeanCols"/>*)
      procedure StdDevCols(const result: TVec);
      (*<summary>Standard deviation for matrix rows.</summary>
        
<remarks>Calculates the standard deviation for each of the calling matrix rows and stores the
        results in vector result. An exception is raised if calling matrix is complex.
        The Length  and Complex properties of the result vector are adjusted automatically.
</remarks>


        <SeeAlso cref="StdDevCols"/>
        <SeeAlso cref="MeanRows"/>*)
      procedure StdDevRows(const result: TVec);

    (*<summary>Singular value decomposition.</summary>
      
<remarks>Performs a singular value decomposition on a calling matrix (A). U or V can be nil, if not desired. If you do not want economy
      size U and V set MinSize to False. The singular value decomposition (SVD) of the calling matrix (A, with m rows and n cols) is
      defined by the following equation:

      <IMG name="mtx010"/>

      where U and V are unitay (for complex A) or orthogonal (for real A). S is a diagonal matrix with real diagonal elements is:

      <IMG name="mtx011"/>

      The diagonal elements are singular values of A (calling matrix). The first min(m, n) columns of the matrices U and V are,
      respectively, left and right singular vectors of calling matrix (A). The singular values and singular vectors satisfy:

      <IMG name="mtx012"/>

      where u<sub>i</sub> and v<sub>i</sub> are the i-th columns of U and V, respectively.
      One interpretation of the singular values is as follows. If you take a unit sphere in n-dimensional space, and multiply each
      vector in it by an m x n  matrix , you will get an ellipsoid in m-dimensional space. The singular values give the lengths of
      the principal axes of the ellipsoid. If the matrix is singular in some way, this will be reflected in the shape of the
      ellipsoid. In fact, the ratio of the largest singular value of a matrix to the smallest one gives a
      <see cref="ConditionNr"/> of the matrix, which determines, for example, the accuracy of numerical
      matrix inverses. Very small singular values are usually numerically meaningless.
</remarks>


      <Example>
      <code>
      var A,U,V: Matrix;
        S: Vector;
      begin
          A.SetIt(3,3,True, [2, 5, 12, 1, 5, 2.5,
                            -4, 2,  8, 0, 0,   3,
                             2, 0,  4, 8, 12,  8]);

          A.SVD(U,S,V);
          // S =  [21.3406,10.9726,3.7989]

    end;
    </code>
    </Example>

      <SeeAlso cref="SVDSolve"/>
      <SeeAlso cref="ConditionNr"/>*)
    function SVD(S: TVec): TMtx; overload;
    (*<summary>Matrix version of SVD. Perfroms a SVD for each U and V matrices columns in single pass.</summary>*)
    function SVD(U: TMtx; S: TVec; V: TMtx; MinSize: boolean = True): TMtx; overload;

    (*<summary>Calculates the minimum norm solution to a real linear least squares problem.</summary>
      
<remarks>Calculates the minimum norm solution to a real linear least squares problem.

      <c>Minimize 2-norm(| b - A*x |).</c>

      using the singular value decomposition (SVD) of the calling matrix A. A is an
      Rows-by-Cols matrix which may be rank-deficient. Several right hand side vectors b and solution vectors
      x can be handled in a single call. The effective rank of A is determined by treating as zero those singular
      values which are less than Threshold times the largest singular value and is returned by the function. The
      S vector holds the singular values on the output.
</remarks>


      <Example>
      <code>
      var X,B,D: Vector;
        V: Matrix;
      begin
          B.SetIt(false,[0,2,3]);
          V.SetIt(3,3,false,[1,2,3,
                             3,4,5,
                             6,7,7]);

          V.SVDSolve(B,X,D); // matrix V can be non-quadratic
      end;
      </code>
      </Example>

      <SeeAlso cref="SVD"/>*)
    function SVDSolve(B, X, S: TVec; Threshold: double = 1E-9): integer; overload;
    (*<summary>Matrix version of SVDSolve. Perfroms a SVDSolve for each U and V matrices columns in single pass.</summary>*)
    function SVDSolve(B, X: TMtx; S: TVec; Threshold: double = 1E-9): integer; overload;

    (*<summary>Solves the Sylvester equation.</summary>
      
<remarks>Solves the Sylvester's equation

      <IMG name="mtx001"/>

      for real quasi-triangular or complex triangular matrices A and B. The solution (X) overwrites the C matrix.
      The AOp and BOp parameters indicate the <see cref="TMtxOperation"/> performed on A and
      B respectively. The <see cref="TSign"/> of the Sylvester equation is determined with the ASign parameter
      (siPlus for +, siMinus for -). The result of a Sylvester function is a scale factor a. The A and B matrices
      <see cref="Quadratic"/> property must be true, otherwise an exception is raised.
</remarks>
*)
    function Sylvester(A, B, C: TMtx; ASign: TSign = siPlus; AOp: TMtxOperation = opNone; BOp: TMtxOperation = opNone): double; overload;

    (*<summary>Saves matrix data to MatrixMarket ASCII file format.</summary>
      
<remarks>Saves matrix data to <See xref="add_mmarketff"/> ASCII file format.
</remarks>
*)
    procedure SaveToMatrixMarketFile(FileName: string);

    (*<summary>Splits matrix in blocks.</summary>
      
<remarks>Splits the calling matrix in blocks. Example:

      <code>
      [ A B ]
      [ C D ]
      </code>
      where A,B,C,D are matrices of size 2x2 and the calling matrix is of size 4x4. ARows and ACols define
      the number of rows and columns of the block based matrix. The matrices passed in the dst array to be
      filled with values from the calling matrix, must already have matching size and complex properties to
      cover the calling matrix or an exception will be raised.
</remarks>


      <Example>
      <code>
      var A,B,C,D,E: Matrix;
      begin
          A.Size(2,2);
          B.Size(A);
          C.Size(A);
          D.Size(A);
          E.SetIt(4,4,False,[1,2,3,4
                             5,6,7,8
                             9,1,2,3
                             4,5,6,7]);
          E.Split(2,2,[A,B,
                       C,D]);
          // A becomes:
          // [1,2,
          //  5,6]

          // B becomes:
          // [3,4,
          //  7,8]

          // C becomes:
          // [9,1,
          //  4,5]

          // D becomes:
          // [2,3,
          //  6,7]
      end;
      </code>
      </Example>

      <SeeAlso cref="Concat"/>
      <SeeAlso cref="ConcatVert"/>
      <SeeAlso cref="ConcatHorz"/>*)
    procedure Split(ARows, ACols: integer;const Dst: array of TMtx);

    (*<summary>The sum of each of the calling matrix columns.</summary>
      
<remarks>Calculates the sum of each of the calling matrix columns and stores the results in Dst vector.
      The <see cref="Length"/> and <see cref="Complex"/> properties of the Dst vector are adjusted automatically.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
          V: Vector;
      begin
        A.Size(2,2,False,[[1,5,
                           2,3]);

        A.SumCols(V); // V = [3,8]
      end;
      </code>
      </Example>

      <SeeAlso cref="SumRows"/>*)
    procedure SumCols(Dst: TVec); overload;

    (*<summary>The sum of each of the calling matrix rows.</summary>
      
<remarks>Calculates the sum of each of the calling matrix rows and stores the results in Dst vector.
      The <see cref="Length"/> and <see cref="Complex"/> properties of the Dst vector are adjusted automatically.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
          V: Vector;
      begin
        A.Size(2,2,False,[[1,2,
                           2,4]);

        A.SumRows(V); // V = [3,6]
      end;
      </code>
      </Example>

      <SeeAlso cref="SumCols"/>*)
    procedure SumRows(Dst: TVec); overload;

    (*<summary>Calculates the tensor product of two vectors.</summary>
      
<remarks>Calculates the tensor product of Vec1 and Vec2 vectors and stores the results in the calling matrix. The <see cref="Rows"/>
      property is set to Vec1.<see cref="Length"/> and <see cref="Cols"/> property is set to Vec2.<see cref="Length"/>.
      The <see cref="Complex"/> property of the calling matrix is adjusted automatically.
</remarks>


        <Example>
        <code>
        var Vec1,Vec2: Vector;
          V: Matrix;
        begin
            Vec1.Size(3);
            Vec1.SetIt(false,[0,2,3]
            Vec2.Copy(Vec1);
            V.TensorProd(Vec1,Vec2);
            // V becomes:
            // [0,0,0]
            // [0,4,6]
            // [0,6,9]
        end;
        </code>
        </Example>

      <SeeAlso cref="AddTensorProd"/>*)
    function TensorProd(const Vec1, Vec2: TVec): TMtx; overload;

    (*<summary>Constructs a Toeplitz matrix.</summary>
      
<remarks>Constructs a Toeplitz matrix  with first row equal to FirstRow vector and first column equal to FirstCol vector,
      but without the first element. The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/>
      properties of the calling matrix are adjusted automatically. An exception is raised if FirstRow and FirstCol
      Complex properties do not match.
</remarks>


      <Example>
      <code>
      var V1,V2: Vector;
          T: Matrix;
      begin
          V1.SetIt(False,[1,2,3,4]);
          V2.SetIt(False,[2,3,4]);
          T.Toeplitz(V1,V2);
          // T becomes:
          //[1  2  3  4]
          //[2  1  2  3]
          //[3  2  1  2]
          //[4  3  2  1]
      end;
      </code>
      </Example>*)
    function Toeplitz(FirstRow,FirstCol: TVec): TMtx; overload;
    (*<summary>Constructs a Toeplitz matrix  with first row equal to FirstRow vector and first column equal to FirstRow vector,
      but without the first element.</summary>*)
    function Toeplitz(FirstRow: TVec): TMtx; overload;

    (*<summary>Matrix trace.</summary>
      <returns>the trace of the calling matrix.</returns>
      
<remarks>If the calling matrix <see cref="Complex"/> property is false, the imaginary part is set to zero.
</remarks>
*)
    function Trace: TCplx; overload;

    (*<summary>Transposes matrix.</summary>
      
<remarks>Transposes calling matrix in-place. Instead of using transpose directly, try using the <See Type="TMtxOperation"/>
      parameter of many TMtx methods. If this operation can not be avoided try using the not-in-place version  (see bellow)
      or see the <see cref="Rotate90"/> method.
</remarks>


      <Example>
      <code>
      var  A: Matrix;
      begin
        A.Size(2,1,True); // 2x1 complex matrix
        A.SetVal(Cplx(3,4));
        A.Transp;
      end;
      </code>
      </Example>

      <SeeAlso cref="Rotate90"/>*)
    function Transp: TMtx; overload;
    (*<summary>Transpose the Mtx matrix and write the results to the calling matrix.</summary>
      
<remarks>The <see cref="Rows"/>, <see cref="Cols"/> and <see cref="Complex"/> properties of
      the calling matrix are adjusted automatically.
</remarks>
*)
    function Transp(const Mtx: TMtx): TMtx; overload;

    (*<summary>Constructs upper triangular matrix.</summary>
      
<remarks>The method uses Mtx matrix to construct an upper triangular matrix. The results are stored in the calling matrix.
      If the ZeroLower parameter is true then the calling matrix subdiagonal elements will be set to zero - otherwise
      the subdiagonal elements will not be initialized. If the Diagonal boolean parameter is true then the Mtx matrix
      main diagonal elements will be copied to the calling matrix main diagonal elements. If the Diagonal parameter is
      false, the calling matrix main diagonal elements will be set to zero.
</remarks>


      <Example>
      <code>
      var  A,B: Matrix;
      begin
        A.SetIt(2,1,True,[1,2,
                          2,4]);  // 2x2, not complex matrix
        B.UpperTriangle(A,True,True);
        // B becomes:
        //  [1,2,
        //  [0,4]
      end;
      </code>
      </Example>
      <SeeAlso cref="LowerTriangle"/>*)
    function UpperTriangle(const Mtx: TMtx; ZeroLower, Diagonal: boolean): TMtx; overload;

    (*<summary>Construct VanderMonde matrix.</summary>
      
<remarks>Constructs a VanderMonde matrix with Vec.<see cref="Length"/> rows and ACols columns.
      The second to last column of the VanderMonde matrix is Vec:

      <IMG name="mtx007"/>
</remarks>
*)
    function VanderMonde(ACols: Integer; Vec: TVec): TMtx; overload;


    (*<summary>Transforms matrix into matrix of standardized data.</summary>
      
<remarks>The routine uses Data matrix and transforms it into ZScore matrix of standardized data
      (the so called Z Scores). The standardization of each column (variable) is made by subtracting
      its mean and dividing by its standard deviation:

      <code>
                    Column - Mean(Column)
      Z(Column) = -----------------------
                    StdDev(Column)
      </code>
</remarks>


    <Example>
    <code>
    var Data, Res: Matrix;
    begin
        Data.SetIt(3,3,false,[1,2,3,
                            4,5,6,
                            7,100,12]);
        Res.ZScore(Data);
        // Res = (-1	-0,604	-0,873,
        //            0	-0,55	-0,218
        //            1	 1,154	 1,091)
    end;
    </code>
    </Example>*)
    function ZScore(const Src: TMtx): TMtx; overload;

    

    (*<summary>Converts the content of the matrix Values array to a list of strings.</summary>
      
<remarks>Convert all elements of the calling matrix to strings with  formating real parts with ReFormat, imaginary parts with ImFormat, using the text delimiter
      Delimiter and store them in aList, by using the Add method of TStrings object.

        Performance note:
          This routine will be exceedingly slow, if TRichEdit.Lines or TMemo.Lines are passed as a parameter for dstList. Use TStringList or StringList types and then
          call TMemo.Lines.AddStrings(yourList) for best results.
</remarks>


      <Example>
      <code>
      procedure TForm1.Button1Click(Sender: TObject);
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          a.Cos;
          b.Size(a);
          b.SetVal(1);
          a := a + b;
          Richedit1.Clear;
          Memo1.Clear;
          a.ValuesToStrings(Richedit1.Lines);
          b.ValuesToStrings(Richedit1.Lines);
          a.ValuesToStrings(Memo1.Lines);
          b.ValuesToStrings(Memo1.Lines);
          Memo1.Lines.SaveToFile('C:\Test.txt');
          Memo1.Lines.LoadFromFile('C:\Test.txt');
          a.StringsToValues(Memo1.Lines);
      end;
      </code>
      </Example>

      <SeeAlso cref="StringsToValues"/>*)
    function ValuesToStrings(const dstList: TStrings;
                              const Delimiter: string = kTab;
                              const Align: TFixedTextAlign = ftaNone;
                              const ReFormat: string = ' 0.###;-0.###';
                              const ImFormat: string = '+0.###i;-0.###i';
                              const Headers: boolean = false): integer; overload;
    (*<summary>Convert calling matrix elements, starting with [Row,Col] and converting Len elements to strings with formating real parts with ReFormat, imaginary
      parts with ImFormat.</summary>
      
<remarks>Uses the text delimiter Delimiter and store them in aList starting at ListIndex. If aList is not large enough, the method will use
      the add method of aList object.

      Performance note:
          This routine will be exceedingly slow, if TRichEdit.Lines or TMemo.Lines are passed as a parameter for dstList. Use TStringList or StringList types and then
          call TMemo.Lines.AddStrings(yourList) for best results.
</remarks>
*)
    function ValuesToStrings(const dstList: TStrings; ListIndex,Row,Col,RowCount,ColCount: integer;
                              const Delimiter: string = kTab;
                              const Align: TFixedTextAlign = ftaNone;
                              const ReFormat: string = ' 0.###;-0.###';
                              const ImFormat: string = '+0.###i;-0.###i';
                              const Headers: boolean = false): integer; overload;

    (*<summary> Converts data to delimited string using Delimiter and number formatting options. </summary>
                 
<remarks>Pass empty string to ReFormat and ImFormat to indicate general number formatting.
</remarks>
*)
    function ValuesToText(Delimiter: string = kTab;
      const ReFormat: string = ' 0.###;-0.###'; const ImFormat: string = '+0.###i;-0.###i'): String;

    (*<summary> Converts text delimited with Delimiter to numbers.  </summary>*)
    function TextToValues(Text: String; Delimiter: String = kTab): TMtx;

    (*<summary>Convert strings to double (TCplx) and store them in the Values array.</summary>
      
<remarks>Convert strings in aList to double (real number) and store them in the Values array of the calling matrix.
      <see cref="Rows"/> property is set to aList.Count. <see cref="Complex"/> and <see cref="Cols"/> propertes
      are auto-detected. Complex numbers must follow the format: a+bi. All strings must have the same number of columns
      (numbers). Columns must be separated with a Delimiter. By default the delimiter is the tab charachter.
</remarks>


      <Example>
      <code>
      var a,b: Matrix;
      begin
          a.SetIt(2,2,False,[1,2,3,4]);
          b.Size(a);
          b.SetVal(1);
          a := Cos(a) + b;
          Richedit1.Clear;
          Memo1.Clear;
          a.ValuesToStrings(Richedit1.Lines);
          b.ValuesToStrings(Richedit1.Lines);
          a.ValuesToStrings(Memo1.Lines);
          b.ValuesToStrings(Memo1.Lines);
          Memo1.Lines.SaveToFile('C:\Test.txt');
          Memo1.Lines.LoadFromFile('C:\Test.txt');
          a.StringsToValues(Memo1.Lines);
      end;
      </code>
      </Example>

      <SeeAlso cref="ValuesToStrings"/>*)
    function StringsToValues(aList: TStrings; const Delimiter: string = kTab): TMtx; overload;
    (*<summary>Convert strings from [ListIndex]..[ListIndex+ListLen-1] in aList to double (TCplx).</summary>
      
<remarks>Store them in the Values array of the calling matrix, starting from element [Row,Cols]. The size of the calling matrix is not changed.
      If array bounds are overrun an exception is raised. Complex numbers must follow the format: a+bi.
</remarks>
*)
    function StringsToValues(aList: TStrings; ListIndex,ListLen, Row,Col: Integer; Delimiter: string = kTab): TMtx; overload;

  end;
  


    
    VectorDouble = Vector;
    MatrixDouble = Matrix;
    



  (*<summary>Vector matrix multiply returning Vector type result.</summary>
             
<remarks>Internally calls <see cref="Vector.TensorProd"/>
</remarks>
*)
  
  function Mul(const Left: TVec; const Right: TMtx): Vector; overload;

  (*<summary>Matrix vector multiply returning Vector type result. </summary>
             
<remarks>Internally calls <see cref="Vector.TensorProd"/>
</remarks>
*)
  
  function Mul(const Left: TMtx; const  Right: TVec): Vector; overload;

  (*<summary>Tensor product of two vectors returning Matrix type result.</summary>
             
<remarks>Internally calls <see cref="Vector.TensorProd"/>
</remarks>
*)
  
  function Mul(const Left: TVec; const  Right: TVec): Matrix; overload;

  (*<summary>Divide Left vector with right matrix (matrix division) returning Vector type result.</summary>
             
<remarks>Internally calls <see cref="Matrix.LUSolve"/>
</remarks>
*)
  
  function Divide(const Left: TVec; const  Right: TMtx): Vector; overload;

  (*<summary>Divide Left with Right (matrix division) returning Matrix type result.</summary>
             
<remarks>Internally calls <see cref="Matrix.LUSolve"/>
</remarks>
*)
  
  function Divide(const Left: TMtx; const  Right: TMtx): Matrix; overload;

  (*<summary>Left divide Left with Right (matrix division) returning Vector type result.</summary>
             
<remarks>Internally calls <see cref="Matrix.LUSolve"/>
</remarks>
*)
  
  function LDivide(const Left: TMtx; const  Right: TVec): Vector; overload;

  (*<summary>Left divide Left with Right (matrix division) returning Matrix type result.</summary>
             
<remarks>Internally calls <see cref="Matrix.LUSolve"/>
</remarks>
*)
  
  function LDivide(const Left: TMtx; const  Right: TMtx): Matrix; overload;

  (*<summary>Compute the Inverse of the matrix and return it as result.</summary>
             
<remarks>Internally calls <see cref="Matrix.Inv"/>
</remarks>
*)
  
  function Inverse(const X: TMtx; MtxType: TMtxType = mtGeneral): Matrix; overload;

  (*<summary>Transpose of the matrix and return it as result.</summary>
             
<remarks>Internally calls <see cref="Matrix.Transp"/>
</remarks>
*)
  
  function Transp(const X: TMtx): Matrix; overload;

  (*<summary>Adjungate the matrix and return it as result.</summary>
             
<remarks>Internally calls <see cref="Matrix.Adjung"/>
</remarks>
*)
  
  function Adjung(const X: TMtx): Matrix; overload;


  (*<summary>Subrange the source vector. </summary>
             
<remarks>Internally calls <see cref="Vector.SetSubIndex"/>
</remarks>
*)
  
  function Select(const Src: TVec; StartIndex, Step, StopIndex: integer): Vector; overload; 

  (*<summary>Subrange the source vector without copy operation. </summary>
             
<remarks>Internally calls <see cref="Vector.SetSubIndex"/>
</remarks>
*)
  
  function Select(const Src: TVec; StartIndex, StopIndex: integer): Vector; overload; 

  (*<summary>Subrange the source matrix and return a vector. </summary>
             
<remarks>Internally calls <see cref="Vector.SetSubIndex"/>
</remarks>
*)
  
  function Select(const Src: TMtx; StartIndex, Step, StopIndex: integer): Vector; overload; 

  (*<summary>Subrange the source matrix and return a vector without copy operation. </summary>
             
<remarks>Internally calls <see cref="Vector.SetSubIndex"/>
</remarks>
*)
  
  function Select(const Src: TMtx; StartIndex, StopIndex: integer): Vector; overload; 

  (*<summary>Compute the sin function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Sin"/>
</remarks>
*)
  
  function Sin(const X: TVec): Vector; overload; 

  (*<summary>Compute the sin function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Sin"/>
</remarks>
*)
  
  function Sin(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the cos function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Cos"/>
</remarks>
*)
  
  function Cos(const X: TVec): Vector; overload; 

  (*<summary>Compute the cos function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Cos"/>
</remarks>
*)
  
  function Cos(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Tan function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Tan"/>
</remarks>
*)
  
  function Tan(const X: TVec): Vector; overload; 

  (*<summary>Compute the Tan function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Tan"/>
</remarks>
*)
  
  function Tan(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Cot function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Cot"/>
</remarks>
*)
  
  function Cot(const X: TVec): Vector; overload; 

  (*<summary>Compute the Cot function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Cot"/>
</remarks>
*)
  
  function Cot(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Sec function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Sec"/>
</remarks>
*)
  
  function Sec(const X: TVec): Vector; overload; 

  (*<summary>Compute the Sec function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Sec"/>
</remarks>
*)
  
  function Sec(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Csc function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Csc"/>
</remarks>
*)
  
  function Csc(const X: TVec): Vector; overload; 

  (*<summary>Compute the Csc function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Csc"/>
</remarks>
*)
  
  function Csc(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcSin function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcSin"/>
</remarks>
*)
  
  function ArcSin(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcSin function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcSin"/>
</remarks>
*)
  
  function ArcSin(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcCos function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcCos"/>
</remarks>
*)
  
  function ArcCos(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcCos function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcCos"/>
</remarks>
*)
  
  function ArcCos(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcTan function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcTan"/>
</remarks>
*)
  
  function ArcTan(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcTan function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcTan"/>
</remarks>
*)
  
  function ArcTan(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcTan2 function from X and Y and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcTan2"/>
</remarks>
*)
  
  function ArcTan2(const Y, X: TVec): Vector; overload; 

  (*<summary>Compute the ArcTan2 function from X and Y and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcTan2"/>
</remarks>
*)
  
  function ArcTan2(const Y, X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcCot function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcCot"/>
</remarks>
*)
  
  function ArcCot(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcCot function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcCot"/>
</remarks>
*)
  
  function ArcCot(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcSec function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcSec"/>
</remarks>
*)
  
  function ArcSec(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcSec function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcSec"/>
</remarks>
*)
  
  function ArcSec(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcCsc function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcCsc"/>
</remarks>
*)
  
  function ArcCsc(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcCsc function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcCsc"/>
</remarks>
*)
  
  function ArcCsc(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Sinh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Sinh"/>
</remarks>
*)
  
  function Sinh(const X: TVec): Vector; overload; 

  (*<summary>Compute the Sinh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Sinh"/>
</remarks>
*)
  
  function Sinh(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Cosh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Cosh"/>
</remarks>
*)
  
  function Cosh(const X: TVec): Vector; overload; 

  (*<summary>Compute the Cosh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Cosh"/>
</remarks>
*)
  
  function Cosh(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Tanh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Tanh"/>
</remarks>
*)
  
  function Tanh(const X: TVec): Vector; overload; 

  (*<summary>Compute the Tanh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Tanh"/>
</remarks>
*)
  
  function Tanh(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Coth function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Coth"/>
</remarks>
*)
  
  function Coth(const X: TVec): Vector; overload; 

  (*<summary>Compute the Coth function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Coth"/>
</remarks>
*)
  
  function Coth(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Sech function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Sech"/>
</remarks>
*)
  
  function Sech(const X: TVec): Vector; overload; 

  (*<summary>Compute the Sech function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Sech"/>
</remarks>
*)
  
  function Sech(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Csch function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Csch"/>
</remarks>
*)
  
  function Csch(const X: TVec): Vector; overload; 

  (*<summary>Compute the Csch function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Csch"/>
</remarks>
*)
  
  function Csch(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcSinh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcSinh"/>
</remarks>
*)
  
  function ArcSinh(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcSinh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcSinh"/>
</remarks>
*)
  
  function ArcSinh(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcCosh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcCosh"/>
</remarks>
*)
  
  function ArcCosh(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcCosh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcCosh"/>
</remarks>
*)
  
  function ArcCosh(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcTanh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcTanh"/>
</remarks>
*)
  
  function ArcTanh(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcTanh function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcTanh"/>
</remarks>
*)
  
  function ArcTanh(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcCoth function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcCoth"/>
</remarks>
*)
  
  function ArcCoth(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcCoth function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcCoth"/>
</remarks>
*)
  
  function ArcCoth(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcSech function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcSech"/>
</remarks>
*)
  
  function ArcSech(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcSech function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcSech"/>
</remarks>
*)
  
  function ArcSech(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the ArcCsch function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.ArcCsch"/>
</remarks>
*)
  
  function ArcCsch(const X: TVec): Vector; overload; 

  (*<summary>Compute the ArcCsch function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.ArcCsch"/>
</remarks>
*)
  
  function ArcCsch(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Abs function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Abs"/>
</remarks>
*)
  
  function Abs(const X: TVec): Vector; overload; 

  (*<summary>Compute the Abs function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Abs"/>
</remarks>
*)
  
  function Abs(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Cbrt function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Cbrt"/>
</remarks>
*)
  
  function Cbrt(const X: TVec): Vector; overload; 

  (*<summary>Compute the Cbrt function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Cbrt"/>
</remarks>
*)
  
  function Cbrt(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Ceil function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Ceil"/>
</remarks>
*)
  
  function Ceil(const X: TVec): Vector; overload; 

  (*<summary>Compute the Ceil function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Ceil"/>
</remarks>
*)
  
  function Ceil(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Ln function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Ln"/>
</remarks>
*)
  
  function Ln(const X: TVec): Vector; overload; 

  (*<summary>Compute the Ln function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Ln"/>
</remarks>
*)
  
  function Ln(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Log10 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Log10"/>
</remarks>
*)
  
  function Log10(const X: TVec): Vector; overload; 

  (*<summary>Compute the Log10 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Log10"/>
</remarks>
*)
  
  function Log10(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Log2 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Log2"/>
</remarks>
*)
  
  function Log2(const X: TVec): Vector; overload; 

  (*<summary>Compute the Log2 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Log2"/>
</remarks>
*)
  
  function Log2(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Exp function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Exp"/>
</remarks>
*)
  
  function Exp(const X: TVec): Vector; overload; 

  (*<summary>Compute the Exp function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Exp"/>
</remarks>
*)
  
  function Exp(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Exp2 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Exp2"/>
</remarks>
*)
  
  function Exp2(const X: TVec): Vector; overload; 

  (*<summary>Compute the Exp2 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Exp2"/>
</remarks>
*)
  
  function Exp2(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the Exp10 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Vector.Exp10"/>
</remarks>
*)
  
  function Exp10(const X: TVec): Vector; overload; 

  (*<summary>Compute the Exp10 function from the source and return the result. </summary>
             
<remarks>Internally calls <see cref="Matrix.Exp10"/>
</remarks>
*)
  
  function Exp10(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the imaginary part of the source. </summary>
             
<remarks>Internally calls <see cref="Vector.ImagPart"/>
</remarks>
*)
  
  function ImagPart(const X: TVec): Vector; overload; 

  (*<summary>Returns the imaginary part of the source. </summary>
             
<remarks>Internally calls <see cref="Vector.ImagPart"/>
</remarks>
*)

  function Imag(const X: TVec): Vector; overload; 

  (*<summary>Returns the imaginary part of the source. </summary>
             
<remarks>Internally calls <see cref="Matrix.ImagPart"/>
</remarks>
*)
  
  function ImagPart(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the imaginary part of the source. </summary>
             
<remarks>Internally calls <see cref="Matrix.ImagPart"/>
</remarks>
*)

  function Imag(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the integer power function. </summary>
             
<remarks>Internally calls <see cref="Vector.IntPower"/>
</remarks>
*)
  
  function IntPower(const Base: TVec; Exponent: integer): Vector; overload; 

  (*<summary>Compute the integer power function. </summary>
             
<remarks>Internally calls <see cref="Matrix.IntPower"/>
</remarks>
*)
  
  function IntPower(const Base: TMtx; Exponent: integer): Matrix; overload; 


  (*<summary>Compute 1/X. </summary>
             
<remarks>Internally calls <see cref="Vector.Inv"/>
</remarks>
*)
  
  function Inv(const X: TVec): Vector; overload; 

  (*<summary>Compute 1/X. </summary>
             
<remarks>Internally calls <see cref="Matrix.InvElem"/>
</remarks>
*)
  
  function Inv(const X: TMtx): Matrix; overload; 

  (*<summary>Compute 1/X. </summary>
             
<remarks>Internally calls <see cref="Vector.Inv"/>
</remarks>
*)
  
  function Inv(const X: TVec; Threshold: double): Vector; overload; 

  (*<summary>Compute 1/X. </summary>
             
<remarks>Internally calls <see cref="Matrix.InvElem"/>
</remarks>
*)
  
  function Inv(const X: TMtx; Threshold: double): Matrix; overload; 

  (*<summary>Compute (1/X)^2. </summary>
             
<remarks>Internally calls <see cref="Vector.InvSqrt"/>
</remarks>
*)
  
  function InvSqrt(const X: TVec): Vector; overload; 

  (*<summary>Compute (1/X)^2. </summary>
             
<remarks>Internally calls <see cref="Matrix.InvSqrt"/>
</remarks>
*)
  
  function InvSqrt(const X: TMtx): Matrix; overload; 

  (*<summary>Compute (1/X)^2. </summary>
             
<remarks>Internally calls <see cref="Vector.InvCbrt"/>
</remarks>
*)
  
  function InvCbrt(const X: TVec): Vector; overload; 

  (*<summary>Compute (1/X)^2. </summary>
             
<remarks>Internally calls <see cref="Matrix.InvCbrt"/>
</remarks>
*)
  
  function InvCbrt(const X: TMtx): Matrix; overload; 

  (*<summary>Return complex conjugate of the source. </summary>
             
<remarks>Internally calls <see cref="Matrix.Conj"/>
</remarks>
*)
  
  function Conj(const X: TVec): Vector; overload; 

  (*<summary>Return complex conjugate of the source. </summary>
             
<remarks>Internally calls <see cref="Matrix.Conj"/>
</remarks>
*)
  
  function Conj(const X: TMtx): Matrix; overload; 

  (*<summary>Extend the source to complex numbers.  </summary>
             
<remarks>Internally calls <see cref="Vector.ExtendToComplex"/>
</remarks>
*)
  
  function ExtendToComplex(const X: TVec; Zeros: boolean = true): Vector; overload; 

  (*<summary>Extend the source to complex numbers.  </summary>
             
<remarks>Internally calls <see cref="Matrix.ExtendToComplex"/>
</remarks>
*)
  
  function ExtendToComplex(const X: TMtx; Zeros: boolean = true): Matrix; overload; 

  (*<summary>Make the angle fit within +/- PI.  </summary>
             
<remarks>Internally calls <see cref="Vector.FixAngle"/>
</remarks>
*)
  
  function FixAngle(const X: TVec): Vector; overload; 

  (*<summary>Make the angle fit within +/- PI.  </summary>
             
<remarks>Internally calls <see cref="Vector.FixAngle"/>
</remarks>
*)
  
  function FixAngle(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the floor function from the source.  </summary>
             
<remarks>Internally calls <see cref="Vector.Floor"/>
</remarks>
*)
  
  function Floor(const X: TVec): Vector; overload; 

  (*<summary>Compute the floor function from the source.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Floor"/>
</remarks>
*)
  
  function Floor(const X: TMtx): Matrix; overload; 

  (*<summary>Computes the e^xj function from the source.  </summary>
             
<remarks>Internally calls <see cref="Vector.Expj"/>
</remarks>
*)
  
  function Expj(const X: TVec): Vector; overload; 

  (*<summary>Computes the e^xj function from the source.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Expj"/>
</remarks>
*)
  
  function Expj(const X: TMtx): Matrix; overload; 

  (*<summary>Return the fractional part of a real number in the source.  </summary>
             
<remarks>Internally calls <see cref="Vector.Frac"/>
</remarks>
*)
  
  function Frac(const X: TVec): Vector; overload; 

  (*<summary>Return the fractional part of a real number in the source.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Frac"/>
</remarks>
*)
  
  function Frac(const X: TMtx): Matrix; overload; 

  (*<summary>Exchange the real and imaginary parts of complex numbers.  </summary>
             
<remarks>Internally calls <see cref="Vector.Flip"/>
</remarks>
*)
  
  function Flip(const X: TVec): Vector; overload; 

  (*<summary>Exchange the real and imaginary parts of complex numbers.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Flip"/>
</remarks>
*)
  
  function Flip(const X: TMtx): Matrix; overload; 

  (*<summary>Exchange the real and imaginary parts of complex numbers and conjugate.  </summary>
             
<remarks>Internally calls <see cref="Vector.FlipConj"/>
</remarks>
*)
  
  function FlipConj(const X: TVec): Vector; overload; 

  (*<summary>Exchange the real and imaginary parts of complex numbers and conjugate.  </summary>
             
<remarks>Internally calls <see cref="Matrix.FlipConj"/>
</remarks>
*)
  
  function FlipConj(const X: TMtx): Matrix; overload; 

  (*<summary>Return reminder after divison of X by Y.  </summary>
             
<remarks>Internally calls <see cref="Vector.Rem"/>
</remarks>
*)
  
  function Rem(const X,Y: TVec): Vector; overload; 

  (*<summary>Return reminder after divison of X by Y.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Rem"/>
</remarks>
*)
  
  function Rem(const X,Y: TMtx): Matrix; overload; 

  (*<summary>Return reminder after divison of X by Y.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Rem"/>
</remarks>
*)
  
  function Rem(const X: TVec; const Y: double): Vector; overload; 

  (*<summary>Return reminder after divison of X by Y.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Rem"/>
</remarks>
*)
  
  function Rem(const X: TMtx; const Y: double): Matrix; overload; 

  (*<summary>Compute magnitude from the source.  </summary>
             
<remarks>Internally calls <see cref="Vector.Mag"/>
</remarks>
*)
  
  function Mag(const X: TVec): Vector; overload; 

  (*<summary>Compute magnitude from the source.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Mag"/>
</remarks>
*)
  
  function Mag(const X: TMtx): Matrix; overload; 

  (*<summary>Compute X^2 from the source.  </summary>
             
<remarks>Internally calls <see cref="Vector.Sqr"/>
</remarks>
*)
  
  function Sqr(const X: TVec): Vector; overload; 

  (*<summary>Compute X^2 from the source.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Sqr"/>
</remarks>
*)
  
  function Sqr(const X: TMtx): Matrix; overload; 

  (*<summary>Compute X^2 from the source.  </summary>
             
<remarks>Internally calls <see cref="Vector.Sqrt"/>
</remarks>
*)
  
  function Sqrt(const X: TVec): Vector; overload; 

  (*<summary>Compute X^2 from the source.  </summary>
             
<remarks>Internally calls <see cref="Matrix.Sqrt"/>
</remarks>
*)
  
  function Sqrt(const X: TMtx): Matrix; overload; 

  (*<summary>Compute X^2 from the source.  </summary>
             
<remarks>Internally calls <see cref="Vector.LogN"/>
</remarks>
*)
  
  function LogN(const X: TVec; N: double): Vector; overload; 

  (*<summary>Compute X^2 from the source.  </summary>
             
<remarks>Internally calls <see cref="Matrix.LogN"/>
</remarks>
*)
  
  function LogN(const X: TMtx; N: double): Matrix; overload; 

  (*<summary>Multiply the source with 1i complex number.  </summary>
             
<remarks>Internally calls <see cref="Vector.MulI"/>
</remarks>
*)
  
  function MulI(const X: TVec): Vector; overload; 

  (*<summary>Multiply the source with 1i complex number.  </summary>
             
<remarks>Internally calls <see cref="Matrix.MulI"/>
</remarks>
*)
  
  function MulI(const X: TMtx): Matrix; overload; 

  (*<summary>Compute (X + Offset)/Factor  </summary>
             
<remarks>Internally calls <see cref="Vector.Normalize"/>
</remarks>
*)
  
  function Normalize(const X: TVec; Offset, Factor: double): Vector; overload; 

  (*<summary>Compute (X + Offset)/Factor  </summary>
             
<remarks>Internally calls <see cref="Vector.Normalize"/>
</remarks>
*)
  
  function Normalize(const X: TVec; const Offset, Factor: TCplx): Vector; overload; 

  (*<summary>Compute (X + Offset)/Factor  </summary>
             
<remarks>Internally calls <see cref="Vector.Normalize"/>
</remarks>
*)
  
  function Normalize(const X: TVec; const Offset: TCplx; Factor: double): Vector; overload; 

  (*<summary>Compute (X + Offset)/Factor  </summary>
             
<remarks>Internally calls <see cref="Matrix.Normalize"/>
</remarks>
*)
  
  function Normalize(const X: TMtx; Offset, Factor: double): Matrix; overload; 

  (*<summary>Compute (X + Offset)/Factor  </summary>
             
<remarks>Internally calls <see cref="Matrix.Normalize"/>
</remarks>
*)
  
  function Normalize(const X: TMtx; const Offset, Factor: TCplx): Matrix; overload; 

  (*<summary>Compute (X + Offset)/Factor  </summary>
             
<remarks>Internally calls <see cref="Matrix.Normalize"/>
</remarks>
*)
  
  function Normalize(const X: TMtx; const Offset: TCplx; Factor: double): Matrix; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Vector.Power"/>
</remarks>
*)
  
  function Power(const Base: TVec; Exponent: double): Vector; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Matrix.Power"/>
</remarks>
*)
  
  function Power(const Base: TMtx; Exponent: double): Matrix; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Vector.Power"/>
</remarks>
*)
  
  function Power(Base: double; const Exponent: TVec): Vector; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Matrix.Power"/>
</remarks>
*)
  
  function Power(Base: double; const Exponent: TMtx): Matrix; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Vector.Power"/>
</remarks>
*)
  
  function Power(const Base: TCplx; const Exponent: TVec): Vector; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Matrix.Power"/>
</remarks>
*)
  
  function Power(const Base: TCplx; const Exponent: TMtx): Matrix; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Vector.Power"/>
</remarks>
*)
  
  function Power(const Base: TVec; const Exponent: TVec): Vector; overload; 
  
  function Power(const Base: TMtx; const Exponent: TMtx): Matrix; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Vector.Power"/>
</remarks>
*)
  
  function Power(const Base: TVec; const Exponent: TCplx): Vector; overload; 

  (*<summary>Compute the power function. </summary>
             
<remarks>Internally calls <see cref="Matrix.Power"/>
</remarks>
*)
  
  function Power(const Base: TMtx; const Exponent: TCplx): Matrix; overload; 

  (*<summary>Compute the phase spectrum. </summary>
             
<remarks>Internally calls <see cref="Vector.PhaseSpectrum"/>
</remarks>
*)
  
  function PhaseSpectrum(const X: TVec): Vector; overload; 

  (*<summary>Compute the phase spectrum from the complex source data. </summary>
             
<remarks>Internally calls <see cref="Matrix.PhaseSpectrum"/>
</remarks>
*)
  
  function PhaseSpectrum(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the phase from the complex source data. </summary>
             
<remarks>Internally calls <see cref="Vector.PhaseSpectrum"/>
</remarks>
*)
  
  function Phase(const X: TVec): Vector; overload; 

  (*<summary>Compute the phase from the complex source data. </summary>
             
<remarks>Internally calls <see cref="Matrix.PhaseSpectrum"/>
</remarks>
*)
  
  function Phase(const X: TMtx): Matrix; overload; 

  (*<summary>Compute the power spectrum from the complex source data. </summary>
             
<remarks>Internally calls <see cref="Vector.PowerSpectrum"/>
</remarks>
*)
  
  function PowerSpectrum(const X: TVec): Vector; overload; 

  (*<summary>Compute the power spectrum from the complex source data. </summary>
             
<remarks>Internally calls <see cref="Matrix.PowerSpectrum"/>
</remarks>
*)
  
  function PowerSpectrum(const X: TMtx): Matrix; overload; 


  (*<summary>Returns random values with gaussian distribution. </summary>
             
<remarks>Internally calls <see cref="Vector.RandGauss"/>
</remarks>
*)
  
  function RandGauss(Len: integer; const FloatPrecision: TMtxFloatPrecision): Vector; overload; 
  (*<summary>Returns random values with gaussian distribution. </summary>
             
<remarks>Internally calls <see cref="Matrix.RandGauss"/>
</remarks>
*)
  
  function RandGauss(Rows, Cols: integer; const FloatPrecision: TMtxFloatPrecision): Matrix; overload; 

  (*<summary>Returns random values with gaussian distribution. </summary>
             
<remarks>Internally calls <see cref="Vector.RandGauss"/>
</remarks>
*)
  
  function RandGauss(Len: integer; const FloatPrecision: TMtxFloatPrecision; aMean, aStdDev: double): Vector; overload; 


  (*<summary>Returns random values with gaussian distribution. </summary>
             
<remarks>Internally calls <see cref="Matrix.RandGauss"/>
</remarks>
*)
  
  function RandGauss(Rows, Cols: integer; const FloatPrecision: TMtxFloatPrecision; aMean, aStdDev: double): Matrix; overload; 

  (*<summary>Returns random values with uniform distribution. </summary>
             
<remarks>Internally calls <see cref="Vector.RandUniform"/>
</remarks>
*)
  
  function RandUniform(Len: integer; const FloatPrecision: TMtxFloatPrecision): Vector; overload; 

  (*<summary>Returns random values with uniform distribution. </summary>
             
<remarks>Internally calls <see cref="Matrix.RandUniform"/>
</remarks>
*)
  
  function RandUniform(Rows, Cols: integer; const FloatPrecision: TMtxFloatPrecision): Matrix; overload; 

  (*<summary>Returns random values with uniform distribution. </summary>
             
<remarks>Internally calls <see cref="Vector.RandUniform"/>
</remarks>
*)
  
  function RandUniform(Len: integer; const FloatPrecision: TMtxFloatPrecision; aLow, aHigh: double): Vector; overload; 

  (*<summary>Returns random values with uniform distribution. </summary>
             
<remarks>Internally calls <see cref="Matrix.RandUniform"/>
</remarks>
*)
  
  function RandUniform(Rows, Cols: integer; const FloatPrecision: TMtxFloatPrecision; aLow, aHigh: double): Matrix; overload; 

  (*<summary>Rounds values to the closest integer. </summary>
             
<remarks>Internally calls <see cref="Vector.Round"/>
</remarks>
*)
  
  function Round(const X: TVec): Vector; overload; 

  (*<summary>Rounds values to the closest integer. </summary>
             
<remarks>Internally calls <see cref="Matrix.Round"/>
</remarks>
*)
  
  function Round(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the real part of the complex number. </summary>
             
<remarks>Internally calls <see cref="Vector.RealPart"/>
</remarks>
*)
  
  function RealPart(const X: TVec): Vector; overload; 

  (*<summary>Returns the real part of the complex number. </summary>
             
<remarks>Internally calls <see cref="Matrix.RealPart"/>
</remarks>
*)
  
  function RealPart(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the real part of the complex number. </summary>
             
<remarks>Internally calls <see cref="Vector.RealPart"/>
</remarks>
*)
  
  function Real(const X: TVec): Vector; overload; 

  (*<summary>Returns the real part of the complex number. </summary>
             
<remarks>Internally calls <see cref="Matrix.RealPart"/>
</remarks>
*)
  
  function Real(const X: TMtx): Matrix; overload; 

  (*<summary>Change the sign of the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.Sign"/>
</remarks>
*)
  
  function Sign(const X: TVec): Vector; overload; 

  (*<summary>Change the sign of the source data. </summary>
             
<remarks>Internally calls <see cref="Matrix.Sign"/>
</remarks>
*)
  
  function Sign(const X: TMtx): Matrix; overload; 


  (*<summary>Rounds values towards to zero to integer. </summary>
             
<remarks>Internally calls <see cref="Vector.Trunc"/>
</remarks>
*)
  
  function Trunc(const X: TVec): Vector; overload; 

  (*<summary>Rounds values towards zero to integer. </summary>
             
<remarks>Internally calls <see cref="Matrix.Trunc"/>
</remarks>
*)
  
  function Trunc(const X: TMtx): Matrix; overload; 

  (*<summary>Limit the smallest value in the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.ThreshBottom"/>
</remarks>
*)
  
  function ThreshBottom(const X: TVec; Value: double): Vector; overload; 

  (*<summary>Limit the smallest value in the source data. </summary>
             
<remarks>Internally calls <see cref="Matrix.ThreshBottom"/>
</remarks>
*)
  
  function ThreshBottom(const X: TMtx; Value: double): Matrix; overload; 

  (*<summary>Limit the largest value in the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.ThreshTop"/>
</remarks>
*)
  
  function ThreshTop(const X: TVec; Value: double): Vector; overload; 

  (*<summary>Limit the largest value in the source data. </summary>
             
<remarks>Internally calls <see cref="Matrix.ThreshTop"/>
</remarks>
*)
  
  function ThreshTop(const X: TMtx; Value: double): Matrix; overload; 

  (*<summary>Computes X + Y*Ascale </summary>
             
<remarks>Internally calls <see cref="Vector.AddScaled"/>
</remarks>
*)
  
  function AddScaled(const X,Y: TVec; aScale: double): Vector; overload; 
  (*<summary>Computes X + Y*Ascale </summary>
             
<remarks>Internally calls <see cref="Matrix.AddScaled"/>
</remarks>
*)
  
  function AddScaled(const X,Y: TMtx; aScale: double): Matrix; overload; 
  (*<summary>Computes X + Y*Ascale </summary>
             
<remarks>Internally calls <see cref="Vector.AddScaled"/>
</remarks>
*)
  
  function AddScaled(const X,Y: TVec; const aScale: TCplx): Vector; overload; 
  (*<summary>Computes X + Y*Ascale </summary>
             
<remarks>Internally calls <see cref="Matrix.AddScaled"/>
</remarks>
*)
  
  function AddScaled(const X,Y: TMtx; const aScale: TCplx): Matrix; overload; 

  (*<summary>Computes X + Y*Z </summary>
             
<remarks>Internally calls <see cref="Vector.AddProduct"/>
</remarks>
*)
  
  function AddProduct(const X, Y, Z: TVec): Vector; overload; 

  (*<summary>Computes X + Y*Z </summary>
             
<remarks>Internally calls <see cref="Matrix.AddProduct"/>
</remarks>
*)
  
  function AddProduct(const X, Y, Z: TMtx): Matrix; overload; 

  (*<summary>Conjugate Y and multiply with X </summary>
             
<remarks>Internally calls <see cref="Vector.ConjMul"/>
</remarks>
*)
  
  function ConjMul(const X, Y: TVec): Vector; overload; 

  (*<summary>Conjugate Y and multiply with X </summary>
             
<remarks>Internally calls <see cref="Matrix.ConjMul"/>
</remarks>
*)
  
  function ConjMul(const X, Y: TMtx): Matrix; overload; 

  (*<summary>Returns the sum of all elements in the source data.</summary>
             
<remarks>Internally calls <see cref="Vector.CumSum"/>
</remarks>
*)
  
  function CumSum(const X: TVec): Vector; overload; 

  (*<summary>Returns the sum of all elements in the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.CumSum"/>
</remarks>
*)
  
  function CumSum(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the discrete cosine transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Vector.DCT"/>
</remarks>
*)
  
  function DCT(const X: TVec): Vector; overload; 

  (*<summary>Returns the inverse discrete cosine transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Vector.IDCT"/>
</remarks>
*)
  
  function IDCT(const X: TVec): Vector; overload; 

  (*<summary>Returns the difference of consecutive elements of the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.Difference"/>
</remarks>
*)
  
  function Difference(const X: TVec): Vector; overload; 

  (*<summary>Returns the dot product: sum(X*Y).</summary>
             
<remarks>Internally calls <see cref="Vector.DotProd"/>
</remarks>
*)
  
  function DotProd(const X,Y: TVec): double; overload; 
  (*<summary>Returns the dot product: sum(X*Y).</summary>
             
<remarks>Internally calls <see cref="Vector.DotProdc"/>
</remarks>
*)
  
  function DotProdc(const X,Y: TVec; ConjY: boolean = false): TCplx; overload; 

  (*<summary>Returns the discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Vector.FFT"/>
</remarks>
*)
  
  function FFT(const X: TVec; ConjugateExtend: boolean = false): Vector; overload; 

  (*<summary>Returns the 1D discrete fourier transforms of the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.FFT1D"/>
</remarks>
*)
  
  function FFT1D(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the 2D discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.FFT2D"/>
</remarks>
*)
  
  function FFT2D(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the discrete fourier transform of the real source data.</summary>
             
<remarks>Internally calls <see cref="Vector.FFTFromReal"/>
</remarks>
*)
  
  function FFTFromReal(const X: TVec): Vector; overload; 

  (*<summary>Returns the discrete fourier transform of the real source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.FFT1D"/>
</remarks>
*)
  
  function FFT1DFromReal(const X: TMtx): Matrix; overload; 

  (*<summary>Returns the discrete fourier transform of the real source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.FFT2DFromReal"/>
</remarks>
*)
  
  function FFT2DFromReal(const X: TMtx): Matrix; overload; 

  (*<summary>Computes the real inverse discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Vector.IFFTToReal"/>
</remarks>
*)
  
  function IFFTToReal(const X: TVec; NoScale: boolean=False): Vector; overload; 

  (*<summary>Computes the real inverse discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.IFFT1DToReal"/>
</remarks>
*)
  
  function IFFT1DToReal(const X: TMtx): Matrix; overload; 

  (*<summary>Computes the real inverse discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.IFFT2DToReal"/>
</remarks>
*)
  
  function IFFT2DToReal(const X: TMtx): Matrix; overload; 

  (*<summary>Computes the inverse discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Vector.IFFT"/>
</remarks>
*)
  
  function IFFT(const X: TVec; NoScale: boolean=False): Vector; overload; 

  (*<summary>Computes the inverse discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.IFFT1D"/>
</remarks>
*)
  
  function IFFT1D(const X: TMtx; NoScale: boolean=False): Matrix; overload; 

  (*<summary>Computes the inverse discrete fourier transform of the source data.</summary>
             
<remarks>Internally calls <see cref="Matrix.IFFT2D"/>
</remarks>
*)
  
  function IFFT2D(const X: TMtx; NoScale: boolean=False): Matrix; overload; 



  (*<summary>Reverses the content of the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.Reverse"/>
</remarks>
*)
  
  function Reverse(const X: TVec): Vector; overload; 

  (*<summary>Rotates the content of the source data by Offset. </summary>
             
<remarks>Internally calls <see cref="Vector.Rotate"/>
</remarks>
*)
  
  function Rotate(const X: TVec; Offset: integer): Vector; overload; 

  (*<summary>Shifts the content of the source data X by Offset left or right. </summary>
             
<remarks>Internally calls <see cref="Vector.Shift"/>
</remarks>
*)
  
  function Shift(const X: TVec; Offset: integer): Vector; overload; 

  (*<summary>Returns biased auto correlation of the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.Skewness"/>
</remarks>
*)
  
  function AutoCorrBiased(const Vec: TVec; Lags: integer): Vector; overload; 

  (*<summary>Returns normal auto correlation of the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.Skewness"/>
</remarks>
*)
  
  function AutoCorrNormal(const Vec: TVec; Lags: integer): Vector; overload; 

  (*<summary>Returns unbiased auto correlation of the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.Skewness"/>
</remarks>
*)
  
  function AutoCorrUnBiased(const Vec: TVec; Lags: integer): Vector; overload; 

  (*<summary>Concatenates multiple Vectors in to a single one. </summary>
             
<remarks>Internally calls <see cref="Vector.Concat"/>
</remarks>
*)
  
  function Concat(const Src: array of TVec): Vector; overload;
  (*<summary>Concatenates multiple Vectors in to a single one. </summary>
             
<remarks>Internally calls <see cref="Vector.Concat"/>
</remarks>
*)
  
  function Concat(const X1, X2: TMtxVec): Vector;  overload;

  (*<summary>Returns convolution of X with H. </summary>
             
<remarks>Internally calls <see cref="Vector.Convolve"/>
</remarks>
*)
  
  function Convolve(const X, H: TVec): Vector; overload; 

  (*<summary>Returns cross correlation between Vec1 and Vec2. </summary>
             
<remarks>Internally calls <see cref="Vector.CrossCorr"/>
</remarks>
*)
  
  function CrossCorr(const Vec1, Vec2: TVec; HiLag, LoLag: integer): Vector; overload; 

  (*<summary>Returns k-th diagonal from the source matrix.</summary>
             
<remarks>Internally calls <see cref="Vector.Diag"/>
</remarks>
*)
  
  function Diag(const Mtx: TMtx; k: integer): Vector; overload; 

  (*<summary>Reduces the sampling frequency without filtering.</summary>
             
<remarks>Internally calls <see cref="Vector.DownSample"/>
</remarks>
*)
  
  function DownSample(const Src: TVec; Factor: integer; Phase: integer = 0): Vector; overload; 

  (*<summary>Reduces the sampling frequency without filtering.</summary>
             
<remarks>Internally calls <see cref="Matrix.DownSample"/>
</remarks>
*)
  
  function DownSample(const Src: TMtx; Factor: integer; Phase: integer = 0): Vector; overload; 

  (*<summary>Returns specified column from the source matrix.</summary>
             
<remarks>Internally calls <see cref="Vector.GetCol"/>
</remarks>
*)
  
  function Col(const Mtx: TMtx; aCol: integer): Vector; overload; 

  (*<summary>Returns specified column from the source matrix.</summary>
             
<remarks>Internally calls <see cref="Vector.GetCol"/>
</remarks>
*)
  
  function Col(const Mtx: TMtx; aRow, aCol, Len: integer): Vector; overload; 

  (*<summary>Returns specified aRow from the source matrix.</summary>
             
<remarks>Internally calls <see cref="Vector.GetRow"/>
</remarks>
*)
  
  function Row(const Mtx: TMtx; aRow: integer): Vector; overload; 

  (*<summary>Returns specified aRow from the source matrix.</summary>
             
<remarks>Internally calls <see cref="Vector.GetRow"/>
</remarks>
*)
  
  function Row(const Mtx: TMtx; aRow, aCol, Len: integer): Vector; overload; 

  (*<summary>Computes the hilbert transform of the source data. </summary>
             
<remarks>Internally calls <see cref="Vector.Hilbert"/>
</remarks>
*)
  
  function Hilbert(const Vec: TVec): Vector; overload; 

  (*<summary>Computes the kronecker product. </summary>
             
<remarks>Internally calls <see cref="Vector.Kron"/>
</remarks>
*)
  
  function Kron(const Vec1, Vec2: TVec): Vector; overload; 

  (*<summary>Computes the Norm from source data. </summary>
             
<remarks>Internally calls <see cref="Vector.Norm"/>
</remarks>
*)
  
  function Norm(const Vec: TVec): Vector; overload;

  (*<summary>Returns primer numbers up to number n. </summary>
             
<remarks>Internally calls <see cref="Vector.PrimeNumbers"/>
</remarks>
*)
  
  function PrimeNumbers(n: integer): Vector;


  (*<summary>Returns a vector of [0, 1, .., Len-1]  numbers. </summary>
             
<remarks>Internally calls <see cref="Vector.Ramp"/>
</remarks>
*)
  
  function Ramp(Len: integer; const FloatPrecision: TMtxFloatPrecision): Vector; overload; 

  (*<summary>Returns a vector of [0, 1, .., Len-1]  numbers. </summary>
             
<remarks>It uses LengthAndFloatPrecisionSrc to obtain Length and FloatPrecision params.
             Internally calls <see cref="TVec.Ramp"/>
</remarks>
*)
  
  function Ramp(const LengthAndFloatPrecisionSrc: TMtxVec): Vector;  overload; 

  (*<summary>Returns a vector of [Offset, Offset+Step, .., Offset+(Len-1)*Step] numbers. </summary>
             
<remarks>Internally calls <see cref="TVec.Ramp"/>
</remarks>
*)
  
  function Ramp(Len: integer; const FloatPrecision: TMtxFloatPrecision; const Offset, Step: TCplx): Vector; overload; 

  (*<summary>Returns a vector of [0, 1, .., Len-1]  numbers. </summary>
             
<remarks>It uses LengthAndFloatPrecisionSrc to obtain Length and FloatPrecision params.
             Internally calls <see cref="TVec.Ramp"/>
</remarks>
*)
  
  function Ramp(const LengthAndFloatPrecisionSrc: TMtxVec; const Offset, Step: TCplx): Vector; overload; 

  (*<summary>Returns a vector of [Offset, Offset+Step, .., Offset+(Len-1)*Step] numbers. </summary>
             
<remarks>Internally calls <see cref="TVec.Ramp"/>
</remarks>
*)
  
  function Ramp(Len: integer; const FloatPrecision: TMtxFloatPrecision; Offset, Step: double): Vector; overload; 

  (*<summary>Returns a vector of [0, 1, .., Len-1]  numbers. </summary>
             
<remarks>It uses LengthAndFloatPrecisionSrc to obtain Length and FloatPrecision params.
             Internally calls <see cref="TVec.Ramp"/>
</remarks>
*)
  
  function Ramp(const LengthAndFloatPrecisionSrc: TMtxVec; Offset, Step: double): Vector; overload; 

  (*<summary>Returns a vector of [Offset, Offset+Step, .., Offset+(Len-1)*Step] numbers. </summary>
             
<remarks>Internally calls <see cref="TVec.Ramp"/>
</remarks>
*)
  
  function Ramp(Len: integer; const FloatPrecision: TMtxFloatPrecision; const Offset: TCplx; Step: double): Vector; overload; 

  (*<summary>Returns a vector of [0, 1, .., Len-1]  numbers. </summary>
             
<remarks>It uses LengthAndFloatPrecisionSrc to obtain Length and FloatPrecision params.
             Internally calls <see cref="TVec.Ramp"/>
</remarks>
*)
  
  function Ramp(const LengthAndFloatPrecisionSrc: TMtxVec; const Offset: TCplx; Step: double): Vector; overload; 

  (*<summary>Sorts the source data ascendingly. </summary>
             
<remarks>Internally calls <see cref="TVec.SortAscend"/>
</remarks>
*)
  
  function SortAscend(const Src: TVec): Vector; overload; 

  (*<summary>Sorts the source data ascendingly. </summary>
             
<remarks>Internally calls <see cref="TVec.SortAscend"/>
</remarks>
*)
  
  function SortAscend(const Src: TVec; const IndexVec: TVecInt): Vector; overload; 

  (*<summary>Sorts the source data descendingly. </summary>
             
<remarks>Internally calls <see cref="TVec.SortDescend"/>
</remarks>
*)
  
  function SortDescend(const Src: TVec): Vector; overload; 

  (*<summary>Sorts the source data descendingly. </summary>
             
<remarks>Internally calls <see cref="TVec.SortDescend"/>
</remarks>
*)
  
  function SortDescend(const Src: TVec; const IndexVec: TVecInt): Vector; overload; 

  (*<summary>Converts a list of strings to vector. </summary>
             
<remarks>Internally calls <see cref="TVec.StringsToValues"/>
</remarks>
*)
  
  function StringsToValues(const aList: TStrings): Vector;  overload; 

  (*<summary>Converts a list of strings to vector. </summary>
             
<remarks>Internally calls <see cref="Vector.StringsToValues"/>
</remarks>
*)
  
  function StringsToValues(const aList: TStrings; ListIndex: integer; Index: integer = 0; Len: integer = MtxVecEOA): Vector; overload; 

  (*<summary>Increase sampling frequency without filtering. </summary>
             
<remarks>Internally calls <see cref="Vector.UpSample"/>
</remarks>
*)
  
  function UpSample(const Src: TMtx; Factor: integer; Phase: integer = 0): Vector; overload; 

  (*<summary>Increase sampling frequency without filtering. </summary>
             
<remarks>Internally calls <see cref="Vector.UpSample"/>
</remarks>
*)
  
  function UpSample(const Src: TVec; Factor: integer; Phase: integer = 0): Vector; overload; 

  (*<summary>Returns Src + Vector1*Vector2' </summary>
             
<remarks>Internally calls <see cref="Matrix.AddTensorProd"/>
</remarks>
*)
  
  function AddTensorProd(const Src: TMtx; const Vec1, Vec2: TVec; ConjVec2: boolean = False): Matrix; overload; 

  (*<summary>Converts a banded matrix to dense storage. </summary>
             
<remarks>Internally calls <see cref="Matrix.BandedToDense"/>
</remarks>
*)
  
  function BandedToDense(const X: TMtx): Matrix; overload; 

  (*<summary>Returns true, if matrix is symmetric and positive definite. </summary>
             
<remarks>Internally calls <see cref="Matrix.Cholesky"/>
</remarks>
*)
  
  function Cholesky(const X: TMtx): boolean; overload; 

  (*<summary>Concatenate a list of matrices in to one big matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Concat"/>
</remarks>
*)
  
  function Concat(ARows, ACols: integer; const Src: array of TMtx): Matrix;  overload;

  (*<summary>Horizontally concatenate a list of matrices in to one big matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.ConcatHorz"/>
</remarks>
*)
  
  function ConcatHorz(const Src: array of TMtx): Matrix;  overload;

  (*<summary>Horizontally concatenate a list of matrices in to one big matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.ConcatHorz"/>
</remarks>
*)
  
  function ConcatHorz(DestRow, DestCol: integer;const Src: array of TMtx): Matrix; overload;

  (*<summary>Vertically concatenate a list of matrices in to one big matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.ConcatVert"/>
</remarks>
*)
  
  function ConcatVert(const Src: array of TMtx): Matrix;  overload;

  (*<summary>Vertically concatenate a list of matrices in to one big matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.ConcatVert"/>
</remarks>
*)
  
  function ConcatVert(DestRow, DestCol: integer;const Src: array of TMtx): Matrix; overload;

  (*<summary>Convert matrix from dense to banded storage format. </summary>
               
<remarks>Internally calls <see cref="Matrix.DenseToBanded"/>
</remarks>
*)
  
  function DenseToBanded(const X: TMtx; MaxElemCount: integer = 10000000): Matrix; overload; 

  (*<summary>Computes determinant of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Determinant"/>
</remarks>
*)
  
  function Determinant(const X: TMtx; MtxType: TMtxType = mtGeneral): double; overload; 

  (*<summary>Computes determinant of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Determinantc"/>
</remarks>
*)
  
  function Determinantc(const X: TMtx; MtxType: TMtxType = mtGeneral): TCplx; overload; 

  (*<summary>Computes the eigen-values of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Eig"/>
</remarks>
*)
  
  function Eig(const X: TMtx; MtxType: TMtxType = mtGeneral): Vector; overload; 

  (*<summary>Returns an "eye" matrix with ones on the diagonal and zeros elsewhere. </summary>
             
<remarks>Internally calls <see cref="Matrix.Eye"/>
</remarks>
*)
  
  function Eye(ARows,ACols: integer; const aFloatPrecision: TMtxFloatPrecision): Matrix; overload; 

  (*<summary>Flips the source matrix horizontally. </summary>
             
<remarks>Internally calls <see cref="Matrix.FlipHor"/>
</remarks>
*)
  
  function FlipHor(const SrcMtx: TMtx): Matrix; overload; 

  (*<summary>Flips the source matrix vertically. </summary>
             
<remarks>Internally calls <see cref="Matrix.FlipVer"/>
</remarks>
*)
  
  function FlipVer(const SrcMtx: TMtx): Matrix; overload; 

  (*<summary>Returns the matrix inverse A^-1. </summary>
             
<remarks>Internally calls <see cref="Matrix.Inv"/>
</remarks>
*)
  
  function MtxInv(const X: TMtx; MtxType: TMtxType = mtGeneral): Matrix; overload; 

  (*<summary>Returns the lower triangle of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.LowerTriangle"/>
</remarks>
*)
  
  function LowerTriangle(const Mtx: TMtx; ZeroUpper, Diagonal: boolean): Matrix; overload; 

  (*<summary>Returns the X from LQR solving A*X = B. </summary>
             
<remarks>Internally calls <see cref="Matrix.LQRSolve"/>
</remarks>
*)
  
  function LQRSolve(const B,A: TMtx; Op: TMtxOperation = opNone): Matrix; overload; 

  (*<summary>Returns the X from LQR solving A*X = B. </summary>
             
<remarks>Internally calls <see cref="Matrix.LQRSolve"/>
</remarks>
*)
  
  function LQRSolve(const B: TVec; const A: TMtx; Op: TMtxOperation = opNone): Vector; overload; 

  (*<summary>Returns the X from LU solving A*X = B. </summary>
             
<remarks>Internally calls <see cref="Matrix.LUSolve"/>
</remarks>
*)
  
  function LUSolve(const B, A: TMtx; MtxType: TMtxType = mtGeneral; Operation: TMtxOperation = opNone): Matrix; overload; 

  (*<summary>Returns the X from LU solving A*X = B. </summary>
             
<remarks>Internally calls <see cref="Matrix.LUSolve"/>
</remarks>
*)
  
  function LUSolve(const B: TVec; const A: TMtx; MtxType: TMtxType = mtGeneral; Operation: TMtxOperation = opNone): Vector; overload; 

  (*<summary>Returns the average of columns in the source matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.MeanCols"/>
</remarks>
*)
  
  function MeanCols(const X: TMtx): Vector; overload; 

  (*<summary>Returns the average of rows in the source matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.MeanRows"/>
</remarks>
*)
  
  function MeanRows(const X: TMtx): Vector; overload; 

  (*<summary>Computes matrix function of x^n where n is integer. </summary>
             
<remarks>Internally calls <see cref="Matrix.MtxIntPower"/>
</remarks>
*)
  
  function MtxIntPower(const Src: TMtx; Exponent: Integer): Matrix; overload; 

  (*<summary>Computes matrix function of x^r where r is a real number. </summary>
             
<remarks>Internally calls <see cref="Matrix.MtxPower"/>
</remarks>
*)
  
  function MtxPower(const Src: TMtx; Exponent: double; SourceType: TMtxType = mtGeneral): Matrix; overload; 

  (*<summary>Computes matrix function of x^c where c is a complex number. </summary>
             
<remarks>Internally calls <see cref="Matrix.MtxPower"/>
</remarks>
*)
  
  function MtxPower(const Src: TMtx; const Exponent: TCplx; SourceType: TMtxType = mtGeneral): Matrix; overload; 

  (*<summary>Computes matrix function of x^0.5. </summary>
             
<remarks>Internally calls <see cref="Matrix.MtxSqrt"/>
</remarks>
*)
  
  function MtxSqrt(const Src: TMtx; SourceType: TMtxType = mtGeneral): Matrix; overload; 

  (*<summary>Returns the matrix product of two matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.Mul"/> and does JIT-ed (faster) multiply for small square matrices.
</remarks>
*)
  
  function Mul(const Mtx1, Mtx2: TMtx): Matrix; overload; 
  (*<summary>Returns the matrix product of three matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.Mul"/> and does JIT-ed (faster) multiply for small square matrices.
</remarks>
*)
  
  function Mul(const Mtx1, Mtx2, Mtx3: TMtx): Matrix; overload;
  (*<summary>Returns the matrix product of four matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.Mul"/> and does JIT-ed (faster) multiply for small square matrices.
</remarks>
*)
  
  function Mul(const Mtx1, Mtx2, Mtx3, Mtx4: TMtx): Matrix; overload;
  (*<summary>Returns the matrix product of multiple matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.Mul"/> and does JIT-ed (faster) multiply for small square matrices.

             var a,b,c,d,e: Matrix;
             begin
                a := Mul([b,c,d,e]);
             end;
</remarks>
*)
  
  function Mul(const mtxArray: array of TMtx): Matrix; overload;

  (*<summary>Returns the matrix product of multiple matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.Mul"/> and will not use JIT-ed matrix multiply for small square matrices, if transpose is requested for the specified matrix.
             Both parameters need to be equal in length.

             var a,b,c,d,e: Matrix;
             begin
                a := Mul([b,c,d,e], [0,1,0,0]);  // transpose c before multiplying
             end;
</remarks>
*)
  
  function Mul(const mtxArray: array of TMtx; const transpArray: array of integer): Matrix; overload;

  (*<summary>Returns the matrix product of two matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.Mul"/>
             This operation is not JIT-ed.
</remarks>
*)
  
  function Mul(const Mtx1, Mtx2: TMtx; Operation1: TMtxOperation;  Operation2: TMtxOperation = opNone): Matrix; overload; 

  (*<summary>Returns the matrix product of two matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.Mul"/>
             This operation is not JIT-ed.
</remarks>
*)
  
  function Mul(const Mtx1, Mtx2: TMtx; Mtx1Type: TMtxType; Mtx2Type: TMtxType = mtGeneral; Operation1: TMtxOperation = opNone; Operation2: TMtxOperation = opNone): Matrix; overload; 

  (*<summary>Returns the 1-Norm of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Norm1"/>
</remarks>
*)
  
  function Norm1(const X: TMtx): double; overload; 

  (*<summary>Returns the Frobenius Norm of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.NormFro"/>
</remarks>
*)
  
  function NormFro(const X: TMtx): double; overload; 

  (*<summary>Returns the matrix Infinity Norm. </summary>
             
<remarks>Internally calls <see cref="Matrix.NormInf"/>
</remarks>
*)
  
  function NormInf(const X: TMtx): double; overload; 

  (*<summary>Returns the pascal matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Pascl"/>
</remarks>
*)
  
  function Pascl(Order: integer): Matrix; overload; 

  (*<summary>Returns the resized matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Resize"/>
</remarks>
*)
  
  function Resize(const Src: TMtx; NewRows, NewCols: integer): Matrix; overload; 

  (*<summary>Returns the resized and transposed matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.ResizeAndTranspose"/>
</remarks>
*)
  
  function ResizeAndTranspose(const Src: TMtx; NewRows, NewCols: integer): Matrix; overload; 

  (*<summary>Rotates the matrix by 90 degree. </summary>
             
<remarks>Internally calls <see cref="Matrix.Rotate90"/>
</remarks>
*)
  
  function Rotate90(const Mtx: TMtx): Matrix; overload; 

  (*<summary>Sorts all rows in the matrix descendingly </summary>
             
<remarks>Internally calls <see cref="Matrix.SortDescend"/>
</remarks>
*)
  
  function SortDescend(const X: TMtx): Matrix; overload; 

  (*<summary>Performs row based sort in descending order.  </summary>
             
<remarks>Internally calls <see cref="Matrix.SortDescend"/>
</remarks>
*)
  
  function SortDescend(const X: TMtx; Col: integer): Matrix; overload; 

  (*<summary>Converts strings to values. </summary>
             
<remarks>Internally calls <see cref="Matrix.StringsToValues"/>
</remarks>
*)
  
  function StringsToValues(const aList: TStrings; const Delimiter: string = kTab): Matrix; overload; 

  (*<summary>Converts strings to values. </summary>
             
<remarks>Internally calls <see cref="Matrix.StringsToValues"/>
</remarks>
*)
  
  function StringsToValues(const aList: TStrings; ListIndex,ListLen, Row,Col: Integer; Delimiter: string = kTab): Matrix; overload; 

  (*<summary>Returns singular values. </summary>
             
<remarks>Internally calls <see cref="Matrix.SVD"/>
</remarks>
*)
  
  function SVD(const X: TMtx): Vector; overload; 

  (*<summary>Returns the sum of matrix columns. </summary>
             
<remarks>Internally calls <see cref="Matrix.SumCols"/>
</remarks>
*)
  
  function SumCols(const X: TMtx): Vector; overload; 

  (*<summary>Returns the sum of matrix rows. </summary>
             
<remarks>Internally calls <see cref="Matrix.SumRows"/>
</remarks>
*)
  
  function SumRows(const X: TMtx): Vector; overload; 

  (*<summary>Returns the Toeplitz matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Toeplitz"/>
</remarks>
*)
  
  function Toeplitz(const FirstRow,FirstCol: TVec): Matrix; overload; 

  (*<summary>Returns the Trace of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.Trace"/>
</remarks>
*)
  
  function Trace(const X: TMtx): TCplx; overload; 

  (*<summary>Returns the upper triangle of the matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.UpperTriangle"/>
</remarks>
*)
  
  function UpperTriangle(const Mtx: TMtx; ZeroLower, Diagonal: boolean): Matrix; overload; 

  (*<summary>Constructs VanDerMonde matrix. </summary>
             
<remarks>Internally calls <see cref="Matrix.VanderMonde"/>
</remarks>
*)
  
  function VanderMonde(ACols: Integer; const Vec: TVec): Matrix; overload; 

  (*<summary>Multiply two matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.MulDiagLeft"/>
</remarks>
*)
  
  function MulDiag(const DiagMtx: TVec; const Mtx: TMtx): Matrix; overload;  

  (*<summary>Multiply two matrices. </summary>
             
<remarks>Internally calls <see cref="Matrix.MulDiagRight"/>
</remarks>
*)
  
  function MulDiag(const Mtx: TMtx; const DiagMtx: TVec): Matrix; overload;  

  (*<summary>Compute maximum of each row.</summary>
             
<remarks>Compute maximum of each row and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
  
  function MaxRows(const Src: TMtx): Vector;
  (*<summary>Compute minimum of each row.</summary>
             
<remarks>Compute minimum of each row and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
  
  function MinRows(const Src: TMtx): Vector;
  (*<summary>Compute maximum of each column.</summary>
             
<remarks>Compute maximum of each column and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
  
  function MaxCols(const Src: TMtx): Vector;
  (*<summary>Compute minimum of each column.</summary>
             
<remarks>Compute minimum of each column and store the result in to Dst vector. The Dst is sized automatically.
</remarks>
*)
  
  function MinCols(const Src: TMtx): Vector;


    (*<summary> Compute X*xScale + Y*yScale </summary>

       
<remarks>Computes the specified expression without temporary objects and at the same speed as computing only X + Y.
</remarks>


       

       <example>
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double xScale = 1.5;
           double yScale = -1.5;

           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };

           Vector A1 = X * xScale + Y * yScale;
           Vector A2 = AddScaled(X, xScale, Y, yScale);
           Vector A3 = new Vector();
           A3.AddScaled(X, xScale, Y, yScale);

           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function AddScaled(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): Vector; overload;
    (*<summary> Compute X*xScale + Y*yScale, when X is a Matrix </summary>
                 
<remarks>The operation does only per-element math.
</remarks>
*)
    
    function AddScaled(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double): Matrix; overload;



    (*<summary> Compute sqr(X*xScale + Y*yScale) </summary>

       
<remarks>Computes the square of the expression X*xScale + Y*yScale without temporary objects.
</remarks>


       

       <example>
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double xScale = 1.5, yScale = -1.5;
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector A1 = MtxExpr.Sqr(X * xScale + Y * yScale);
           Vector A2 = AddScaledSqr(X, xScale, Y, yScale);
           Vector A3 = new Vector();
           A3.AddScaledSqr(X, xScale, Y, yScale);

           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function AddScaledSqr(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): Vector; overload;

    (*<summary> Compute sqr(X*xScale + Y*yScale), when X is a Matrix </summary>
                 
<remarks>The operation does only per-element math.
</remarks>
*)
    
    function AddScaledSqr(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double): Matrix; overload;

    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale </summary>

       
<remarks>Computes the weighted sum of the squares of X and Y without temporary objects.
</remarks>


       

       <example>
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double xScale = 2.0, yScale = 3.0;
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector A1 = MtxExpr.Sqr(X) * xScale + MtxExpr.Sqr(Y) * yScale;
           Vector A2 = SqrAddScaled(X, xScale, Y, yScale);
           Vector A3 = new Vector();
           A3.SqrAddScaled(X, xScale, Y, yScale);

           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function SqrAddScaled(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double): Vector; overload;

    (*<summary> Compute sqr(X)*xScale + sqr(Y)*yScale, when X is a matrix </summary>
                 
<remarks>The operation does only per-element math.
</remarks>
*)
    
    function SqrAddScaled(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double): Matrix; overload;


    (*<summary> Compute sqr(X + Y*yScale) </summary>

       
<remarks>Computes the square of (X + Y*yScale) without temporary objects.
</remarks>


       

       <example>
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double yScale = 1.5;
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector A1 = MtxExpr.Sqr(X + Y * yScale);
           Vector A2 = AddScaledSqr(X, Y, yScale);
           Vector A3 = new Vector();
           A3.AddScaledSqr(X, Y, yScale);

           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function AddScaledSqr(const X: TVec; const Y: TMtxVec; const yScale: Double): Vector; overload;

    (*<summary> Compute sqr(X + Y*yScale) when X is a matrix </summary>
                 
<remarks>The operation does only per-element math.
</remarks>
*)
    
    function AddScaledSqr(const X: TMtx; const Y: TMtxVec; const yScale: Double): Matrix; overload;


    (*<summary> Compute sqr(X) + sqr(Y)*yScale </summary>

       
<remarks>Computes the sum of the square of X and the scaled square of Y without temporary objects.
</remarks>


       

       <example>
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double yScale = 2.0;
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector A1 = MtxExpr.Sqr(X) + MtxExpr.Sqr(Y) * yScale;
           Vector A2 = SqrAddScaled(X, Y, yScale);
           Vector A3 = new Vector();
           A3.SqrAddScaled(X, Y, yScale);

           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function SqrAddScaled(const X: TVec; const Y: TMtxVec; const yScale: Double): Vector; overload;

    (*<summary> Compute sqr(X) + sqr(Y)*yScale, when X is a Matrix. </summary>
                 
<remarks>The operation does only per-element math.
</remarks>
*)
    
    function SqrAddScaled(const X: TMtx; const Y: TMtxVec; const yScale: Double): Matrix; overload;

    (*<summary> Compute X*xScale + Y*yScale + Z*zScale </summary>

       
<remarks>Computes the weighted sum of X, Y, and Z without temporary objects.
</remarks>


       

       <example>
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double xScale = 1.0, yScale = 2.0, zScale = 3.0;
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
           Vector A1 = X * xScale + Y * yScale + Z * zScale;
           Vector A2 = AddScaled(X, xScale, Y, yScale, Z, zScale);
           Vector A3 = new Vector();
           A3.AddScaled(X, xScale, Y, yScale, Z, zScale);
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function AddScaled(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double;   const Z: TMtxVec; const zScale: Double): Vector; overload;

    (*<summary> Compute X*xScale + Y*yScale + Z*zScale </summary>*)
    
    function AddScaled(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double;   const Z: TMtxVec; const zScale: Double): Matrix; overload;


    (*<summary> Compute X*xScale + Y*yScale + zScalar </summary>

       
<remarks>Computes X*xScale + Y*yScale plus a scalar zScalar without temporary objects.
</remarks>


       

       <example>
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double xScale = 1.0, yScale = 2.0, zScalar = 3.0;
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector A1 = X * xScale + Y * yScale + zScalar;
           Vector A2 = AddScaledC(X, xScale, Y, yScale, zScalar);
           Vector A3 = new Vector();
           A3.AddScaledC(X, xScale, Y, yScale, zScalar);
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function AddScaledC(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): Vector; overload;

    (*<summary> Compute X*xScale + Y*yScale + zScalar, when X is a Matrix </summary>*)
    
    function AddScaledC(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): Matrix; overload;

    (*<summary> Compute X*xScale - Y*yScale - Z*zScale </summary>

       
<remarks>Computes the expression X*xScale  Y*yScale  Z*zScale without temporary objects,
       achieving the same speed as an optimized inplace operation.
</remarks>


       

       <example>:
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double xScale = 1.0, yScale = 2.0, zScale = 3.0;
           Vector X = (Vector) new double[] { 5, 6, 7, 8 };
           Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Z = (Vector) new double[] { 1, 1, 1, 1 };
           Vector A1 = X * xScale - Y * yScale - Z * zScale;
           Vector A2 = SubScaled(X, xScale, Y, yScale, Z, zScale);
           Vector A3 = new Vector();
           A3.SubScaled(X, xScale, Y, yScale, Z, zScale);
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function SubScaled(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double;  const Z: TMtxVec; const zScale: Double): Vector; overload;

    (*<summary> Compute X*xScale - Y*yScale - Z*zScale, when X is a Matrix. </summary>*)
    
    function SubScaled(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

    (*<summary> Compute X*xScale - Y*yScale - zScalar </summary>

       
<remarks>Computes the expression X*xScale  Y*yScale  zScalar without temporary objects.
</remarks>


       

       <example>:
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double xScale = 1.0, yScale = 2.0, zScalar = 3.0;
           Vector X = (Vector) new double[] { 5, 6, 7, 8 };
           Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
           Vector A1 = X * xScale - Y * yScale - zScalar;
           Vector A2 = SubScaledC(X, xScale, Y, yScale, zScalar);
           Vector A3 = new Vector();
           A3.SubScaledC(X, xScale, Y, yScale, zScalar);
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function SubScaledC(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double;   const Z: Double): Vector; overload;

    (*<summary> Compute X*xScale - Y*yScale - zScalar, when X is a Matrix </summary>*)
    
    function SubScaledC(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double;  const Z: Double): Matrix; overload;

    (*<summary> Compute X*Y*Z </summary>

       
<remarks>Computes the product X*Y*Z without temporary objects.
</remarks>


       

       <example>:
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
           Vector A1 = X * Y * Z;
           Vector A2 = MulElem(X, Y, Z);
           Vector A3 = new Vector();
           A3.Mul(X, Y, Z);
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function MulElem(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

    (*<summary> Compute X*Y*Z, when X is a Matrix </summary>*)
    
    function MulElem(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

    (*<summary> Compute X*Y*zScalar </summary>

       
<remarks>Computes the product of X and Y multiplied by the scalar zScalar without temporary objects.
</remarks>


       

       <example>:
       <code>
       using Dew.Math;
       using Dew.Math.Units;
       namespace Dew.Examples
       {
         void Example()
         {
           double zScalar = 2.0;
           Vector X = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
           Vector A1 = (X * Y) * zScalar;
           Vector A2 = MulElem(X, Y, zScalar);
           Vector A3 = new Vector();
           A3.Mul(X, Y, zScalar);
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function MulElem(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

    (*<summary> Compute X*Y*zScalar, when X is a Matrix </summary>
                 
<remarks>The operation does only per-element math.
</remarks>
*)
    
    function MulElem(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  (*<summary> Compute X / (Y*Z) </summary>

     
<remarks>Divides X by the product of Y and Z without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         Vector X = (Vector) new double[] { 6, 8, 10, 12 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 2, 2, 2, 2 };
         Vector A1 = X / (Y * Z);
         Vector A2 = DivideElem(X, Y, Z);
         Vector A3 = new Vector();
         A3.Divide(X, Y, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function DivideElem(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  (*<summary> Compute X / (Y*Z), when X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivideElem(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

  (*<summary> Compute X / (Y*zScale) </summary>

     
<remarks>Divides X by (Y multiplied by the scalar zScale) without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScale = 2.0;
         Vector X = (Vector) new double[] { 10, 20, 30, 40 };
         Vector Y = (Vector) new double[] { 2, 4, 6, 8 };
         Vector A1 = X / (Y * zScale);
         Vector A2 = DivideElemC(X, Y, zScale);
         Vector A3 = new Vector();
         A3.DivideC(X, Y, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function DivideElemC(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  (*<summary> Compute X / (Y*zScale), when X is a Matrix. </summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivideElemC(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  (*<summary> Compute X * Y * xyScale / Z </summary>

     
<remarks>Computes the product of X and Y scaled by xyScale, then divided by Z, without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xyScale = 1.5;
         Vector X = (Vector) new double[] { 2, 4, 6, 8 };
         Vector Y = (Vector) new double[] { 1, 1, 1, 1 };
         Vector Z = (Vector) new double[] { 2, 2, 2, 2 };
         Vector A1 = (X * Y * xyScale) / Z;
         Vector A2 = MulAndDiv(X, Y, xyScale, Z);
         Vector A3 = new Vector();
         A3.MulAndDiv(X, Y, xyScale, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function MulAndDiv(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec): Vector; overload;

  (*<summary> Compute X * Y * xyScale / Z, when X is a Matrix. </summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndDiv(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec): Matrix; overload;

  (*<summary> Compute X * Y / zScalar </summary>

     
<remarks>Computes the product of X and Y divided by the scalar zScalar without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScalar = 2.0;
         Vector X = (Vector) new double[] { 3, 6, 9, 12 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector A1 = (X * Y) / zScalar;
         Vector A2 = MulAndDiv(X, Y, zScalar);
         Vector A3 = new Vector();
         A3.MulAndDiv(X, Y, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function MulAndDiv(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  (*<summary> Compute X * Y / zScalar, when X is a Matrix. </summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndDiv(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  (*<summary> Compute xScalar / (Y*Z) </summary>

     
<remarks>Divides a scalar xScalar by the product of Y and Z without temporary objects.
     Since the first parameter is scalar, the overload is provided by splitting the second parameter
     into TVec and TMtx versions.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScalar = 100;
         Vector Y = (Vector) new double[] { 2, 4, 5, 10 };
         Vector Z = (Vector) new double[] { 1, 2, 2, 2 };
         Vector A1 = xScalar / (Y * Z);
         Vector A2 = DivideElem(xScalar, Y, Z);
         Vector A3 = new Vector();
         A3.Divide(xScalar, Y, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function DivideElem(const X: Double; const Y: TVec; const Z: TMtxVec): Vector; overload;

  (*<summary> Compute xScalar / (Y*Z), when Y is a Matrix </summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivideElem(const X: Double; const Y: TMtx; const Z: TMtxVec): Matrix; overload;

  (*<summary> Compute (X*xScale + Y*yScale)*Z*zScale</summary>

     
<remarks>Computes the expression (X*xScale + Y*yScale) multiplied by Z*zScale
     without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScale = 2.0, zScale = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X * xScale + Y * yScale) * Z * zScale;
         Vector A2 = AddAndMul(X, xScale, Y, yScale, Z, zScale);
         Vector A3 = new Vector();
         A3.AddAndMul(X, xScale, Y, yScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute (X*xScale + Y*yScale)*Z*zScale, when X is a Matrix. </summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute (X*xScale + yScalar)*Z*zScale</summary>

     
<remarks>Computes the expression where X is scaled by xScale, then added to a scalar yScalar,
     and the result is multiplied element-wise by Z and finally scaled by zScale.
     This operation is performed without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScalar = 2.0, zScale = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X * xScale + yScalar) * Z * zScale;
         Vector A2 = AddAndMul(X, xScale, yScalar, Z, zScale);
         Vector A3 = new Vector();
         A3.AddAndMul(X, xScale, yScalar, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const xScale: Double; Y: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute (X*xScale + yScalar)*Z*zScale, when X is a Matrix. </summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const xScale: Double; Y: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;


  (*<summary> Compute (X*xScale + Y*yScale)*zScalar</summary>

     
<remarks>Computes the expression (X*xScale + Y*yScale) multiplied by a scalar zScalar
     without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScale = 2.0, zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector A1 = (X * xScale + Y * yScale) * zScalar;
         Vector A2 = AddAndMul(X, xScale, Y, yScale, zScalar);
         Vector A3 = new Vector();
         A3.AddAndMul(X, xScale, Y, yScale, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): Vector; overload;

  (*<summary> Compute (X*xScale + Y*yScale)*zScalar, when X is a Matrix. </summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): Matrix; overload;

  (*<summary> Compute (X*xScale + yScalar)*zScalar</summary>

     
<remarks>Computes the result of multiplying X by xScale, adding a scalar yScalar, and then multiplying
     the entire result by a scalar zScalar, all without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScalar = 2.0, zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector A1 = (X * xScale + yScalar) * zScalar;
         Vector A2 = AddAndMul(X, xScale, yScalar, zScalar);
         Vector A3 = new Vector();
         A3.AddAndMul(X, xScale, yScalar, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const xScale: Double; Y, Z: Double): Vector; overload;

  (*<summary> Compute (X*xScale + yScalar)*zScalar, when X is a Matrix.</summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const xScale: Double; Y, Z: Double): Matrix; overload;

  (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale</summary>

     
<remarks>Computes the product of (X scaled by xScale minus Y scaled by yScale) multiplied by Z scaled by zScale,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScale = 2.0, zScale = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X * xScale - Y * yScale) * Z * zScale;
         Vector A2 = SubAndMul(X, xScale, Y, yScale, Z, zScale);
         Vector A3 = new Vector();
         A3.SubAndMul(X, xScale, Y, yScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubAndMul(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double;  const Z: TMtxVec; const zScale: Double): Vector; overload;
  (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale.</summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale, when X is a Matrix.</summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double;  const Z: TMtxVec; const zScale: Double): Matrix; overload;
  (*<summary> Compute (X*xScale - Y*yScale)*Z*zScale, when X is a Matrix.</summary>
                  
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx;  const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  (*<summary> Compute (X*xScale - Y*yScale)*zScale </summary>*)
  
  function SubAndMul(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Vector; overload;

  (*<summary> Compute (X*xScale - Y*yScale)*zScale </summary>*)
  
  function SubAndMul(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx;  const Z: TCplx): Matrix; overload;



  (*<summary> Compute (X*xScale - Y*yScale)*zScalar</summary>

     
<remarks>Computes the product of (X scaled by xScale minus Y scaled by yScale) multiplied by a scalar zScalar,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScale = 2.0, zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector A1 = (X * xScale - Y * yScale) * zScalar;
         Vector A2 = SubAndMul(X, xScale, Y, yScale, zScalar);
         Vector A3 = new Vector();
         A3.SubAndMul(X, xScale, Y, yScale, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubAndMul(const X: TVec; const xScale: Double; const Y: TMtxVec; const yScale: Double;  Z: Double): Vector; overload;

  (*<summary> Compute (X*xScale - Y*yScale)*zScalar, when X is a Matrix.</summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TMtx; const xScale: Double; const Y: TMtxVec; const yScale: Double; const Z: Double): Matrix; overload;


   (*<summary> Compute (X*xScale - yScalar)*Z*zScale</summary>

     
<remarks>Computes the expression (X*xScale - yScalar) multiplied by Z*zScale without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScalar = 2.0, zScale = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X * xScale - yScalar) * Z * zScale;
         Vector A2 = SubAndMul(X, xScale, yScalar, Z, zScale);
         Vector A3 = new Vector();
         A3.SubAndMul(X, xScale, yScalar, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubAndMul(const X: TVec; const xScale: Double; Y: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

   (*<summary> Compute (X*xScale - yScalar)*Z*zScale, where X is a Matrix. </summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TMtx; const xScale: Double; Y: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

   (*<summary> Compute (X*xScale - yScalar)*Z*zScale, where X is a Matrix. </summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TVec; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

   (*<summary> Compute (X*xScale - yScalar)*Z*zScale, where X is a Matrix. </summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TMtx; const xScale: TCplx; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;


   (*<summary> Compute (X*xScale - yScalar)*zScalar</summary>

     
<remarks>Computes the expression (X*xScale - yScalar) multiplied by a scalar zScalar without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScalar = 2.0, zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector A1 = (X * xScale - yScalar) * zScalar;
         Vector A2 = SubAndMul(X, xScale, yScalar, zScalar);
         Vector A3 = new Vector();
         A3.SubAndMul(X, xScale, yScalar, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubAndMul(const X: TVec; const xScale: Double; Y, Z: Double): Vector; overload;

   (*<summary> Compute (X*xScale - yScalar)*zScalar, where X is a Matrix.</summary>*)
  
  function SubAndMul(const X: TMtx; const xScale: Double; Y, Z: Double): Matrix; overload;

  (*<summary> Compute (X*Y)*xyScale + Z*zScale</summary>

     
<remarks>Computes the product of X and Y scaled by xyScale, and then adds Z scaled by zScale,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xyScale = 1.5, zScale = 2.0;
         Vector X = (Vector) new double[] { 2, 4, 6, 8 };
         Vector Y = (Vector) new double[] { 1, 1, 1, 1 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X * Y * xyScale) + (Z * zScale);
         Vector A2 = MulAndAdd(X, xyScale, Y, xyScale, Z, zScale);
         Vector A3 = new Vector();
         A3.MulAndAdd(X, xyScale, Y, xyScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function MulAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute (X*Y)*xyScale + Z*zScale, where X is a Matrix. </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute (X*Y)*xyScale + Z*zScale. </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: TCplx;  const Z: TMtxVec; const zScale: TCplx): Vector; overload;
  (*<summary> Compute (X*Y)*xyScale + Z*zScale, where X is a Matrix. </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix;  overload;


   (*<summary> Compute (X*Y)*xyScale + zScalar</summary>

     
<remarks>Computes the product of X and Y scaled by xyScale, then adds a scalar zScalar,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xyScale = 1.5, zScalar = 2.0;
         Vector X = (Vector) new double[] { 2, 4, 6, 8 };
         Vector Y = (Vector) new double[] { 1, 1, 1, 1 };
         Vector A1 = (X * Y * xyScale) + zScalar;
         Vector A2 = MulAndAdd(X, xyScale, Y, xyScale, zScalar);
         Vector A3 = new Vector();
         A3.MulAndAdd(X, xyScale, Y, xyScale, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function MulAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): Vector; overload;

   (*<summary> Compute (X*Y)*xyScale + zScalar, where X is a Matrix.</summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: Double): Matrix; overload;

   (*<summary> Compute (X*Y)*xyScale + zScalar</summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): Vector;  overload;

   (*<summary> Compute (X*Y)*xyScale + zScalar, where X is a Matrix.</summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): Matrix;  overload;

   (*<summary> Compute (X*yScalar) + zScalar</summary>

     
<remarks>Computes the result of multiplying X by a scalar yScalar and then adding a scalar zScalar,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScalar = 2.0, zScalar = 3.0;
         Vector X = (Vector) new double[] { 2, 4, 6, 8 };
         Vector A1 = (X * yScalar) + zScalar;
         Vector A2 = MulAndAdd(X, yScalar, zScalar);
         Vector A3 = new Vector();
         A3.MulAndAdd(X, yScalar, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function MulAndAdd(const X: TVec; const Y, Z: Double): Vector; overload;

   (*<summary> Compute (X*yScalar) + zScalar, where X is a Matrix.</summary>*)
  
  function MulAndAdd(const X: TMtx; const Y, Z: Double): Matrix; overload;

   (*<summary> Compute (X*yScalar) + zScalar, where X is a Matrix.</summary>*)
  
  function MulAndAdd(const X: TVec; const Y, Z: TCplx): Vector; overload;

   (*<summary> Compute (X*yScalar) + zScalar, where X is a Matrix.</summary>*)
  
  function MulAndAdd(const X: TMtx; const Y, Z: TCplx): Matrix; overload;

  (*<summary> Compute X*yScalar - Z*zScale</summary>

     
<remarks>Computes the result of multiplying X by a scalar yScalar and then subtracting Z multiplied by zScale,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScalar = 2.0, zScale = 3.0;
         Vector X = (Vector) new double[] { 3, 6, 9, 12 };
         Vector Z = (Vector) new double[] { 1, 1, 1, 1 };
         Vector A1 = (X * yScalar) - (Z * zScale);
         Vector A2 = MulAndSub(X, yScalar, Z, zScale);
         Vector A3 = new Vector();
         A3.MulAndSub(X, yScalar, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function MulAndSub(const X: TVec; const Y: double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute X*yScalar - Z*zScale, where X is a Matrix</summary>*)
  
  function MulAndSub(const X: TMtx; const Y: double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute X*yScalar - Z*zScale</summary>*)
  
  function MulAndSub(const X: TVec; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  (*<summary> Compute X*yScalar - Z*zScale, where X is a Matrix</summary>*)
  
  function MulAndSub(const X: TMtx; const Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix;  overload;

  (*<summary> Compute (X / Y)*xyScale + Z*zScale</summary>

     
<remarks>Computes the expression (X divided by Y) multiplied by xyScale plus Z multiplied by zScale,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xyScale = 1.5, zScale = 2.0;
         Vector X = (Vector) new double[] { 8, 10, 12, 14 };
         Vector Y = (Vector) new double[] { 2, 2, 2, 2 };
         Vector Z = (Vector) new double[] { 1, 1, 1, 1 };
         Vector A1 = (X / Y) * xyScale + Z * zScale;
         Vector A2 = DivAndAdd(X, xyScale, Y, xyScale, Z, zScale);
         Vector A3 = new Vector();
         A3.DivAndAdd(X, xyScale, Y, xyScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute (X / Y)*xyScale + Z*zScale, where X is a Matrix.</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute (X / Y)*xyScale + Z*zScale.</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: TCplx;  const Z: TMtxVec; const zScale: TCplx): Vector; overload;
  (*<summary> Compute (X / Y)*xyScale + Z*zScale, where X is a Matrix.</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;


  (*<summary> Compute (X / Y)*xyScale + zScalar</summary>

     
<remarks>Computes the expression (X divided by Y) multiplied by xyScale plus a scalar zScalar,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xyScale = 1.5, zScalar = 2.0;
         Vector X = (Vector) new double[] { 8, 10, 12, 14 };
         Vector Y = (Vector) new double[] { 2, 2, 2, 2 };
         Vector A1 = (X / Y) * xyScale + zScalar;
         Vector A2 = DivAndAdd(X, xyScale, Y, xyScale, zScalar);
         Vector A3 = new Vector();
         A3.DivAndAdd(X, xyScale, Y, xyScale, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): Vector; overload;

  (*<summary> Compute (X / Y)*xyScale + zScalar, where X is a Matrix</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: Double): Matrix; overload;

  (*<summary> Compute (X / Y)*xyScale + zScalar</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): Vector; overload;

  (*<summary> Compute (X / Y)*xyScale + zScalar, where X is a Matrix</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): Matrix; overload;

   (*<summary> Compute (X / Y) * xyScale - Z*zScale</summary>

     
<remarks>Divides X by Y, scales the quotient by xyScale, then subtracts Z scaled by zScale,
     all without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xyScale = 1.5, zScale = 2.0;
         Vector X = (Vector) new double[] { 8, 10, 12, 14 };
         Vector Y = (Vector) new double[] { 2, 2, 2, 2 };
         Vector Z = (Vector) new double[] { 1, 1, 1, 1 };
         Vector A1 = (X / Y) * xyScale - Z * zScale;
         Vector A2 = DivAndSub(X, xyScale, Y, xyScale, Z, zScale);
         Vector A3 = new Vector();
         A3.DivAndSub(X, xyScale, Y, xyScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

   (*<summary> Compute (X / Y) * xyScale - Z*zScale, where X is a Matrix </summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

   (*<summary> Compute (X / Y) * xyScale - Z*zScale</summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

   (*<summary> Compute (X / Y) * xyScale - Z*zScale, where X is a Matrix </summary>
                
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix;  overload;

  (*<summary> Compute (X / Y) * xyScale - zScalar</summary>

     
<remarks>Computes the expression (X divided by Y) multiplied by xyScale and then subtracts
     the scalar zScalar, all without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xyScale = 1.5, zScalar = 2.0;
         Vector X = (Vector) new double[] { 8, 10, 12, 14 };
         Vector Y = (Vector) new double[] { 2, 2, 2, 2 };
         Vector A1 = (X / Y) * xyScale - zScalar;
         Vector A2 = DivAndSub(X, xyScale, Y, xyScale, zScalar);
         Vector A3 = new Vector();
         A3.DivAndSub(X, xyScale, Y, xyScale, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: Double): Vector; overload;

  (*<summary> Compute (X / Y) * xyScale - zScalar, where X is a Matrix</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: Double): Matrix; overload;

  (*<summary> Compute (X / Y) * xyScale - zScalar</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TCplx): Vector;  overload;

  (*<summary> Compute (X / Y) * xyScale - zScalar, where X is a Matrix</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx;  const Z: TCplx): Matrix;  overload;

    (*<summary> Compute X + Y*yScale </summary>

     
<remarks>Computes the sum of two vector-based operands, X and Y, where Y is first scaled by yScale.
     This operation is performed without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScale = 1.5;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector A1 = X + Y * yScale;
         Vector A2 = AddScaled(X, Y, yScale);
         Vector A3 = new Vector();
         A3.AddScaled(X, Y, yScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddScaled(const X: TVec; const Y: TMtxVec; const yScale: Double): Vector; overload;

  (*<summary> Compute X + Y*yScale, where X is a Matrix. </summary>*)
  
  function AddScaled(const X: TMtx; const Y: TMtxVec; const yScale: Double): Matrix; overload;

  (*<summary> Compute X + Y*yScale </summary>*)
  
  function AddScaled(const X: TVec; const Y: TMtxVec; const yScale: TCplx): Vector; overload;

  (*<summary> Compute X + Y*yScale, where X is a Matrix. </summary>*)
  
  function AddScaled(const X: TMtx; const Y: TMtxVec; const yScale: TCplx): Matrix; overload;

  (*<summary> Compute X + Y + Z </summary>

     
<remarks>Computes the sum of three vector-based operands, X, Y, and Z, without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = X + Y + Z;
         Vector A2 = Add(X, Y, Z);
         Vector A3 = new Vector();
         A3.Add(X, Y, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function Add(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  (*<summary> Compute X + Y + Z, where X is a Matrix. </summary>*)
  
  function Add(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

  (*<summary> Compute X + Y + Z*zScale </summary>

     
<remarks>Computes the sum of X and Y plus Z scaled by zScale without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScale = 2.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = X + Y + Z * zScale;
         Vector A2 = AddScaled(X, Y, Z, zScale);
         Vector A3 = new Vector();
         A3.AddScaled(X, Y, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddScaled(const X: TVec; const Y, Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute X + Y + Z*zScale, where X is a Matrix. </summary>*)
  
  function AddScaled(const X: TMtx; const Y, Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute X + Y + Z*zScale </summary>*)
  
  function AddScaled(const X: TVec; const Y, Z: TMtxVec; const zScale: TCplx): Vector; overload;

  (*<summary> Compute X + Y + Z*zScale, where X is a Matrix. </summary>*)
  
  function AddScaled(const X: TMtx; const Y, Z: TMtxVec; const zScale: TCplx): Matrix; overload;


  (*<summary> Compute X + Y*yScale + Z*zScale </summary>

     
<remarks>Computes the sum of X and Y scaled by yScale plus Z scaled by zScale without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScale = 1.5, zScale = 2.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = X + Y * yScale + Z * zScale;
         Vector A2 = AddScaled(X, Y, yScale, Z, zScale);
         Vector A3 = new Vector();
         A3.AddScaled(X, Y, yScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddScaled(const X: TVec; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute X + Y*yScale + Z*zScale, where X is a Matrix. </summary>*)
  
  function AddScaled(const X: TMtx; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute X + Y*yScale + Z*zScale</summary>*)
  
  function AddScaled(const X: TVec; const Y: TMtxVec; const yScale: TCplx;  const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  (*<summary> Compute X + Y*yScale + Z*zScale, where X is a Matrix. </summary>*)
  
  function AddScaled(const X: TMtx; const Y: TMtxVec; const yScale: TCplx;  const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  (*<summary> Compute X + Y + zScalar </summary>

     
<remarks>Computes the sum of X and Y with an added scalar zScalar without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector A1 = X + Y + zScalar;
         Vector A2 = Add(X, Y, zScalar);
         Vector A3 = new Vector();
         A3.Add(X, Y, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function Add(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  (*<summary> Compute X + Y + zScalar, where X is a Matrix. </summary>*)
  
  function Add(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  (*<summary> Compute X + Y + zScalar </summary>*)
  
  function Add(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  (*<summary> Compute X + Y + zScalar, where X is a Matrix. </summary>*)
  
  function Add(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  (*<summary> Compute X + Y*yScale + zScalar </summary>

     
<remarks>Computes the sum of X and Y scaled by yScale, with an added scalar zScalar,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScale = 1.5, zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector A1 = X + Y * yScale + zScalar;
         Vector A2 = AddScaledC(X, Y, yScale, zScalar);
         Vector A3 = new Vector();
         A3.AddScaledC(X, Y, yScale, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddScaledC(const X: TVec; const Y: TMtxVec; const yScale: Double; const Z: Double): Vector; overload;

  (*<summary> Compute X + Y*yScale + zScalar, where X is a Matrix. </summary>*)
  
  function AddScaledC(const X: TMtx; const Y: TMtxVec; const yScale: Double; const Z: Double): Matrix; overload;

  (*<summary> Compute X + Y*yScale + zScalar</summary>*)
  
  function AddScaledC(const X: TVec; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Vector; overload;
  (*<summary> Compute X + Y*yScale + zScalar, where X is a Matrix. </summary>*)
  
  function AddScaledC(const X: TMtx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Matrix; overload;


  (*<summary> Compute X - Y - Z </summary>

     
<remarks>Computes the difference of three vector-based operands (X, Y, and Z) without
     creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         Vector X = (Vector) new double[] { 5, 6, 7, 8 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 1, 1, 1, 1 };
         Vector A1 = X - Y - Z;
         Vector A2 = Sub(X, Y, Z);
         Vector A3 = new Vector();
         A3.Sub(X, Y, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function Sub(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  (*<summary> Compute X - Y - Z, where X is a Matrix </summary>*)
  
  function Sub(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;


    (*<summary> Compute X - Y*yScale - Z*zScale </summary>

       
<remarks>Computes the difference between X and Y scaled by yScale, then subtracts Z scaled by zScale,
       without creating temporary objects.
</remarks>


       

       <example>:
       <code>
       using Dew.Math;
       using Dew.Math.Units;

       namespace Dew.Examples
       {
         void Example()
         {
           double yScale = 1.5, zScale = 2.0;
           Vector X = (Vector) new double[] { 5, 6, 7, 8 };
           Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Z = (Vector) new double[] { 1, 1, 1, 1 };
           Vector A1 = X - Y * yScale - Z * zScale;
           Vector A2 = SubScaled(X, Y, yScale, Z, zScale);
           Vector A3 = new Vector();
           A3.SubScaled(X, Y, yScale, Z, zScale);
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)
    
    function SubScaled(const X: TVec; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

    (*<summary> Compute X - Y*yScale - Z*zScale, where X is a Matrix. </summary>*)
    
    function SubScaled(const X: TMtx; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

    (*<summary> Compute X - Y*yScale - Z*zScale </summary>*)
    
    function SubScaled(const X: TVec; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;
    (*<summary> Compute X - Y*yScale - Z*zScale, where X is a Matrix. </summary>*)
    
    function SubScaled(const X: TMtx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

    (*<summary> Compute X - Y - Z*zScale </summary>

       
<remarks>Computes the difference between X and Y, then subtracts Z scaled by zScale,
       without creating temporary objects.
</remarks>


       

       <example>:
       <code>
       using Dew.Math;
       using Dew.Math.Units;

       namespace Dew.Examples
       {
         void Example()
         {
           double zScale = 2.0;
           Vector X = (Vector) new double[] { 5, 6, 7, 8 };
           Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
           Vector Z = (Vector) new double[] { 1, 1, 1, 1 };
           Vector A1 = X - Y - Z * zScale;
           Vector A2 = SubScaled(X, Y, Z, zScale);
           Vector A3 = new Vector();
           A3.Sub(X, Y, Z * zScale); // Or via a dedicated overload if available.
           if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
           if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
         }
       }
       </code></example>*)

    
    function SubScaled(const X: TVec; const Y, Z: TMtxVec; const zScale: Double): Vector; overload;

    (*<summary> Compute X - Y - Z*zScale, where X is a Matrix. </summary>*)
    
    function SubScaled(const X: TMtx; const Y, Z: TMtxVec; const zScale: Double): Matrix; overload;


    (*<summary> Compute X - Y - Z*zScale </summary>*)
    
    function SubScaled(const X: TVec; const Y, Z: TMtxVec; const zScale: TCplx): Vector; overload;
    (*<summary> Compute X - Y - Z*zScale, where X is a Matrix. </summary>*)
    
    function SubScaled(const X: TMtx; const Y, Z: TMtxVec; const zScale: TCplx): Matrix; overload;

    (*<summary> Compute X - Y - zScalar </summary>

     
<remarks>Computes the difference between X and Y and then subtracts a scalar zScalar,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScalar = 3.0;
         Vector X = (Vector) new double[] { 5, 6, 7, 8 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector A1 = X - Y - zScalar;
         Vector A2 = Sub(X, Y, zScalar);
         Vector A3 = new Vector();
         A3.Sub(X, Y, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function Sub(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  (*<summary> Compute X - Y - zScalar, where X is a Matrix. </summary>*)
  
  function Sub(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  (*<summary> Compute X - Y - zScalar </summary>*)
  
  function Sub(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;
  (*<summary> Compute X - Y - zScalar, where X is a Matrix. </summary>*)
  
  function Sub(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  (*<summary> Compute X - Y*yScale - zScalar </summary>

     
<remarks>Computes the result of subtracting Y scaled by yScale and a scalar zScalar from X,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScale = 1.5, zScalar = 3.0;
         Vector X = (Vector) new double[] { 5, 6, 7, 8 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector A1 = X - Y * yScale - zScalar;
         Vector A2 = SubScaledC(X, yScale, Y, zScalar); // Adjust parameter order if needed.
         Vector A3 = new Vector();
         A3.SubScaledC(X, yScale, Y, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubScaledC(const X: TVec; const Y: TMtxVec; const yScale: Double; const Z: Double): Vector; overload;

  (*<summary> Compute X - Y*yScale - zScalar, where X is a Matrix </summary>*)
  
  function SubScaledC(const X: TMtx; const Y: TMtxVec; const yScale: Double; const Z: Double): Matrix; overload;

  (*<summary> Compute X - Y*yScale - zScalar </summary>*)
  
  function SubScaledC(const X: TVec; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Vector; overload;

  (*<summary> Compute X - Y*yScale - zScalar, where X  is a Matrix</summary>*)
  
  function SubScaledC(const X: TMtx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Matrix; overload;

  (*<summary> Compute X * Y / Z </summary>

     
<remarks>Computes the element-wise product of X and Y, then divides the result by Z,
     all without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         Vector X = (Vector) new double[] { 4, 8, 12, 16 };
         Vector Y = (Vector) new double[] { 2, 2, 2, 2 };
         Vector Z = (Vector) new double[] { 2, 4, 6, 8 };
         Vector A1 = (X * Y) / Z;
         Vector A2 = MulAndDiv(X, Y, Z);
         Vector A3 = new Vector();
         A3.MulAndDiv(X, Y, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function MulAndDiv(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  (*<summary> Compute X * Y / Z, where X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function MulAndDiv(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

  (*<summary> Compute (X + Y)*Z </summary>

     
<remarks>Computes the product of the sum of X and Y multiplied by Z without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X + Y) * Z;
         Vector A2 = AddAndMul(X, Y, Z);
         Vector A3 = new Vector();
         A3.AddAndMul(X, Y, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  (*<summary> Compute (X + Y)*Z, where X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

  (*<summary> Compute (X + Y)*Z*zScale </summary>

     
<remarks>Computes the product of (X + Y) multiplied by Z and then by the scalar zScale,
     all without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScale = 2.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X + Y) * Z * zScale;
         Vector A2 = AddAndMul(X, Y, Z, zScale);
         Vector A3 = new Vector();
         A3.AddAndMul(X, Y, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const Y, Z: TMtxVec; const zScale: double): Vector; overload;

  (*<summary> Compute (X + Y)*Z*zScale, where X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const Y, Z: TMtxVec; const zScale: double): Matrix; overload;

  (*<summary> Compute (X + Y*yScale)*Z*zScale </summary>

     
<remarks>Computes the product of (X plus Y scaled by yScale) multiplied by Z and then by zScale,
     without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScale = 1.5, zScale = 2.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X + Y * yScale) * Z * zScale;
         Vector A2 = AddAndMul(X, yScale, Y, yScale, Z, zScale);
         Vector A3 = new Vector();
         A3.AddAndMul(X, yScale, Y, yScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)

  
  function AddAndMul(const X: TVec; const Y: TMtxVec; const yScale: double; const Z: TMtxVec; const zScale: double): Vector; overload;

  (*<summary> Compute (X + Y*yScale)*Z*zScale, where X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const Y: TMtxVec; const yScale: double; const Z: TMtxVec; const zScale: double): Matrix; overload;

  (*<summary> Compute (X + Y)*zScalar </summary>

     
<remarks>Computes the sum of X and Y multiplied by the scalar zScalar without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector A1 = (X + Y) * zScalar;
         Vector A2 = AddAndMul(X, Y, zScalar);
         Vector A3 = new Vector();
         A3.AddAndMul(X, Y, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  (*<summary> Compute (X + Y)*zScalar, where X is a Matrix </summary>*)
  
  function AddAndMul(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  (*<summary> Compute (X + Y*yScale)*zScalar </summary>

     
<remarks>Computes the expression (X + Y*yScale) multiplied by a scalar zScalar without temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScale = 1.5, zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Y = (Vector) new double[] { 2, 3, 4, 5 };
         Vector A1 = (X + Y * yScale) * zScalar;
         Vector A2 = AddAndMul(X, yScale, Y, yScale, zScalar);
         Vector A3 = new Vector();
         A3.AddAndMul(X, yScale, Y, yScale, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const Y: TMtxVec; const yScale, Z: Double): Vector; overload;

  (*<summary> Compute (X + Y*yScale)*zScalar, where X is a Matrix. </summary>*)
  
  function AddAndMul(const X: TMtx; const Y: TMtxVec; const yScale, Z: Double): Matrix; overload;

  (*<summary> Compute (X + yScalar)*Z*zScale</summary>

     
<remarks>Computes the expression (X + yScalar) multiplied by Z and then by zScale,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScalar = 2.0, zScale = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X + yScalar) * Z * zScale;
         Vector A2 = AddAndMul(X, yScalar, Z, zScale);
         Vector A3 = new Vector();
         A3.AddAndMul(X, yScalar, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; Y: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute (X + yScalar)*Z*zScale, where X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; Y: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute (X*xScale + yScalar)*Z</summary>

     
<remarks>Computes the expression (X scaled by xScale plus the scalar yScalar) multiplied by Z,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double xScale = 1.0, yScalar = 2.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X * xScale + yScalar) * Z;
         Vector A2 = AddAndMul(X, xScale, yScalar, Z);
         Vector A3 = new Vector();
         A3.AddAndMul(X, xScale, yScalar, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; const xScale, Y: Double; const Z: TMtxVec): Vector; overload;

  (*<summary> Compute (X*xScale + yScalar)*Z, where X is a Matrix. </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function AddAndMul(const X: TMtx; const xScale, Y: Double; const Z: TMtxVec): Matrix; overload;

  (*<summary> Compute (X + yScalar)*Z</summary>

     
<remarks>Computes the expression (X plus the scalar yScalar) multiplied by Z,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScalar = 2.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 3, 4, 5, 6 };
         Vector A1 = (X + yScalar) * Z;
         Vector A2 = AddAndMul(X, yScalar, Z);
         Vector A3 = new Vector();
         A3.AddAndMul(X, yScalar, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; Y: Double; const Z: TMtxVec): Vector; overload;

  (*<summary> Compute (X + yScalar)*Z, where X is a Matrix</summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)

  
  function AddAndMul(const X: TMtx; Y: Double; const Z: TMtxVec): Matrix; overload;


  (*<summary> Compute (X + yScalar)*zScalar</summary>

     
<remarks>Computes the result of adding the scalar yScalar to X and then multiplying by the scalar zScalar,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScalar = 2.0, zScalar = 3.0;
         Vector X = (Vector) new double[] { 1, 2, 3, 4 };
         Vector A1 = (X + yScalar) * zScalar;
         Vector A2 = AddAndMul(X, yScalar, zScalar);
         Vector A3 = new Vector();
         A3.AddAndMul(X, yScalar, zScalar);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function AddAndMul(const X: TVec; Y, Z: Double): Vector; overload;

  (*<summary> Compute (X + yScalar)*zScalar, where X is a Matrix</summary>*)
  
  function AddAndMul(const X: TMtx; Y, Z: Double): Matrix; overload;


  (*<summary> Compute (X - Y)*Z </summary>

     
<remarks>Computes the product of the difference between X and Y multiplied by Z without
     creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         Vector X = (Vector) new double[] { 5, 6, 7, 8 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 2, 2, 2, 2 };
         Vector A1 = (X - Y) * Z;
         Vector A2 = SubAndMul(X, Y, Z);
         Vector A3 = new Vector();
         A3.SubAndMul(X, Y, Z);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubAndMul(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  (*<summary> Compute (X - Y)*Z, where X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)
  
  function SubAndMul(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

  (*<summary> Compute (X - Y)*Z*zScale </summary>

     
<remarks>Computes the product of (X - Y) multiplied by Z and then scaled by zScale, without
     creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double zScale = 3.0;
         Vector X = (Vector) new double[] { 5, 6, 7, 8 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 2, 2, 2, 2 };
         Vector A1 = (X - Y) * Z * zScale;
         Vector A2 = SubAndMul(X, Y, Z, zScale);
         Vector A3 = new Vector();
         A3.SubAndMul(X, Y, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubAndMul(const X: TVec; const Y, Z: TMtxVec; const zScale: Double): Vector; overload;

  (*<summary> Compute (X - Y)*Z*zScale, where X is a Matrix </summary>
               
<remarks>The operation does only per-element math.
</remarks>
*)

  
  function SubAndMul(const X: TMtx; const Y, Z: TMtxVec; const zScale: Double): Matrix; overload;

  (*<summary> Compute (X - Y*yScale)*Z*zScale </summary>

     
<remarks>Computes the product of (X minus Y scaled by yScale) multiplied by Z and then by zScale,
     without creating temporary objects.
</remarks>


     

     <example>:
     <code>
     using Dew.Math;
     using Dew.Math.Units;

     namespace Dew.Examples
     {
       void Example()
       {
         double yScale = 1.5, zScale = 2.0;
         Vector X = (Vector) new double[] { 5, 6, 7, 8 };
         Vector Y = (Vector) new double[] { 1, 2, 3, 4 };
         Vector Z = (Vector) new double[] { 2, 2, 2, 2 };
         Vector A1 = (X - Y * yScale) * Z * zScale;
         Vector A2 = SubAndMul(X, yScale, Y, yScale, Z, zScale);
         Vector A3 = new Vector();
         A3.SubAndMul(X, yScale, Y, yScale, Z, zScale);
         if (!A2.IsEqual(A1)) Math387.ERaise("Problem");
         if (!A3.IsEqual(A1)) Math387.ERaise("Problem");
       }
     }
     </code></example>*)
  
  function SubAndMul(const X: TVec; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y: TMtxVec; const yScale: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y: TMtxVec; const yScale: Double; const Z: Double): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y: TMtxVec; const yScale: Double; const Z: Double): Matrix; overload;


  
  
  function SubAndMul(const X: TVec; Y: Double; const Z: TMtxVec; const zScale: Double): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; Y: Double; const Z: TMtxVec; const zScale: Double): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const xScale, Y: Double; const Z: TMtxVec): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const xScale, Y: Double; const Z: TMtxVec): Matrix; overload;


  
  
  function SubAndMul(const X: TVec; Y: Double; const Z: TMtxVec): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; Y: Double; const Z: TMtxVec): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; Y, Z: Double): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; Y, Z: Double): Matrix; overload;

  
  
  function MulAndSub(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  
  
  function MulAndSub(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;


  
  
  function MulAndSub(const X: TVec; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec): Vector; overload;

  

  
  function MulAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: Double; const Z: TMtxVec): Matrix; overload;

  
  
  function MulAndSub(const X: TVec; const Y, Z: TMtxVec; const zScale: Double): Vector; overload;

  
  
  function MulAndSub(const X: TMtx; const Y, Z: TMtxVec; const zScale: Double): Matrix; overload;

  
  
  function MulAndSub(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  
  
  function MulAndSub(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

   
  
  function DivAndAdd(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  
  
  function DivAndAdd(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

    
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: double; const Z: TMtxVec): Vector; overload;
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: double; const Z: TMtxVec): Matrix; overload;

   
  
  function DivAndAdd(const X: TVec; const Y, Z: TMtxVec; const zScale: double): Vector; overload;

   
  
  function DivAndAdd(const X: TMtx; const Y, Z: TMtxVec; const zScale: double): Matrix; overload;

  
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  
  
  function DivAndSub(const X: TVec; const Y, Z: TMtxVec): Vector; overload;

  
  
  function DivAndSub(const X: TMtx; const Y, Z: TMtxVec): Matrix; overload;

  
  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const xyScale: double; const Z: TMtxVec): Vector; overload;

  
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: double; const Z: TMtxVec): Matrix; overload;


  
  
  function DivAndSub(const X: TVec; const Y, Z: TMtxVec; const zScale: double): Vector; overload;

  
  
  function DivAndSub(const X: TMtx; const Y, Z: TMtxVec; const zScale: double): Matrix; overload;


  

  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const Z: Double): Vector; overload;

  
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const Z: Double): Matrix; overload;

  
  
  function AddScaled(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): Vector; overload;

  
  
  function AddScaled(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): Matrix; overload;

  
  
  function AddScaledSqr(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): Vector; overload;

  
  
  function AddScaledSqr(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): Matrix; overload;

  
  
  function SqrAddScaled(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): Vector; overload;

  
  
  function SqrAddScaled(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx): Matrix; overload;

  
  
  function AddScaledSqr(const X: TVec; const Y: TMtxVec; const yScale: TCplx): Vector; overload;

  
  
  function AddScaledSqr(const X: TMtx; const Y: TMtxVec; const yScale: TCplx): Matrix; overload;

  
  
  function SqrAddScaled(const X: TVec; const Y: TMtxVec; const yScale: TCplx): Vector; overload;

  
  
  function SqrAddScaled(const X: TMtx; const Y: TMtxVec; const yScale: TCplx): Matrix; overload;

  
  
  function AddScaled(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function AddScaled(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function AddScaledC(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Vector; overload;

  
  
  function AddScaledC(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Matrix; overload;

  
  
  function SubScaled(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function SubScaled(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function SubScaledC(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Vector; overload;

  
  
  function SubScaledC(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Matrix; overload;

  
  
  function MulElem(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  
  
  function MulElem(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  
  
  function DivideElem(const X: TCplx; const Y: TVec; const Z: TMtxVec): Vector; overload;

  
  
  function DivideElem(const X: TCplx; const Y: TMtx; const Z: TMtxVec): Matrix; overload;

  
  
  function DivideElemC(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  
  
  function DivideElemC(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  
  
  function MulAndDiv(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Vector; overload;

  
  
  function MulAndDiv(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Matrix; overload;

  
  
  function MulAndDiv(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  
  
  function MulAndDiv(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  
  
  function AddAndMul(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function AddAndMul(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function AddAndMul(const X: TVec; const xScale: TCplx; Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function AddAndMul(const X: TMtx; const xScale: TCplx; Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function AddAndMul(const X: TVec; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Vector; overload;

  
  
  function AddAndMul(const X: TMtx; const xScale: TCplx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Matrix; overload;

  
  
  function AddAndMul(const X: TVec; const xScale: TCplx; Y, Z: TCplx): Vector; overload;

  
  
  function AddAndMul(const X: TMtx; const xScale: TCplx; Y, Z: TCplx): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y: TMtxVec; const yScale: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y, Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y, Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y: TMtxVec; const yScale: TCplx; const Z: TCplx): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; Y: TCplx; const Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const xScale, Y: TCplx; const Z: TMtxVec): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const xScale, Y: TCplx; const Z: TMtxVec): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y: TCplx; const Z: TMtxVec): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y: TCplx; const Z: TMtxVec): Matrix; overload;

  
  
  function SubAndMul(const X: TVec; const Y, Z: TCplx): Vector; overload;

  
  
  function SubAndMul(const X: TMtx; const Y, Z: TCplx): Matrix; overload;

  
  
  function MulAndSub(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Vector; overload;

  
  
  function MulAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Matrix; overload;

  
  
  function MulAndSub(const X: TVec; const Y, Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function MulAndSub(const X: TMtx; const Y, Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function MulAndSub(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  
  
  function MulAndSub(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Vector; overload;

  
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Matrix; overload;

  
  
  function DivAndAdd(const X: TVec; const Y, Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function DivAndAdd(const X: TMtx; const Y, Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function DivAndAdd(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  
  
  function DivAndAdd(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  
  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Vector; overload;

  
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const xyScale: TCplx; const Z: TMtxVec): Matrix; overload;

  
  
  function DivAndSub(const X: TVec; const Y, Z: TMtxVec; const zScale: TCplx): Vector; overload;

  
  
  function DivAndSub(const X: TMtx; const Y, Z: TMtxVec; const zScale: TCplx): Matrix; overload;

  
  
  function DivAndSub(const X: TVec; const Y: TMtxVec; const Z: TCplx): Vector; overload;

  
  
  function DivAndSub(const X: TMtx; const Y: TMtxVec; const Z: TCplx): Matrix; overload;

  
  
  function GatherSplit(const MaskVec, NotMaskVec: TVec; const Mask: TVecInt): Vector;



  
      
  


  
  
  function SortAscend(const X: TMtx): Matrix; overload;

  
  
  function SortAscend(const X: TMtx; Col: integer): Matrix; overload;

  

  
  function Sqr(const X :double): double; overload;

  
  function Round(const X: double): Int64; overload;
  function Roundf(const X: single): Int64; overload;

  
  
  function Trunc(const X: double): Int64; overload;
  function Truncf(const X: single): Int64; overload;


  
  function Abs(const X :double): double; overload; 
  
  function Abs(const X :integer): integer; overload; 


  

  
  function Sgn(const Src: TVec): Vector; overload;

  
  function Sgn(const Src: TMtx): Matrix; overload;










